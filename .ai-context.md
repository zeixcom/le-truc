# AI Context â€” Le Truc

**Le Truc** is a TypeScript library for building reactive web components using signals and native custom elements. It provides a declarative, type-safe approach to component development with automatic DOM updates and minimal runtime overhead.

## Core Concepts

### Component Definition
Components are defined using the `defineComponent()` function with four parameters:

```typescript
defineComponent(
  'component-name',         // Must contain hyphen, lowercase
  { prop: initializer },    // Properties become signals
  ({ first, all }) => ({}), // UI element selectors
  ui => ({})                // Effects that run reactively
)
```

### Property System
Properties are reactive signals that can be initialized in multiple ways:

- **Static values**: `{ message: 'Hello' }`
- **Parsers**: `{ count: asNumber() }` - transform attributes to typed values
- **Signals**: `{ state: createState(false) }` - external reactive values
- **Initializers**: `{ timestamp: ui => ui.host.hasAttribute('created')
    ? Number(ui.host.getAttribute('created'))
    : Date.now() }` - computed on connection
- **Readers**: `read(ui => ui.input.value, fallback)` - read from DOM

Parsers automatically handle attribute synchronization and are added to `observedAttributes`.

### UI Query System
The selector function provides type-safe DOM queries:

```typescript
({ first, all }) => ({
  button?: first('button'),          // HTMLButtonElement | undefined
  input: first('input', 'required'), // HTMLInputElement (throws if missing)
  items: all('.item'),               // Collection<HTMLElement>
  custom?: first<MyElement>('my-el') // Custom typing
})
```

Collections are reactive arrays that emit `add`/`remove` events and track DOM mutations automatically.

### Effect System
Effects run reactively when dependencies change:

```typescript
({ host }) => ({
  button: [
    on('click', () => ({ count: host.count + 1 })),        // Event handlers
    setText('count'),                                      // Text updates
    setAttribute('disabled', () => host.loading),          // Attributes
    toggleClass('active', 'isActive'),                     // CSS classes
    setProperty('value', 'currentValue'),                  // Properties
    (host, target) => createEffect(() => { /* custom */ }) // Custom effects
  ]
})
```

## Built-in Effects

### Event Handling
- `on(event, handler, options?)`   - Attach event listeners
- Handlers return object to update host properties: `{ prop: newValue }`

### DOM Updates
- `setText(property)`               - Update text content
- `setAttribute(attr, reactive)`    - Set/remove attributes
- `toggleAttribute(attr, property)` - Conditional attributes
- `setProperty(prop, reactive)`     - Update element properties
- `show(property)`                  - Toggle element visibility

### Styling
- `toggleClass(className, property)` - Conditional CSS classes
- `setStyle(property, reactive)`     - Update inline styles

### Advanced
- `pass(props)`                               - Pass properties to child components
- `dangerouslySetInnerHTML(reactive)`         - Set innerHTML (use carefully)
- `insertOrRemoveElement(reactive, inserter)` - Dynamic element creation/removal

## Parsers

Transform attribute strings to typed values:

- `asString(fallback?)`                          - String values
- `asNumber(fallback?)` / `asInteger(fallback?)` - Numeric values
- `asBoolean()`                                  - Boolean attributes (presence = true)
- `asJSON(fallback)`                             - Parse JSON strings
- `asEnum(values)`                               - Constrain to specific values

Custom parsers follow the signature: `(ui, value, oldValue) => parsedValue`

## Signal Integration

Built on `@zeix/cause-effect` signals:

- **State**: `createState(value)`               - mutable reactive value
- **Computed**: `createComputed(() => derived)` - derived reactive value
- **Effects**: `createEffect(() => sideEffect)` - reactive side effects
- **Batching**: `batch(() => updates)`          - group multiple updates

Access signals in effects via properties or direct signal methods:

```typescript
// Via properties from public interface
setText('value')                  // By property key
setText(() => String(host.count)) // By a function

// Direct signal access for private signals
const countSignal = createState(0)
setText(() => countSignal.get())
```

## Collections

Read-only reactive element arrays with array-like interface:

```typescript
// Creation
({ all }) => ({ items: all('.item') })          // In UI query, will be ui.items
const items = createCollection(parent, '.item') // Elsewhere with arbitrary parent

// Access
items.get()            // Get current elements
items.length           // Reactive length
items[0]               // Index access
items.on('add', fn)    // Listen for additions
items.on('remove', fn) // Listen for removals
```

## Common Patterns

### Form Components
```typescript
defineComponent('text-input', {
  value: asString(),
  required: asBoolean()
}, q => ({ input: q.first('input') }), ui => ({
  input: [
    setProperty('value'),
    setProperty('required'),
    on('change', ({ target }) => ({ value: target.value }))
  ]
}))
```

### List Components
```typescript
defineComponent('todo-list', {
  items: asJSON([])
}, q => ({
  list: q.first('ul'),
  items: q.all('li')
}), ui => ({
  items: toggleClass('completed', item =>
    ui.host.items.find(todo => todo.id === item.dataset.id)?.done
  )
}))
```

### Conditional Visibility
```typescript
ui => ({
  errorMsg: show(() => !!host.error),
  loadingSpinner: show('loading'),
  successIcon: show(() => host.status === 'success')
})
```

## Error Handling

Development mode (`process.env.DEV_MODE=true`) provides detailed errors:

- `InvalidComponentNameError` - Invalid component names
- `InvalidPropertyNameError` - Property name conflicts with HTML/DOM APIs
- `MissingElementError` - Required UI elements not found
- `DependencyTimeoutError` - Custom element dependencies timeout
- `InvalidEffectsError` - Effect setup failures

Enable debug logging on instances: `component.debug = true`

## TypeScript Integration

Full type safety with proper declarations:

```typescript
type MyComponentProps = {
  count: number
  message: string
}

type MyComponentUI = {
  button: HTMLButtonElement
  output: HTMLOutputElement
}

declare global {
  interface HTMLElementTagNameMap {
    'my-component': Component<MyComponentProps>
  }
}

export default defineComponent<MyComponentProps, MyComponentUI>(...)
```

## Best Practices

### Component Design
- Keep components focused on single responsibilities
- Use semantic HTML structure in component templates
- Leverage native form validation and accessibility features
- Prefer composition over inheritance

### State Management
- Use local component state for UI-specific data
- Lift state up for shared data between components
- Consider external signal stores `createStore()` for global state
- Batch related updates for performance

### Performance
- Effects automatically optimize re-runs when dependencies don't change
- Collections efficiently track only actual DOM changes
- Use `schedule()` for non-critical updates in passive event handlers
- Proper cleanup prevents memory leaks

### Testing
- Components work with standard DOM testing libraries
- Set properties directly on component instances
- Use `@playwright/test` for integration testing

This context provides the essential knowledge for building components with Le Truc's signal-based reactive system and type-safe DOM interaction patterns.
