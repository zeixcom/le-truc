{
  "version": 3,
  "sources": ["../../node_modules/@zeix/cause-effect/src/errors.ts", "../../node_modules/@zeix/cause-effect/src/util.ts", "../../node_modules/@zeix/cause-effect/src/diff.ts", "../../node_modules/@zeix/cause-effect/src/system.ts", "../../node_modules/@zeix/cause-effect/src/computed.ts", "../../node_modules/@zeix/cause-effect/src/effect.ts", "../../node_modules/@zeix/cause-effect/src/state.ts", "../../node_modules/@zeix/cause-effect/src/store.ts", "../../node_modules/@zeix/cause-effect/src/signal.ts", "../../src/util.ts", "../../src/errors.ts", "../../src/signals/collection.ts", "../../src/effects.ts", "../../src/parsers.ts", "../../src/ui.ts", "../../src/component.ts", "../../src/context.ts", "../../src/effects/attribute.ts", "../../src/effects/class.ts", "../../src/scheduler.ts", "../../src/effects/event.ts", "../../src/effects/html.ts", "../../src/effects/pass.ts", "../../src/effects/property.ts", "../../src/effects/text.ts", "../../src/parsers/boolean.ts", "../../src/parsers/number.ts", "../../src/parsers/string.ts", "../../src/signals/sensor.ts", "../../examples/basic-hello/basic-hello.ts", "../../examples/basic-button/basic-button.ts", "../../examples/basic-counter/basic-counter.ts", "../../examples/basic-number/basic-number.ts", "../../examples/basic-pluralize/basic-pluralize.ts", "../../examples/context-media/context-media.ts", "../../examples/card-mediaqueries/card-mediaqueries.ts", "../../examples/form-checkbox/form-checkbox.ts", "../../examples/_common/clear.ts", "../../examples/form-combobox/form-combobox.ts", "../../examples/_common/fetch.ts", "../../examples/_common/focus.ts", "../../examples/_common/highlight.ts", "../../examples/form-listbox/form-listbox.ts", "../../examples/form-radiogroup/form-radiogroup.ts", "../../examples/form-spinbutton/form-spinbutton.ts", "../../examples/form-textbox/form-textbox.ts", "../../examples/module-carousel/module-carousel.ts", "../../examples/module-catalog/module-catalog.ts", "../../examples/basic-button/copyToClipboard.ts", "../../examples/module-codeblock/module-codeblock.ts", "../../examples/module-dialog/module-dialog.ts", "../../examples/module-lazyload/module-lazyload.ts", "../../examples/module-list/module-list.ts", "../../examples/module-pagination/module-pagination.ts", "../../examples/module-scrollarea/module-scrollarea.ts", "../../examples/module-tabgroup/module-tabgroup.ts", "../../examples/module-todo/module-todo.ts"],
  "sourcesContent": [
    "class CircularDependencyError extends Error {\n\tconstructor(where: string) {\n\t\tsuper(`Circular dependency detected in ${where}`)\n\t\tthis.name = 'CircularDependencyError'\n\t}\n}\n\nclass InvalidCallbackError extends TypeError {\n\tconstructor(where: string, value: string) {\n\t\tsuper(`Invalid ${where} callback ${value}`)\n\t\tthis.name = 'InvalidCallbackError'\n\t}\n}\n\nclass InvalidSignalValueError extends TypeError {\n\tconstructor(where: string, value: string) {\n\t\tsuper(`Invalid signal value ${value} in ${where}`)\n\t\tthis.name = 'InvalidSignalValueError'\n\t}\n}\n\nclass NullishSignalValueError extends TypeError {\n\tconstructor(where: string) {\n\t\tsuper(`Nullish signal values are not allowed in ${where}`)\n\t\tthis.name = 'NullishSignalValueError'\n\t}\n}\n\nclass StoreKeyExistsError extends Error {\n\tconstructor(key: string, value: string) {\n\t\tsuper(\n\t\t\t`Could not add store key \"${key}\" with value ${value} because it already exists`,\n\t\t)\n\t\tthis.name = 'StoreKeyExistsError'\n\t}\n}\n\nclass StoreKeyRangeError extends RangeError {\n\tconstructor(index: number) {\n\t\tsuper(\n\t\t\t`Could not remove store index ${String(index)} because it is out of range`,\n\t\t)\n\t\tthis.name = 'StoreKeyRangeError'\n\t}\n}\n\nclass StoreKeyReadonlyError extends Error {\n\tconstructor(key: string, value: string) {\n\t\tsuper(\n\t\t\t`Could not set store key \"${key}\" to ${value} because it is readonly`,\n\t\t)\n\t\tthis.name = 'StoreKeyReadonlyError'\n\t}\n}\n\nexport {\n\tCircularDependencyError,\n\tInvalidCallbackError,\n\tInvalidSignalValueError,\n\tNullishSignalValueError,\n\tStoreKeyExistsError,\n\tStoreKeyRangeError,\n\tStoreKeyReadonlyError,\n}\n",
    "/* === Constants === */\n\n// biome-ignore lint/suspicious/noExplicitAny: Deliberately using any to be used as a placeholder value in any signal\nconst UNSET: any = Symbol()\n\n/* === Utility Functions === */\n\nconst isString = /*#__PURE__*/ (value: unknown): value is string =>\n\ttypeof value === 'string'\n\nconst isNumber = /*#__PURE__*/ (value: unknown): value is number =>\n\ttypeof value === 'number'\n\nconst isSymbol = /*#__PURE__*/ (value: unknown): value is symbol =>\n\ttypeof value === 'symbol'\n\nconst isFunction = /*#__PURE__*/ <T>(\n\tfn: unknown,\n): fn is (...args: unknown[]) => T => typeof fn === 'function'\n\nconst isAsyncFunction = /*#__PURE__*/ <T>(\n\tfn: unknown,\n): fn is (...args: unknown[]) => Promise<T> =>\n\tisFunction(fn) && fn.constructor.name === 'AsyncFunction'\n\nconst isObjectOfType = /*#__PURE__*/ <T>(\n\tvalue: unknown,\n\ttype: string,\n): value is T => Object.prototype.toString.call(value) === `[object ${type}]`\n\nconst isRecord = /*#__PURE__*/ <T extends Record<string, unknown>>(\n\tvalue: unknown,\n): value is T => isObjectOfType(value, 'Object')\n\nconst isRecordOrArray = /*#__PURE__*/ <\n\tT extends Record<string | number, unknown> | ReadonlyArray<unknown>,\n>(\n\tvalue: unknown,\n): value is T => isRecord(value) || Array.isArray(value)\n\nconst validArrayIndexes = /*#__PURE__*/ (\n\tkeys: Array<PropertyKey>,\n): number[] | null => {\n\tif (!keys.length) return null\n\tconst indexes = keys.map(k =>\n\t\tisString(k) ? parseInt(k, 10) : isNumber(k) ? k : NaN,\n\t)\n\treturn indexes.every(index => Number.isFinite(index) && index >= 0)\n\t\t? indexes.sort((a, b) => a - b)\n\t\t: null\n}\n\nconst hasMethod = /*#__PURE__*/ <\n\tT extends object & Record<string, (...args: unknown[]) => unknown>,\n>(\n\tobj: T,\n\tmethodName: string,\n): obj is T & Record<string, (...args: unknown[]) => unknown> =>\n\tmethodName in obj && isFunction(obj[methodName])\n\nconst isAbortError = /*#__PURE__*/ (error: unknown): boolean =>\n\terror instanceof DOMException && error.name === 'AbortError'\n\nconst toError = /*#__PURE__*/ (reason: unknown): Error =>\n\treason instanceof Error ? reason : Error(String(reason))\n\nconst arrayToRecord = /*#__PURE__*/ <T>(array: T[]): Record<string, T> => {\n\tconst record: Record<string, T> = {}\n\tfor (let i = 0; i < array.length; i++) record[String(i)] = array[i]\n\treturn record\n}\n\nconst recordToArray = /*#__PURE__*/ <T>(\n\trecord: Record<string | number, T>,\n): Record<string, T> | T[] => {\n\tconst indexes = validArrayIndexes(Object.keys(record))\n\tif (indexes === null) return record\n\n\tconst array: T[] = []\n\tfor (const index of indexes) array.push(record[String(index)])\n\treturn array\n}\n\nconst valueString = /*#__PURE__*/ (value: unknown): string =>\n\tisString(value)\n\t\t? `\"${value}\"`\n\t\t: !!value && typeof value === 'object'\n\t\t\t? JSON.stringify(value)\n\t\t\t: String(value)\n\n/* === Exports === */\n\nexport {\n\tUNSET,\n\tisString,\n\tisNumber,\n\tisSymbol,\n\tisFunction,\n\tisAsyncFunction,\n\tisObjectOfType,\n\tisRecord,\n\tisRecordOrArray,\n\thasMethod,\n\tisAbortError,\n\ttoError,\n\tarrayToRecord,\n\trecordToArray,\n\tvalueString,\n}\n",
    "import { CircularDependencyError } from './errors'\nimport { isRecord, isRecordOrArray, UNSET } from './util'\n\n/* === Types === */\n\ntype UnknownRecord = Record<string, unknown & {}>\ntype UnknownArray = ReadonlyArray<unknown & {}>\n\ntype ArrayToRecord<T extends UnknownArray> = {\n\t[key: string]: T extends Array<infer U extends {}> ? U : never\n}\n\ntype PartialRecord<T> = T extends UnknownArray\n\t? Partial<ArrayToRecord<T>>\n\t: Partial<T>\n\ntype DiffResult<T extends UnknownRecord | UnknownArray = UnknownRecord> = {\n\tchanged: boolean\n\tadd: PartialRecord<T>\n\tchange: PartialRecord<T>\n\tremove: PartialRecord<T>\n}\n\n/* === Functions === */\n\n/**\n * Checks if two values are equal with cycle detection\n *\n * @since 0.15.0\n * @param {T} a - First value to compare\n * @param {T} b - Second value to compare\n * @param {WeakSet<object>} visited - Set to track visited objects for cycle detection\n * @returns {boolean} Whether the two values are equal\n */\nconst isEqual = <T>(a: T, b: T, visited?: WeakSet<object>): boolean => {\n\t// Fast paths\n\tif (Object.is(a, b)) return true\n\tif (typeof a !== typeof b) return false\n\tif (typeof a !== 'object' || a === null || b === null) return false\n\n\t// Cycle detection\n\tif (!visited) visited = new WeakSet()\n\tif (visited.has(a as object) || visited.has(b as object))\n\t\tthrow new CircularDependencyError('isEqual')\n\tvisited.add(a as object)\n\tvisited.add(b as object)\n\n\ttry {\n\t\tif (Array.isArray(a) && Array.isArray(b)) {\n\t\t\tif (a.length !== b.length) return false\n\t\t\tfor (let i = 0; i < a.length; i++) {\n\t\t\t\tif (!isEqual(a[i], b[i], visited)) return false\n\t\t\t}\n\t\t\treturn true\n\t\t}\n\n\t\tif (Array.isArray(a) !== Array.isArray(b)) return false\n\n\t\tif (isRecord(a) && isRecord(b)) {\n\t\t\tconst aKeys = Object.keys(a)\n\t\t\tconst bKeys = Object.keys(b)\n\n\t\t\tif (aKeys.length !== bKeys.length) return false\n\t\t\tfor (const key of aKeys) {\n\t\t\t\tif (!(key in b)) return false\n\t\t\t\tif (\n\t\t\t\t\t!isEqual(\n\t\t\t\t\t\t(a as Record<string, unknown>)[key],\n\t\t\t\t\t\t(b as Record<string, unknown>)[key],\n\t\t\t\t\t\tvisited,\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t\treturn false\n\t\t\t}\n\t\t\treturn true\n\t\t}\n\n\t\t// For non-records/non-arrays, they are only equal if they are the same reference\n\t\t// (which would have been caught by Object.is at the beginning)\n\t\treturn false\n\t} finally {\n\t\tvisited.delete(a as object)\n\t\tvisited.delete(b as object)\n\t}\n}\n\n/**\n * Compares two records and returns a result object containing the differences.\n *\n * @since 0.15.0\n * @param {T} oldObj - The old record to compare\n * @param {T} newObj - The new record to compare\n * @returns {DiffResult<T>} The result of the comparison\n */\nconst diff = <T extends UnknownRecord | UnknownArray>(\n\toldObj: T extends UnknownArray ? ArrayToRecord<T> : T,\n\tnewObj: T extends UnknownArray ? ArrayToRecord<T> : T,\n): DiffResult<T> => {\n\t// Guard against non-objects that can't be diffed properly with Object.keys and 'in' operator\n\tconst oldValid = isRecordOrArray(oldObj)\n\tconst newValid = isRecordOrArray(newObj)\n\tif (!oldValid || !newValid) {\n\t\t// For non-objects or non-plain objects, treat as complete change if different\n\t\tconst changed = !Object.is(oldObj, newObj)\n\t\treturn {\n\t\t\tchanged,\n\t\t\tadd: changed && newValid ? newObj : ({} as PartialRecord<T>),\n\t\t\tchange: {} as PartialRecord<T>,\n\t\t\tremove: changed && oldValid ? oldObj : ({} as PartialRecord<T>),\n\t\t}\n\t}\n\n\tconst visited = new WeakSet()\n\n\tconst add = {} as PartialRecord<T>\n\tconst change = {} as PartialRecord<T>\n\tconst remove = {} as PartialRecord<T>\n\n\tconst oldKeys = Object.keys(oldObj)\n\tconst newKeys = Object.keys(newObj)\n\tconst allKeys = new Set([...oldKeys, ...newKeys])\n\n\tfor (const key of allKeys) {\n\t\tconst oldHas = key in oldObj\n\t\tconst newHas = key in newObj\n\n\t\tif (!oldHas && newHas) {\n\t\t\tadd[key] = newObj[key]\n\t\t\tcontinue\n\t\t} else if (oldHas && !newHas) {\n\t\t\tremove[key] = UNSET\n\t\t\tcontinue\n\t\t}\n\n\t\tconst oldValue = oldObj[key]\n\t\tconst newValue = newObj[key]\n\n\t\tif (!isEqual(oldValue, newValue, visited)) change[key] = newValue\n\t}\n\n\tconst changed =\n\t\tObject.keys(add).length > 0 ||\n\t\tObject.keys(change).length > 0 ||\n\t\tObject.keys(remove).length > 0\n\n\treturn {\n\t\tchanged,\n\t\tadd,\n\t\tchange,\n\t\tremove,\n\t}\n}\n\n/* === Exports === */\n\nexport {\n\ttype ArrayToRecord,\n\ttype DiffResult,\n\tdiff,\n\tisEqual,\n\ttype UnknownRecord,\n\ttype UnknownArray,\n\ttype PartialRecord,\n}\n",
    "/* === Types === */\n\ntype Cleanup = () => void\n\ntype Watcher = {\n\t(): void\n\tunwatch(cleanup: Cleanup): void\n\tcleanup(): void\n}\n\n/* === Internal === */\n\n// Currently active watcher\nlet activeWatcher: Watcher | undefined\n\n// Pending queue for batched change notifications\nconst pendingWatchers = new Set<Watcher>()\nlet batchDepth = 0\n\n/* === Functions === */\n\n/**\n * Create a watcher that can be used to observe changes to a signal\n *\n * @since 0.14.1\n * @param {() => void} watch - Function to be called when the state changes\n * @returns {Watcher} - Watcher object with off and cleanup methods\n */\nconst createWatcher = (watch: () => void): Watcher => {\n\tconst cleanups = new Set<Cleanup>()\n\tconst w = watch as Partial<Watcher>\n\tw.unwatch = (cleanup: Cleanup) => {\n\t\tcleanups.add(cleanup)\n\t}\n\tw.cleanup = () => {\n\t\tfor (const cleanup of cleanups) cleanup()\n\t\tcleanups.clear()\n\t}\n\treturn w as Watcher\n}\n\n/**\n * Add active watcher to the Set of watchers\n *\n * @param {Set<Watcher>} watchers - watchers of the signal\n */\nconst subscribe = (watchers: Set<Watcher>) => {\n\tif (activeWatcher && !watchers.has(activeWatcher)) {\n\t\tconst watcher = activeWatcher\n\t\twatcher.unwatch(() => {\n\t\t\twatchers.delete(watcher)\n\t\t})\n\t\twatchers.add(watcher)\n\t}\n}\n\n/**\n * Add watchers to the pending set of change notifications\n *\n * @param {Set<Watcher>} watchers - watchers of the signal\n */\nconst notify = (watchers: Set<Watcher>) => {\n\tfor (const watcher of watchers) {\n\t\tif (batchDepth) pendingWatchers.add(watcher)\n\t\telse watcher()\n\t}\n}\n\n/**\n * Flush all pending changes to notify watchers\n */\nconst flush = () => {\n\twhile (pendingWatchers.size) {\n\t\tconst watchers = Array.from(pendingWatchers)\n\t\tpendingWatchers.clear()\n\t\tfor (const watcher of watchers) watcher()\n\t}\n}\n\n/**\n * Batch multiple changes in a single signal graph and DOM update cycle\n *\n * @param {() => void} fn - function with multiple signal writes to be batched\n */\nconst batch = (fn: () => void) => {\n\tbatchDepth++\n\ttry {\n\t\tfn()\n\t} finally {\n\t\tflush()\n\t\tbatchDepth--\n\t}\n}\n\n/**\n * Run a function in a reactive context\n *\n * @param {() => void} run - function to run the computation or effect\n * @param {Watcher} watcher - function to be called when the state changes or undefined for temporary unwatching while inserting auto-hydrating DOM nodes that might read signals (e.g., web components)\n */\nconst observe = (run: () => void, watcher?: Watcher): void => {\n\tconst prev = activeWatcher\n\tactiveWatcher = watcher\n\ttry {\n\t\trun()\n\t} finally {\n\t\tactiveWatcher = prev\n\t}\n}\n\n/* === Exports === */\n\nexport {\n\ttype Cleanup,\n\ttype Watcher,\n\tsubscribe,\n\tnotify,\n\tflush,\n\tbatch,\n\tcreateWatcher,\n\tobserve,\n}\n",
    "import { isEqual } from './diff'\nimport {\n\tCircularDependencyError,\n\tInvalidCallbackError,\n\tNullishSignalValueError,\n} from './errors'\nimport {\n\tcreateWatcher,\n\tflush,\n\tnotify,\n\tobserve,\n\tsubscribe,\n\ttype Watcher,\n} from './system'\nimport {\n\tisAbortError,\n\tisAsyncFunction,\n\tisFunction,\n\tisObjectOfType,\n\ttoError,\n\tUNSET,\n\tvalueString,\n} from './util'\n\n/* === Types === */\n\ntype Computed<T extends {}> = {\n\treadonly [Symbol.toStringTag]: 'Computed'\n\tget(): T\n}\ntype ComputedCallback<T extends {} & { then?: undefined }> =\n\t| ((oldValue: T, abort: AbortSignal) => Promise<T>)\n\t| ((oldValue: T) => T)\n\n/* === Constants === */\n\nconst TYPE_COMPUTED = 'Computed'\n\n/* === Functions === */\n\n/**\n * Create a derived signal from existing signals\n *\n * @since 0.9.0\n * @param {ComputedCallback<T>} callback - Computation callback function\n * @returns {Computed<T>} - Computed signal\n */\nconst createComputed = <T extends {}>(\n\tcallback: ComputedCallback<T>,\n\tinitialValue: T = UNSET,\n): Computed<T> => {\n\tif (!isComputedCallback(callback))\n\t\tthrow new InvalidCallbackError('computed', valueString(callback))\n\tif (initialValue == null) throw new NullishSignalValueError('computed')\n\n\tconst watchers: Set<Watcher> = new Set()\n\n\t// Internal state\n\tlet value: T = initialValue\n\tlet error: Error | undefined\n\tlet controller: AbortController | undefined\n\tlet dirty = true\n\tlet changed = false\n\tlet computing = false\n\n\t// Functions to update internal state\n\tconst ok = (v: T): undefined => {\n\t\tif (!isEqual(v, value)) {\n\t\t\tvalue = v\n\t\t\tchanged = true\n\t\t}\n\t\terror = undefined\n\t\tdirty = false\n\t}\n\tconst nil = (): undefined => {\n\t\tchanged = UNSET !== value\n\t\tvalue = UNSET\n\t\terror = undefined\n\t}\n\tconst err = (e: unknown): undefined => {\n\t\tconst newError = toError(e)\n\t\tchanged =\n\t\t\t!error ||\n\t\t\tnewError.name !== error.name ||\n\t\t\tnewError.message !== error.message\n\t\tvalue = UNSET\n\t\terror = newError\n\t}\n\tconst settle =\n\t\t<T>(fn: (arg: T) => void) =>\n\t\t(arg: T) => {\n\t\t\tcomputing = false\n\t\t\tcontroller = undefined\n\t\t\tfn(arg)\n\t\t\tif (changed) notify(watchers)\n\t\t}\n\n\t// Own watcher: called when notified from sources (push)\n\tconst watcher = createWatcher(() => {\n\t\tdirty = true\n\t\tcontroller?.abort()\n\t\tif (watchers.size) notify(watchers)\n\t\telse watcher.cleanup()\n\t})\n\twatcher.unwatch(() => {\n\t\tcontroller?.abort()\n\t})\n\n\t// Called when requested by dependencies (pull)\n\tconst compute = () =>\n\t\tobserve(() => {\n\t\t\tif (computing) throw new CircularDependencyError('computed')\n\t\t\tchanged = false\n\t\t\tif (isAsyncFunction(callback)) {\n\t\t\t\t// Return current value until promise resolves\n\t\t\t\tif (controller) return value\n\t\t\t\tcontroller = new AbortController()\n\t\t\t\tcontroller.signal.addEventListener(\n\t\t\t\t\t'abort',\n\t\t\t\t\t() => {\n\t\t\t\t\t\tcomputing = false\n\t\t\t\t\t\tcontroller = undefined\n\t\t\t\t\t\tcompute() // Retry computation with updated state\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tonce: true,\n\t\t\t\t\t},\n\t\t\t\t)\n\t\t\t}\n\t\t\tlet result: T | Promise<T>\n\t\t\tcomputing = true\n\t\t\ttry {\n\t\t\t\tresult = controller\n\t\t\t\t\t? callback(value, controller.signal)\n\t\t\t\t\t: (callback as (oldValue: T) => T)(value)\n\t\t\t} catch (e) {\n\t\t\t\tif (isAbortError(e)) nil()\n\t\t\t\telse err(e)\n\t\t\t\tcomputing = false\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (result instanceof Promise) result.then(settle(ok), settle(err))\n\t\t\telse if (null == result || UNSET === result) nil()\n\t\t\telse ok(result)\n\t\t\tcomputing = false\n\t\t}, watcher)\n\n\tconst computed: Record<PropertyKey, unknown> = {}\n\tObject.defineProperties(computed, {\n\t\t[Symbol.toStringTag]: {\n\t\t\tvalue: TYPE_COMPUTED,\n\t\t},\n\t\tget: {\n\t\t\tvalue: (): T => {\n\t\t\t\tsubscribe(watchers)\n\t\t\t\tflush()\n\t\t\t\tif (dirty) compute()\n\t\t\t\tif (error) throw error\n\t\t\t\treturn value\n\t\t\t},\n\t\t},\n\t})\n\treturn computed as Computed<T>\n}\n\n/**\n * Check if a value is a computed signal\n *\n * @since 0.9.0\n * @param {unknown} value - Value to check\n * @returns {boolean} - true if value is a computed signal, false otherwise\n */\nconst isComputed = /*#__PURE__*/ <T extends {}>(\n\tvalue: unknown,\n): value is Computed<T> => isObjectOfType(value, TYPE_COMPUTED)\n\n/**\n * Check if the provided value is a callback that may be used as input for toSignal() to derive a computed state\n *\n * @since 0.12.0\n * @param {unknown} value - Value to check\n * @returns {boolean} - true if value is a callback or callbacks object, false otherwise\n */\nconst isComputedCallback = /*#__PURE__*/ <T extends {}>(\n\tvalue: unknown,\n): value is ComputedCallback<T> => isFunction(value) && value.length < 3\n\n/* === Exports === */\n\nexport {\n\tTYPE_COMPUTED,\n\tcreateComputed,\n\tisComputed,\n\tisComputedCallback,\n\ttype Computed,\n\ttype ComputedCallback,\n}\n",
    "import { CircularDependencyError, InvalidCallbackError } from './errors'\nimport { type Cleanup, createWatcher, observe } from './system'\nimport { isAbortError, isAsyncFunction, isFunction, valueString } from './util'\n\n/* === Types === */\n\n// biome-ignore lint/suspicious/noConfusingVoidType: optional Cleanup return type\ntype MaybeCleanup = Cleanup | undefined | void\n\ntype EffectCallback =\n\t| (() => MaybeCleanup)\n\t| ((abort: AbortSignal) => Promise<MaybeCleanup>)\n\n/* === Functions === */\n\n/**\n * Define what happens when a reactive state changes\n *\n * The callback can be synchronous or asynchronous. Async callbacks receive\n * an AbortSignal parameter, which is automatically aborted when the effect\n * re-runs or is cleaned up, preventing stale async operations.\n *\n * @since 0.1.0\n * @param {EffectCallback} callback - Synchronous or asynchronous effect callback\n * @returns {Cleanup} - Cleanup function for the effect\n */\nconst createEffect = (callback: EffectCallback): Cleanup => {\n\tif (!isFunction(callback) || callback.length > 1)\n\t\tthrow new InvalidCallbackError('effect', valueString(callback))\n\n\tconst isAsync = isAsyncFunction(callback)\n\tlet running = false\n\tlet controller: AbortController | undefined\n\n\tconst watcher = createWatcher(() =>\n\t\tobserve(() => {\n\t\t\tif (running) throw new CircularDependencyError('effect')\n\t\t\trunning = true\n\n\t\t\t// Abort any previous async operations\n\t\t\tcontroller?.abort()\n\t\t\tcontroller = undefined\n\n\t\t\tlet cleanup: MaybeCleanup | Promise<MaybeCleanup>\n\n\t\t\ttry {\n\t\t\t\tif (isAsync) {\n\t\t\t\t\t// Create AbortController for async callback\n\t\t\t\t\tcontroller = new AbortController()\n\t\t\t\t\tconst currentController = controller\n\t\t\t\t\tcallback(controller.signal)\n\t\t\t\t\t\t.then(cleanup => {\n\t\t\t\t\t\t\t// Only register cleanup if this is still the current controller\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tisFunction(cleanup) &&\n\t\t\t\t\t\t\t\tcontroller === currentController\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\twatcher.unwatch(cleanup)\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.catch(error => {\n\t\t\t\t\t\t\tif (!isAbortError(error))\n\t\t\t\t\t\t\t\tconsole.error('Async effect error:', error)\n\t\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\tcleanup = (callback as () => MaybeCleanup)()\n\t\t\t\t\tif (isFunction(cleanup)) watcher.unwatch(cleanup)\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tif (!isAbortError(error))\n\t\t\t\t\tconsole.error('Effect callback error:', error)\n\t\t\t}\n\n\t\t\trunning = false\n\t\t}, watcher),\n\t)\n\n\twatcher()\n\treturn () => {\n\t\tcontroller?.abort()\n\t\twatcher.cleanup()\n\t}\n}\n\n/* === Exports === */\n\nexport { type MaybeCleanup, type EffectCallback, createEffect }\n",
    "import { isEqual } from './diff'\nimport { InvalidCallbackError, NullishSignalValueError } from './errors'\nimport { notify, subscribe, type Watcher } from './system'\nimport { isFunction, isObjectOfType, UNSET, valueString } from './util'\n\n/* === Types === */\n\ntype State<T extends {}> = {\n\treadonly [Symbol.toStringTag]: 'State'\n\tget(): T\n\tset(newValue: T): void\n\tupdate(updater: (oldValue: T) => T): void\n}\n\n/* === Constants === */\n\nconst TYPE_STATE = 'State'\n\n/* === Functions === */\n\n/**\n * Create a new state signal\n *\n * @since 0.9.0\n * @param {T} initialValue - initial value of the state\n * @returns {State<T>} - new state signal\n */\nconst createState = /*#__PURE__*/ <T extends {}>(initialValue: T): State<T> => {\n\tif (initialValue == null) throw new NullishSignalValueError('state')\n\n\tconst watchers: Set<Watcher> = new Set()\n\tlet value: T = initialValue\n\n\tconst setValue = (newValue: T) => {\n\t\tif (newValue == null) throw new NullishSignalValueError('state')\n\t\tif (isEqual(value, newValue)) return\n\t\tvalue = newValue\n\t\tnotify(watchers)\n\n\t\t// Setting to UNSET clears the watchers so the signal can be garbage collected\n\t\tif (UNSET === value) watchers.clear()\n\t}\n\n\tconst state: Record<PropertyKey, unknown> = {}\n\tObject.defineProperties(state, {\n\t\t[Symbol.toStringTag]: {\n\t\t\tvalue: TYPE_STATE,\n\t\t},\n\t\tget: {\n\t\t\tvalue: () => {\n\t\t\t\tsubscribe(watchers)\n\t\t\t\treturn value\n\t\t\t},\n\t\t},\n\t\tset: {\n\t\t\tvalue: (newValue: T) => {\n\t\t\t\tsetValue(newValue)\n\t\t\t},\n\t\t},\n\t\tupdate: {\n\t\t\tvalue: (updater: (oldValue: T) => T) => {\n\t\t\t\tif (!isFunction(updater))\n\t\t\t\t\tthrow new InvalidCallbackError(\n\t\t\t\t\t\t'state update',\n\t\t\t\t\t\tvalueString(updater),\n\t\t\t\t\t)\n\t\t\t\tsetValue(updater(value))\n\t\t\t},\n\t\t},\n\t})\n\treturn state as State<T>\n}\n\n/**\n * Check if the provided value is a State instance\n *\n * @since 0.9.0\n * @param {unknown} value - value to check\n * @returns {boolean} - true if the value is a State instance, false otherwise\n */\nconst isState = /*#__PURE__*/ <T extends {}>(\n\tvalue: unknown,\n): value is State<T> => isObjectOfType(value, TYPE_STATE)\n\n/* === Exports === */\n\nexport { TYPE_STATE, isState, createState, type State }\n",
    "import { isComputed } from './computed'\nimport {\n\ttype ArrayToRecord,\n\tdiff,\n\ttype PartialRecord,\n\ttype UnknownArray,\n\ttype UnknownRecord,\n} from './diff'\nimport {\n\tInvalidSignalValueError,\n\tNullishSignalValueError,\n\tStoreKeyExistsError,\n\tStoreKeyRangeError,\n\tStoreKeyReadonlyError,\n} from './errors'\nimport { isMutableSignal, type Signal } from './signal'\nimport { createState, isState, type State } from './state'\nimport {\n\tbatch,\n\ttype Cleanup,\n\tcreateWatcher,\n\tnotify,\n\tobserve,\n\tsubscribe,\n\ttype Watcher,\n} from './system'\nimport {\n\tisFunction,\n\tisObjectOfType,\n\tisRecord,\n\tisSymbol,\n\trecordToArray,\n\tUNSET,\n\tvalueString,\n} from './util'\n\n/* === Types === */\n\ntype ArrayItem<T> = T extends readonly (infer U extends {})[] ? U : never\n\ntype StoreChanges<T> = {\n\tadd: PartialRecord<T>\n\tchange: PartialRecord<T>\n\tremove: PartialRecord<T>\n\tsort: string[]\n}\n\ntype StoreListeners<T> = {\n\t[K in keyof StoreChanges<T>]: Set<(change: StoreChanges<T>[K]) => void>\n}\n\ninterface BaseStore {\n\treadonly [Symbol.toStringTag]: 'Store'\n\treadonly length: number\n}\n\ntype RecordStore<T extends UnknownRecord> = BaseStore & {\n\t[K in keyof T]: T[K] extends readonly unknown[] | Record<string, unknown>\n\t\t? Store<T[K]>\n\t\t: State<T[K]>\n} & {\n\t[Symbol.iterator](): IterableIterator<\n\t\t[\n\t\t\tExtract<keyof T, string>,\n\t\t\tT[Extract<keyof T, string>] extends\n\t\t\t\t| readonly unknown[]\n\t\t\t\t| Record<string, unknown>\n\t\t\t\t? Store<T[Extract<keyof T, string>]>\n\t\t\t\t: State<T[Extract<keyof T, string>]>,\n\t\t]\n\t>\n\tadd<K extends Extract<keyof T, string>>(key: K, value: T[K]): void\n\tget(): T\n\tset(value: T): void\n\tupdate(fn: (value: T) => T): void\n\tsort<U = T[Extract<keyof T, string>]>(\n\t\tcompareFn?: (a: U, b: U) => number,\n\t): void\n\ton<K extends keyof StoreChanges<T>>(\n\t\ttype: K,\n\t\tlistener: (change: StoreChanges<T>[K]) => void,\n\t): Cleanup\n\tremove<K extends Extract<keyof T, string>>(key: K): void\n}\n\ntype ArrayStore<T extends UnknownArray> = BaseStore & {\n\t[Symbol.iterator](): IterableIterator<\n\t\tArrayItem<T> extends readonly unknown[] | Record<string, unknown>\n\t\t\t? Store<ArrayItem<T>>\n\t\t\t: State<ArrayItem<T>>\n\t>\n\treadonly [Symbol.isConcatSpreadable]: boolean\n\t[n: number]: ArrayItem<T> extends\n\t\t| readonly unknown[]\n\t\t| Record<string, unknown>\n\t\t? Store<ArrayItem<T>>\n\t\t: State<ArrayItem<T>>\n\tadd(value: ArrayItem<T>): void\n\tget(): T\n\tset(value: T): void\n\tupdate(fn: (value: T) => T): void\n\tsort<U = ArrayItem<T>>(compareFn?: (a: U, b: U) => number): void\n\ton<K extends keyof StoreChanges<T>>(\n\t\ttype: K,\n\t\tlistener: (change: StoreChanges<T>[K]) => void,\n\t): Cleanup\n\tremove(index: number): void\n}\n\ntype Store<T extends UnknownRecord | UnknownArray> = T extends UnknownRecord\n\t? RecordStore<T>\n\t: T extends UnknownArray\n\t\t? ArrayStore<T>\n\t\t: never\n\n/* === Constants === */\n\nconst TYPE_STORE = 'Store'\n\n/* === Functions === */\n\n/**\n * Create a new store with deeply nested reactive properties\n *\n * Supports both objects and arrays as initial values. Arrays are converted\n * to records internally for storage but maintain their array type through\n * the .get() method, which automatically converts objects with consecutive\n * numeric keys back to arrays.\n *\n * @since 0.15.0\n * @param {T} initialValue - initial object or array value of the store\n * @returns {Store<T>} - new store with reactive properties that preserves the original type T\n */\nconst createStore = <T extends UnknownRecord | UnknownArray>(\n\tinitialValue: T,\n): Store<T> => {\n\tif (initialValue == null) throw new NullishSignalValueError('store')\n\n\tconst watchers = new Set<Watcher>()\n\tconst listeners: StoreListeners<T> = {\n\t\tadd: new Set<(change: PartialRecord<T>) => void>(),\n\t\tchange: new Set<(change: PartialRecord<T>) => void>(),\n\t\tremove: new Set<(change: PartialRecord<T>) => void>(),\n\t\tsort: new Set<(change: string[]) => void>(),\n\t}\n\tconst signals = new Map<string, Signal<T[Extract<keyof T, string>] & {}>>()\n\tconst signalWatchers = new Map<string, Watcher>()\n\n\t// Determine if this is an array-like store at creation time\n\tconst isArrayLike = Array.isArray(initialValue)\n\n\t// Get current record\n\tconst current = () => {\n\t\tconst record: Record<string, unknown> = {}\n\t\tfor (const [key, signal] of signals) record[key] = signal.get()\n\t\treturn record\n\t}\n\n\t// Emit change notifications\n\tconst emit = <K extends keyof StoreChanges<T>>(\n\t\tkey: K,\n\t\tchanges: StoreChanges<T>[K],\n\t) => {\n\t\tObject.freeze(changes)\n\t\tfor (const listener of listeners[key]) listener(changes)\n\t}\n\n\t// Get sorted indexes\n\tconst getSortedIndexes = () =>\n\t\tArray.from(signals.keys())\n\t\t\t.map(k => Number(k))\n\t\t\t.filter(n => Number.isInteger(n))\n\t\t\t.sort((a, b) => a - b)\n\n\t// Validate input\n\tconst isValidValue = <T>(\n\t\tkey: string,\n\t\tvalue: T,\n\t): value is NonNullable<T> => {\n\t\tif (value == null)\n\t\t\tthrow new NullishSignalValueError(`store for key \"${key}\"`)\n\t\tif (value === UNSET) return true\n\t\tif (isSymbol(value) || isFunction(value) || isComputed(value))\n\t\t\tthrow new InvalidSignalValueError(\n\t\t\t\t`store for key \"${key}\"`,\n\t\t\t\tvalueString(value),\n\t\t\t)\n\t\treturn true\n\t}\n\n\t// Add nested signal and effect\n\tconst addProperty = (\n\t\tkey: string,\n\t\tvalue: ArrayItem<T> | T[keyof T],\n\t\tsingle = false,\n\t): boolean => {\n\t\tif (!isValidValue(key, value)) return false\n\t\tconst signal =\n\t\t\tisState(value) || isStore(value)\n\t\t\t\t? value\n\t\t\t\t: isRecord(value) || Array.isArray(value)\n\t\t\t\t\t? createStore(value)\n\t\t\t\t\t: createState(value)\n\t\t// @ts-expect-error non-matching signal types\n\t\tsignals.set(key, signal)\n\t\tconst watcher = createWatcher(() =>\n\t\t\tobserve(() => {\n\t\t\t\temit('change', { [key]: signal.get() } as PartialRecord<T>)\n\t\t\t}, watcher),\n\t\t)\n\t\twatcher()\n\t\tsignalWatchers.set(key, watcher)\n\n\t\tif (single) {\n\t\t\tnotify(watchers)\n\t\t\temit('add', { [key]: value } as PartialRecord<T>)\n\t\t}\n\t\treturn true\n\t}\n\n\t// Remove nested signal and effect\n\tconst removeProperty = (key: string, single = false) => {\n\t\tconst ok = signals.delete(key)\n\t\tif (ok) {\n\t\t\tconst watcher = signalWatchers.get(key)\n\t\t\tif (watcher) watcher.cleanup()\n\t\t\tsignalWatchers.delete(key)\n\t\t}\n\n\t\tif (single) {\n\t\t\tnotify(watchers)\n\t\t\temit('remove', { [key]: UNSET } as PartialRecord<T>)\n\t\t}\n\t\treturn ok\n\t}\n\n\t// Reconcile data and dispatch events\n\tconst reconcile = (\n\t\toldValue: T,\n\t\tnewValue: T,\n\t\tinitialRun?: boolean,\n\t): boolean => {\n\t\tconst changes = diff(\n\t\t\toldValue as T extends UnknownArray ? ArrayToRecord<T> : T,\n\t\t\tnewValue as T extends UnknownArray ? ArrayToRecord<T> : T,\n\t\t)\n\n\t\tbatch(() => {\n\t\t\t// Additions\n\t\t\tif (Object.keys(changes.add).length) {\n\t\t\t\tfor (const key in changes.add)\n\t\t\t\t\taddProperty(key, changes.add[key] ?? UNSET)\n\n\t\t\t\t// Queue initial additions event to allow listeners to be added first\n\t\t\t\tif (initialRun) {\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\temit('add', changes.add)\n\t\t\t\t\t}, 0)\n\t\t\t\t} else {\n\t\t\t\t\temit('add', changes.add)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Changes\n\t\t\tif (Object.keys(changes.change).length) {\n\t\t\t\tfor (const key in changes.change) {\n\t\t\t\t\tconst value = changes.change[key]\n\t\t\t\t\tif (!isValidValue(key, value)) continue\n\t\t\t\t\tconst signal = signals.get(key as Extract<keyof T, string>)\n\t\t\t\t\tif (isMutableSignal(signal)) signal.set(value)\n\t\t\t\t\telse\n\t\t\t\t\t\tthrow new StoreKeyReadonlyError(key, valueString(value))\n\t\t\t\t}\n\t\t\t\temit('change', changes.change)\n\t\t\t}\n\n\t\t\t// Removals\n\t\t\tif (Object.keys(changes.remove).length) {\n\t\t\t\tfor (const key in changes.remove) removeProperty(key)\n\t\t\t\temit('remove', changes.remove)\n\t\t\t}\n\t\t})\n\n\t\treturn changes.changed\n\t}\n\n\t// Initialize data\n\treconcile({} as T, initialValue, true)\n\n\t// Methods and Properties\n\tconst store: Record<PropertyKey, unknown> = {}\n\tObject.defineProperties(store, {\n\t\t[Symbol.toStringTag]: {\n\t\t\tvalue: TYPE_STORE,\n\t\t},\n\t\t[Symbol.isConcatSpreadable]: {\n\t\t\tvalue: isArrayLike,\n\t\t},\n\t\t[Symbol.iterator]: {\n\t\t\tvalue: isArrayLike\n\t\t\t\t? function* () {\n\t\t\t\t\t\tconst indexes = getSortedIndexes()\n\t\t\t\t\t\tfor (const index of indexes) {\n\t\t\t\t\t\t\tconst signal = signals.get(String(index))\n\t\t\t\t\t\t\tif (signal) yield signal\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t: function* () {\n\t\t\t\t\t\tfor (const [key, signal] of signals) yield [key, signal]\n\t\t\t\t\t},\n\t\t},\n\t\tadd: {\n\t\t\tvalue: isArrayLike\n\t\t\t\t? (v: ArrayItem<T>): void => {\n\t\t\t\t\t\taddProperty(String(signals.size), v, true)\n\t\t\t\t\t}\n\t\t\t\t: <K extends Extract<keyof T, string>>(k: K, v: T[K]): void => {\n\t\t\t\t\t\tif (!signals.has(k)) addProperty(k, v, true)\n\t\t\t\t\t\telse throw new StoreKeyExistsError(k, valueString(v))\n\t\t\t\t\t},\n\t\t},\n\t\tget: {\n\t\t\tvalue: (): T => {\n\t\t\t\tsubscribe(watchers)\n\t\t\t\treturn recordToArray(current()) as T\n\t\t\t},\n\t\t},\n\t\tremove: {\n\t\t\tvalue: isArrayLike\n\t\t\t\t? (index: number): void => {\n\t\t\t\t\t\tconst currentArray = recordToArray(current()) as T\n\t\t\t\t\t\tconst currentLength = signals.size\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t!Array.isArray(currentArray) ||\n\t\t\t\t\t\t\tindex <= -currentLength ||\n\t\t\t\t\t\t\tindex >= currentLength\n\t\t\t\t\t\t)\n\t\t\t\t\t\t\tthrow new StoreKeyRangeError(index)\n\t\t\t\t\t\tconst newArray = [...currentArray]\n\t\t\t\t\t\tnewArray.splice(index, 1)\n\n\t\t\t\t\t\tif (reconcile(currentArray, newArray as unknown as T))\n\t\t\t\t\t\t\tnotify(watchers)\n\t\t\t\t\t}\n\t\t\t\t: (k: string): void => {\n\t\t\t\t\t\tif (signals.has(k)) removeProperty(k, true)\n\t\t\t\t\t},\n\t\t},\n\t\tset: {\n\t\t\tvalue: (v: T): void => {\n\t\t\t\tif (reconcile(current() as T, v)) {\n\t\t\t\t\tnotify(watchers)\n\t\t\t\t\tif (UNSET === v) watchers.clear()\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\tupdate: {\n\t\t\tvalue: (fn: (v: T) => T): void => {\n\t\t\t\tconst oldValue = current()\n\t\t\t\tconst newValue = fn(recordToArray(oldValue) as T)\n\t\t\t\tif (reconcile(oldValue as T, newValue)) {\n\t\t\t\t\tnotify(watchers)\n\t\t\t\t\tif (UNSET === newValue) watchers.clear()\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\tsort: {\n\t\t\tvalue: (\n\t\t\t\tcompareFn?: <\n\t\t\t\t\tU = T extends UnknownArray\n\t\t\t\t\t\t? ArrayItem<T>\n\t\t\t\t\t\t: T[Extract<keyof T, string>],\n\t\t\t\t>(\n\t\t\t\t\ta: U,\n\t\t\t\t\tb: U,\n\t\t\t\t) => number,\n\t\t\t): void => {\n\t\t\t\t// Get all entries as [key, value] pairs\n\t\t\t\tconst entries = Array.from(signals.entries())\n\t\t\t\t\t.map(([key, signal]) => [key, signal.get()])\n\t\t\t\t\t.sort(\n\t\t\t\t\t\tcompareFn\n\t\t\t\t\t\t\t? (a, b) => compareFn(a[1], b[1])\n\t\t\t\t\t\t\t: (a, b) =>\n\t\t\t\t\t\t\t\t\tString(a[1]).localeCompare(String(b[1])),\n\t\t\t\t\t)\n\n\t\t\t\t// Create array of original keys in their new sorted order\n\t\t\t\tconst newOrder: string[] = entries.map(([key]) => String(key))\n\t\t\t\tconst newSignals = new Map<\n\t\t\t\t\tstring,\n\t\t\t\t\tSignal<T[Extract<keyof T, string>] & {}>\n\t\t\t\t>()\n\n\t\t\t\tentries.forEach(([key], newIndex) => {\n\t\t\t\t\tconst oldKey = String(key)\n\t\t\t\t\tconst newKey = isArrayLike ? String(newIndex) : String(key)\n\t\t\t\t\tconst signal = signals.get(oldKey)\n\t\t\t\t\tif (signal) newSignals.set(newKey, signal)\n\t\t\t\t})\n\n\t\t\t\t// Replace signals map\n\t\t\t\tsignals.clear()\n\t\t\t\tnewSignals.forEach((signal, key) => signals.set(key, signal))\n\t\t\t\tnotify(watchers)\n\t\t\t\temit('sort', newOrder)\n\t\t\t},\n\t\t},\n\t\ton: {\n\t\t\tvalue: <K extends keyof StoreChanges<T>>(\n\t\t\t\ttype: K,\n\t\t\t\tlistener: (change: StoreChanges<T>[K]) => void,\n\t\t\t): Cleanup => {\n\t\t\t\tlisteners[type].add(listener)\n\t\t\t\treturn () => listeners[type].delete(listener)\n\t\t\t},\n\t\t},\n\t\tlength: {\n\t\t\tget(): number {\n\t\t\t\tsubscribe(watchers)\n\t\t\t\treturn signals.size\n\t\t\t},\n\t\t},\n\t})\n\n\t// Return proxy directly with integrated signal methods\n\treturn new Proxy(store as Store<T>, {\n\t\tget(target, prop) {\n\t\t\tif (prop in target) return Reflect.get(target, prop)\n\t\t\tif (isSymbol(prop)) return undefined\n\t\t\treturn signals.get(prop)\n\t\t},\n\t\thas(target, prop) {\n\t\t\tif (prop in target) return true\n\t\t\treturn signals.has(String(prop))\n\t\t},\n\t\townKeys(target) {\n\t\t\tconst staticKeys = Reflect.ownKeys(target)\n\t\t\tconst signalKeys = isArrayLike\n\t\t\t\t? getSortedIndexes().map(key => String(key))\n\t\t\t\t: Array.from(signals.keys())\n\t\t\treturn [...new Set([...signalKeys, ...staticKeys])]\n\t\t},\n\t\tgetOwnPropertyDescriptor(target, prop) {\n\t\t\tif (prop in target)\n\t\t\t\treturn Reflect.getOwnPropertyDescriptor(target, prop)\n\n\t\t\tconst signal = signals.get(String(prop))\n\t\t\treturn signal\n\t\t\t\t? {\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\twritable: true,\n\t\t\t\t\t\tvalue: signal,\n\t\t\t\t\t}\n\t\t\t\t: undefined\n\t\t},\n\t})\n}\n\n/**\n * Check if the provided value is a Store instance\n *\n * @since 0.15.0\n * @param {unknown} value - value to check\n * @returns {boolean} - true if the value is a Store instance, false otherwise\n */\nconst isStore = <T extends UnknownRecord | UnknownArray>(\n\tvalue: unknown,\n): value is Store<T> => isObjectOfType(value, TYPE_STORE)\n\n/* === Exports === */\n\nexport { TYPE_STORE, isStore, createStore, type Store, type StoreChanges }\n",
    "import {\n\ttype Computed,\n\ttype ComputedCallback,\n\tcreateComputed,\n\tisComputed,\n\tisComputedCallback,\n} from './computed'\nimport { createState, isState, type State } from './state'\nimport { createStore, isStore, type Store } from './store'\nimport { isRecord } from './util'\n\n/* === Types === */\n\ntype Signal<T extends {}> = {\n\tget(): T\n}\n\ntype UnknownSignalRecord = Record<string, Signal<unknown & {}>>\n\ntype SignalValues<S extends UnknownSignalRecord> = {\n\t[K in keyof S]: S[K] extends Signal<infer T> ? T : never\n}\n\n/* === Functions === */\n\n/**\n * Check whether a value is a Signal\n *\n * @since 0.9.0\n * @param {unknown} value - value to check\n * @returns {boolean} - true if value is a Signal, false otherwise\n */\nconst isSignal = /*#__PURE__*/ <T extends {}>(\n\tvalue: unknown,\n): value is Signal<T> => isState(value) || isComputed(value) || isStore(value)\n\n/**\n * Check whether a value is a State or Store\n *\n * @since 0.15.2\n * @param {unknown} value - value to check\n * @returns {boolean} - true if value is a State or Store, false otherwise\n */\nconst isMutableSignal = /*#__PURE__*/ <T extends {}>(\n\tvalue: unknown,\n): value is State<T> | Store<T> => isState(value) || isStore(value)\n\n/**\n * Convert a value to a Signal if it's not already a Signal\n *\n * @since 0.9.6\n * @param {T} value - value to convert\n * @returns {Signal<T>} - Signal instance\n */\nfunction toSignal<T extends {}>(\n\tvalue: T,\n): T extends Store<infer U>\n\t? Store<U>\n\t: T extends State<infer U>\n\t\t? State<U>\n\t\t: T extends Computed<infer U>\n\t\t\t? Computed<U>\n\t\t\t: T extends Signal<infer U>\n\t\t\t\t? Signal<U>\n\t\t\t\t: T extends ReadonlyArray<infer U extends {}>\n\t\t\t\t\t? Store<U[]>\n\t\t\t\t\t: T extends Record<string, unknown & {}>\n\t\t\t\t\t\t? Store<{ [K in keyof T]: T[K] }>\n\t\t\t\t\t\t: T extends ComputedCallback<infer U extends {}>\n\t\t\t\t\t\t\t? Computed<U>\n\t\t\t\t\t\t\t: State<T>\nfunction toSignal<T extends {}>(value: T) {\n\tif (isSignal<T>(value)) return value\n\tif (isComputedCallback(value)) return createComputed(value)\n\tif (Array.isArray(value) || isRecord(value)) return createStore(value)\n\treturn createState(value)\n}\n\n/* === Exports === */\n\nexport {\n\ttype Signal,\n\ttype UnknownSignalRecord,\n\ttype SignalValues,\n\tisSignal,\n\tisMutableSignal,\n\ttoSignal,\n}\n",
    "import { isFunction, isString } from '@zeix/cause-effect'\n\n/* === Types === */\n\ntype LogLevel = 'debug' | 'info' | 'warn' | 'error'\n\n/* === Constants === */\n\nconst DEV_MODE = process.env.DEV_MODE\n\nconst LOG_DEBUG: LogLevel = 'debug'\nconst LOG_INFO: LogLevel = 'info'\nconst LOG_WARN: LogLevel = 'warn'\nconst LOG_ERROR: LogLevel = 'error'\n\n// Reserved words that should never be used as property names\n// These are fundamental JavaScript/Object properties that cause serious issues\nconst RESERVED_WORDS = new Set([\n\t'constructor',\n\t'prototype',\n\t// Expand this list based on user feedback for other reserved words like:\n\t// '__proto__', 'toString', 'valueOf', 'hasOwnProperty', etc.\n])\n\n// HTMLElement properties that commonly cause conflicts\n// These are properties that exist on HTMLElement and cause confusion when overridden\n// in our reactive components because we use the same name for both attributes and properties\nconst HTML_ELEMENT_PROPS = new Set([\n\t'id', // DOM selector conflicts\n\t'class', // CSS class management conflicts (note: property is 'className')\n\t'className', // CSS class management conflicts (note: HTML attribute is 'class')\n\t'title', // Conflicts with tooltip behavior\n\t'role', // ARIA/accessibility conflicts\n\t'style', // Conflicts with style object\n\t'dataset', // Conflicts with data-* attribute access\n\t'lang', // Language/i18n conflicts\n\t'dir', // Text direction conflicts\n\t'hidden', // Visibility control conflicts\n\t'children', // DOM manipulation conflicts\n\t'innerHTML', // DOM manipulation conflicts\n\t'outerHTML', // Full element HTML conflicts\n\t'textContent', // Text manipulation conflicts\n\t'innerText', // Text manipulation conflicts\n\t// TO EXPAND: Add properties based on user feedback and common mistakes\n\t// 'tabindex', 'tabIndex', 'slot', 'part', etc.\n])\n\n/* === Internal Functions === */\n\n/**\n * Return selector string for the id of the element\n *\n * @since 0.7.0\n * @param {string | undefined | null} id\n * @returns {string} - id string for the element with '#' prefix\n */\nconst idString = (id: string | undefined | null): string => (id ? `#${id}` : '')\n\n/**\n * Return a selector string for classes of the element\n *\n * @since 0.7.0\n * @param {DOMTokenList | undefined | null} classList - DOMTokenList to convert to a string\n * @returns {string} - class string for the DOMTokenList with '.' prefix if any\n */\nconst classString = (classList: DOMTokenList | undefined | null): string =>\n\tclassList?.length ? `.${Array.from(classList).join('.')}` : ''\n\n/* === Exported Functions === */\n\nconst hasMethod = /*#__PURE__*/ <T extends object, K extends PropertyKey, R>(\n\tobj: T,\n\tmethodName: K,\n): obj is T & Record<K, (...args: any[]) => R> =>\n\tisString(methodName) &&\n\tmethodName in obj &&\n\tisFunction<R>((obj as any)[methodName])\n\n/**\n * Check if a node is an Element\n *\n * @param {Node} node - node to check\n * @returns {boolean} - `true` if node is an element node, otherwise `false`\n */\nconst isElement = /*#__PURE__*/ (node: Node): node is Element =>\n\tnode.nodeType === Node.ELEMENT_NODE\n\n/**\n * Check whether an element is a custom element\n *\n * @param {E} element - Element to check\n * @returns {boolean} - True if the element is a custom element\n */\nconst isCustomElement = /*#__PURE__*/ <E extends Element>(\n\telement: E,\n): boolean => element.localName.includes('-')\n\n/**\n * Check whether a custom element is not yet defined\n *\n * @param {Element} element - Element to check\n * @returns {boolean} - True if the element is a custom element and not yet defined\n */\nconst isNotYetDefinedComponent = /*#__PURE__*/ (element: Element): boolean =>\n\tisCustomElement(element) && element.matches(':not(:defined)')\n\n/**\n * Return a string representation of the Element instance\n *\n * @since 0.7.0\n * @param {Element | undefined | null} el\n * @returns {string}\n */\nconst elementName = /*#__PURE__*/ (el: Element | undefined | null): string =>\n\tel\n\t\t? `<${el.localName}${idString(el.id)}${classString(el.classList)}>`\n\t\t: '<unknown>'\n\n/**\n * Return a detailed type of a JavaScript variable\n *\n * @since 0.11.0\n * @param {unknown} value\n * @returns {string}\n */\nconst typeString = /*#__PURE__*/ (value: unknown): string => {\n\tif (value === null) return 'null'\n\tif (typeof value !== 'object') return typeof value\n\tif (Array.isArray(value)) return 'Array'\n\n\t// Check for Symbol.toStringTag\n\tif (Symbol.toStringTag in Object(value)) {\n\t\treturn (value as any)[Symbol.toStringTag]\n\t}\n\n\t// For other objects, return the constructor name if available\n\treturn value.constructor?.name || 'Object'\n}\n\n/**\n * Log a message to the console with the specified level\n *\n * @since 0.7.0\n * @param {T} value - value to inspect\n * @param {string} msg - message to log\n * @param {LogLevel} level - log level\n * @returns {T} - value passed through\n */\nconst log = <T>(value: T, msg: string, level: LogLevel = LOG_DEBUG): T => {\n\tif (DEV_MODE || ([LOG_ERROR, LOG_WARN] as LogLevel[]).includes(level))\n\t\tconsole[level](msg, value)\n\treturn value\n}\n\n/**\n * Simple fail-fast validation that checks for specific problematic cases\n *\n * This validation prevents common mistakes where developers accidentally\n * use property names that conflict with native HTMLElement functionality.\n *\n * @param {string} prop - Property name to validate\n * @returns {string | null} - Error message or null if valid\n */\nconst validatePropertyName = (prop: string): string | null => {\n\tif (RESERVED_WORDS.has(prop))\n\t\treturn `Property name \"${prop}\" is a reserved word`\n\tif (HTML_ELEMENT_PROPS.has(prop))\n\t\treturn `Property name \"${prop}\" conflicts with inherited HTMLElement property`\n\treturn null\n}\n\nexport {\n\ttype LogLevel,\n\thasMethod,\n\tisElement,\n\tisCustomElement,\n\tisNotYetDefinedComponent,\n\tlog,\n\telementName,\n\ttypeString,\n\tvalidatePropertyName,\n\tDEV_MODE,\n\tLOG_DEBUG,\n\tLOG_INFO,\n\tLOG_WARN,\n\tLOG_ERROR,\n}\n",
    "import { valueString } from '@zeix/cause-effect'\nimport { elementName } from './util'\n\n/* === Error Classes === */\n\n/**\n * Error thrown when a circular dependency is detected in a selection signal\n *\n * @since 0.14.0\n */\nclass CircularMutationError extends Error {\n\t/**\n\t * @param {HTMLElement} host - Host component\n\t * @param {string} selector - Selector used to find the elements\n\t */\n\tconstructor(host: HTMLElement, selector: string) {\n\t\tsuper(\n\t\t\t`Circular dependency detected in selection signal for component ${elementName(host)} with selector \"${selector}\"`,\n\t\t)\n\t\tthis.name = 'CircularMutationError'\n\t}\n}\n\n/**\n * Error thrown when component name violates rules for custom element names\n *\n * @since 0.14.0\n */\nclass InvalidComponentNameError extends TypeError {\n\t/**\n\t * @param {string} component - Component name\n\t */\n\tconstructor(component: string) {\n\t\tsuper(\n\t\t\t`Invalid component name \"${component}\". Custom element names must contain a hyphen, start with a lowercase letter, and contain only lowercase letters, numbers, and hyphens.`,\n\t\t)\n\t\tthis.name = 'InvalidComponentNameError'\n\t}\n}\n\n/**\n * Error thrown when trying to assign a property name that conflicts with reserved words or inherited HTMLElement properties\n *\n * @since 0.14.0\n */\nclass InvalidPropertyNameError extends TypeError {\n\t/**\n\t * @param {string} component - Component name\n\t * @param {string} prop - Property name\n\t * @param {string} reason - Explanation why the property is invalid\n\t */\n\tconstructor(component: string, prop: string, reason: string) {\n\t\tsuper(\n\t\t\t`Invalid property name \"${prop}\" for component <${component}>. ${reason}`,\n\t\t)\n\t\tthis.name = 'InvalidPropertyNameError'\n\t}\n}\n\n/**\n * Error thrown when setup function does not return effects\n *\n * @since 0.14.0\n */\nclass InvalidEffectsError extends TypeError {\n\t/**\n\t * @param {HTMLElement} host - Host component\n\t * @param {Error} cause - Error that caused the invalid effects\n\t */\n\tconstructor(host: HTMLElement, cause?: Error) {\n\t\tsuper(\n\t\t\t`Invalid effects in component ${elementName(host)}. Effects must be a record of effects for UI elements or the component, or a Promise that resolves to effects.`,\n\t\t)\n\t\tthis.name = 'InvalidEffectsError'\n\t\tif (cause) this.cause = cause\n\t}\n}\n\n/**\n * Error thrown when a required desacendent element does not exist in a component's DOM subtree\n *\n * @since 0.14.0\n */\nclass MissingElementError extends Error {\n\t/**\n\t * @param {HTMLElement} host - Host component\n\t * @param {string} selector - Selector used to find the elements\n\t * @param {string} required - Explanation why the element is required\n\t */\n\tconstructor(host: HTMLElement, selector: string, required: string) {\n\t\tsuper(\n\t\t\t`Missing required element <${selector}> in component ${elementName(host)}. ${required}`,\n\t\t)\n\t\tthis.name = 'MissingElementError'\n\t}\n}\n\n/**\n * Error when a component's dependencies are not met within a specified timeout\n *\n * @since 0.14.0\n */\nclass DependencyTimeoutError extends Error {\n\t/**\n\t * @param {HTMLElement} host - Host component\n\t * @param {string[]} missing - List of missing dependencies\n\t */\n\tconstructor(host: HTMLElement, missing: string[]) {\n\t\tsuper(\n\t\t\t`Timeout waiting for: [${missing.join(', ')}] in component ${elementName(host)}.`,\n\t\t)\n\t\tthis.name = 'DependencyTimeoutError'\n\t}\n}\n\n/**\n * Error thrown when reactives passed to a component are invalid\n *\n * @since 0.15.0\n */\nclass InvalidReactivesError extends TypeError {\n\t/**\n\t * @param {HTMLElement} host - Host component\n\t * @param {HTMLElement} target - Target component\n\t * @param {unknown} reactives - Reactives passed to the component\n\t */\n\tconstructor(host: HTMLElement, target: HTMLElement, reactives: unknown) {\n\t\tsuper(\n\t\t\t`Expected reactives passed from ${elementName(host)} to ${elementName(target)} to be a record of signals, reactive property names or functions. Got ${valueString(reactives)}.`,\n\t\t)\n\t\tthis.name = 'InvalidReactivesError'\n\t}\n}\n\n/**\n * Error thrown when target element is not a custom element as expected\n *\n * @since 0.15.0\n */\nclass InvalidCustomElementError extends TypeError {\n\t/**\n\t * @param {HTMLElement} target - Target component\n\t * @param {string} where - Location where the error occurred\n\t */\n\tconstructor(target: HTMLElement, where: string) {\n\t\tsuper(`Target ${elementName(target)} is not a custom element in ${where}.`)\n\t\tthis.name = 'InvalidCustomElementError'\n\t}\n}\n\nexport {\n\tCircularMutationError,\n\tDependencyTimeoutError,\n\tInvalidComponentNameError,\n\tInvalidCustomElementError,\n\tInvalidPropertyNameError,\n\tInvalidEffectsError,\n\tInvalidReactivesError,\n\tMissingElementError,\n}\n",
    "import {\n\ttype Cleanup,\n\tisSymbol,\n\tnotify,\n\tsubscribe,\n\ttype Watcher,\n} from '@zeix/cause-effect'\nimport type { ElementFromSelector } from '../ui'\nimport { isElement } from '../util'\n\n/* === Types === */\n\ntype CollectionListener<E extends Element> = (changes: readonly E[]) => void\n\ntype Collection<E extends Element> = {\n\treadonly [Symbol.toStringTag]: 'Collection'\n\treadonly [Symbol.isConcatSpreadable]: true\n\t[Symbol.iterator](): IterableIterator<E>\n\t[n: number]: E\n\tget(): E[]\n\ton(type: 'add' | 'remove', listener: CollectionListener<E>): Cleanup\n\treadonly length: number\n}\n\n/* === Constants === */\n\nconst TYPE_COLLECTION = 'Collection'\n\n/* === Internal Functions === */\n\n/**\n * Extract attribute names from a CSS selector\n * Handles various attribute selector formats: .class, #id, [attr], [attr=value], [attr^=value], etc.\n *\n * @param {string} selector - CSS selector to parse\n * @returns {string[]} - Array of attribute names found in the selector\n */\nconst extractAttributes = (selector: string): string[] => {\n\tconst attributes = new Set<string>()\n\tif (selector.includes('.')) attributes.add('class')\n\tif (selector.includes('#')) attributes.add('id')\n\tif (selector.includes('[')) {\n\t\tconst parts = selector.split('[')\n\t\tfor (let i = 1; i < parts.length; i++) {\n\t\t\tconst part = parts[i]\n\t\t\tif (!part.includes(']')) continue\n\t\t\tconst attrName = part\n\t\t\t\t.split('=')[0]\n\t\t\t\t.trim()\n\t\t\t\t.replace(/[^a-zA-Z0-9_-]/g, '')\n\t\t\tif (attrName) attributes.add(attrName)\n\t\t}\n\t}\n\treturn [...attributes]\n}\n\n/* === Exported Functions === */\n\n/**\n * Create a collection of elements from a parent node and a CSS selector.\n *\n * @since 0.15.0\n * @param parent - The parent node to search within\n * @param selector - The CSS selector to match elements\n * @returns A collection signal of elements\n */\nfunction createCollection<S extends string>(\n\tparent: ParentNode,\n\tselector: S,\n): Collection<ElementFromSelector<S>>\nfunction createCollection<E extends Element>(\n\tparent: ParentNode,\n\tselector: string,\n): Collection<E>\nfunction createCollection<S extends string>(\n\tparent: ParentNode,\n\tselector: S,\n): Collection<ElementFromSelector<S>> {\n\tconst watchers: Set<Watcher> = new Set()\n\tconst listeners = {\n\t\tadd: new Set<CollectionListener<ElementFromSelector<S>>>(),\n\t\tremove: new Set<CollectionListener<ElementFromSelector<S>>>(),\n\t}\n\tlet elements: ElementFromSelector<S>[] = []\n\tlet observer: MutationObserver | undefined\n\n\tconst findMatches = (nodes: NodeList) => {\n\t\tconst elements = Array.from(nodes).filter(isElement)\n\t\tconst found: ElementFromSelector<S>[] = []\n\t\tfor (const element of elements) {\n\t\t\tif (element.matches(selector))\n\t\t\t\tfound.push(element as ElementFromSelector<S>)\n\t\t\tfound.push(\n\t\t\t\t...Array.from(\n\t\t\t\t\telement.querySelectorAll<ElementFromSelector<S>>(selector),\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\t\treturn found\n\t}\n\n\tconst notifyListeners = (\n\t\tlisteners: Set<CollectionListener<ElementFromSelector<S>>>,\n\t\telements: ElementFromSelector<S>[],\n\t) => {\n\t\tObject.freeze(elements)\n\t\tfor (const listener of listeners) listener(elements)\n\t}\n\n\tconst observe = () => {\n\t\telements = Array.from(\n\t\t\tparent.querySelectorAll<ElementFromSelector<S>>(selector),\n\t\t)\n\n\t\tobserver = new MutationObserver(mutations => {\n\t\t\tconst added: ElementFromSelector<S>[] = []\n\t\t\tconst removed: ElementFromSelector<S>[] = []\n\n\t\t\tfor (const mutation of mutations) {\n\t\t\t\tif (mutation.type === 'childList') {\n\t\t\t\t\tif (mutation.addedNodes.length)\n\t\t\t\t\t\tadded.push(...findMatches(mutation.addedNodes))\n\t\t\t\t\tif (mutation.removedNodes.length)\n\t\t\t\t\t\tremoved.push(...findMatches(mutation.removedNodes))\n\t\t\t\t} else if (mutation.type === 'attributes') {\n\t\t\t\t\tconst target = mutation.target as ElementFromSelector<S>\n\t\t\t\t\tif (isElement(target)) {\n\t\t\t\t\t\tconst wasMatching = elements.includes(target)\n\t\t\t\t\t\tconst isMatching = target.matches(selector)\n\t\t\t\t\t\tif (wasMatching && !isMatching) removed.push(target)\n\t\t\t\t\t\telse if (!wasMatching && isMatching) added.push(target)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (added.length || removed.length) {\n\t\t\t\telements = Array.from(\n\t\t\t\t\tparent.querySelectorAll<ElementFromSelector<S>>(selector),\n\t\t\t\t)\n\t\t\t\tnotify(watchers)\n\t\t\t}\n\t\t\tif (added.length) notifyListeners(listeners.add, added)\n\t\t\tif (removed.length) notifyListeners(listeners.remove, removed)\n\t\t})\n\t\tconst observerConfig: MutationObserverInit = {\n\t\t\tchildList: true,\n\t\t\tsubtree: true,\n\t\t}\n\t\tconst observedAttributes = extractAttributes(selector)\n\t\tif (observedAttributes.length) {\n\t\t\tobserverConfig.attributes = true\n\t\t\tobserverConfig.attributeFilter = observedAttributes\n\t\t}\n\t\tobserver.observe(parent, observerConfig)\n\t}\n\n\tconst collection = {} as Collection<ElementFromSelector<S>>\n\tObject.defineProperties(collection, {\n\t\t[Symbol.toStringTag]: {\n\t\t\tvalue: TYPE_COLLECTION,\n\t\t},\n\t\t[Symbol.isConcatSpreadable]: {\n\t\t\tvalue: true,\n\t\t},\n\t\t[Symbol.iterator]: {\n\t\t\tvalue: function* () {\n\t\t\t\tfor (const element of elements) yield element\n\t\t\t},\n\t\t},\n\t\tget: {\n\t\t\tvalue: () => {\n\t\t\t\tsubscribe(watchers)\n\t\t\t\tif (!observer) observe()\n\t\t\t\treturn elements\n\t\t\t},\n\t\t},\n\t\ton: {\n\t\t\tvalue: (\n\t\t\t\ttype: 'add' | 'remove',\n\t\t\t\tlistener: CollectionListener<ElementFromSelector<S>>,\n\t\t\t) => {\n\t\t\t\tconst listenerSet = listeners[type]\n\t\t\t\tif (!listenerSet)\n\t\t\t\t\tthrow new TypeError(`Invalid change notification type: ${type}`)\n\t\t\t\tlistenerSet.add(listener)\n\t\t\t\tif (!observer) observe()\n\t\t\t\treturn () => listenerSet.delete(listener)\n\t\t\t},\n\t\t},\n\t\tlength: {\n\t\t\tget: () => {\n\t\t\t\tsubscribe(watchers)\n\t\t\t\tif (!observer) observe()\n\t\t\t\treturn elements.length\n\t\t\t},\n\t\t},\n\t})\n\n\treturn new Proxy(collection, {\n\t\tget(target, prop) {\n\t\t\tif (prop in target) return Reflect.get(target, prop)\n\t\t\tif (isSymbol(prop)) return undefined\n\n\t\t\tconst index = Number(prop)\n\t\t\tif (Number.isInteger(index)) return elements[index]\n\n\t\t\treturn undefined\n\t\t},\n\t\thas(target, prop) {\n\t\t\tif (prop in target) return true\n\t\t\tif (Number.isInteger(Number(prop))) return !!elements[Number(prop)]\n\t\t\treturn false\n\t\t},\n\t\townKeys(target) {\n\t\t\tconst staticKeys = Reflect.ownKeys(target)\n\t\t\tconst indexes = Object.keys(elements).map(key => String(key))\n\t\t\treturn [...new Set([...indexes, ...staticKeys])]\n\t\t},\n\t\tgetOwnPropertyDescriptor(target, prop) {\n\t\t\tif (prop in target) return Reflect.getOwnPropertyDescriptor(target, prop)\n\n\t\t\tconst element = elements[Number(prop)]\n\t\t\treturn element\n\t\t\t\t? {\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\twritable: true,\n\t\t\t\t\t\tvalue: element,\n\t\t\t\t\t}\n\t\t\t\t: undefined\n\t\t},\n\t})\n}\n\n/**\n * Check if a value is a collection signal\n *\n * @since 0.15.0\n * @param {unknown} value - Value to check\n * @returns {boolean} - True if value is a collection signal, false otherwise\n */\nconst isCollection = <E extends Element = Element>(\n\tvalue: unknown,\n): value is Collection<E> =>\n\tObject.prototype.toString.call(value) === `[object Collection]`\n\nexport {\n\ttype Collection,\n\ttype CollectionListener,\n\tTYPE_COLLECTION,\n\tcreateCollection,\n\tisCollection,\n}\n",
    "import {\n\ttype Cleanup,\n\tcreateEffect,\n\tisFunction,\n\tisRecord,\n\tisSignal,\n\tisString,\n\ttype MaybeCleanup,\n\ttype Signal,\n\ttoError,\n\tUNSET,\n\tvalueString,\n} from '@zeix/cause-effect'\nimport type { Component, ComponentProps } from './component'\nimport { InvalidEffectsError } from './errors'\nimport { type Collection, isCollection } from './signals/collection'\nimport type { ElementFromKey, UI } from './ui'\nimport { DEV_MODE, elementName, LOG_ERROR, log } from './util'\n\n/* === Types === */\n\ntype Effect<P extends ComponentProps, E extends Element> = (\n\thost: Component<P>,\n\ttarget: E,\n) => MaybeCleanup\n\ntype ElementEffects<P extends ComponentProps, E extends Element> =\n\t| Effect<P, E>\n\t| Effect<P, E>[]\n\ntype Effects<\n\tP extends ComponentProps,\n\tU extends UI & { host: Component<P> },\n> = {\n\t[K in keyof U]?: ElementEffects<P, ElementFromKey<U, K>>\n}\n\ntype Reactive<T, P extends ComponentProps, E extends Element> =\n\t| keyof P\n\t| Signal<T & {}>\n\t| ((target: E) => T | null | undefined)\n\ntype UpdateOperation = 'a' | 'c' | 'd' | 'h' | 'm' | 'p' | 's' | 't'\n\ntype ElementUpdater<E extends Element, T> = {\n\top: UpdateOperation\n\tname?: string\n\tread: (element: E) => T | null\n\tupdate: (element: E, value: T) => void\n\tdelete?: (element: E) => void\n\tresolve?: (element: E) => void\n\treject?: (error: unknown) => void\n}\n\n/* type ElementInserter<E extends Element> = {\n\tposition?: InsertPosition\n\tcreate: (parent: E) => Element | null\n\tresolve?: (parent: E) => void\n\treject?: (error: unknown) => void\n} */\n\n/* === Constants === */\n\n// Special value explicitly marked as any so it can be used as signal value of any type\nconst RESET: any = Symbol('RESET')\n\n/* === Internal Functions === */\n\nconst getUpdateDescription = (\n\top: UpdateOperation,\n\tname: string = '',\n): string => {\n\tconst ops: Record<UpdateOperation, string> = {\n\t\ta: 'attribute ',\n\t\tc: 'class ',\n\t\td: 'dataset ',\n\t\th: 'inner HTML',\n\t\tm: 'method call ',\n\t\tp: 'property ',\n\t\ts: 'style property ',\n\t\tt: 'text content',\n\t}\n\treturn ops[op] + name\n}\n\n/* === Exported Functions === */\n\n/**\n * Run element effects\n *\n * @since 0.15.0\n * @param {U} host - Host component\n * @param {E} target - Target element\n * @param {ElementEffects<P, E>} effects - Effect functions to run\n * @returns {MaybeCleanup} - Cleanup function that runs collected cleanup functions\n * @throws {InvalidEffectsError} - If the effects are invalid\n */\nconst runElementEffects = <P extends ComponentProps, E extends Element>(\n\thost: Component<P>,\n\ttarget: E,\n\teffects: ElementEffects<P, E>,\n): MaybeCleanup => {\n\tconst cleanups: Cleanup[] = []\n\n\tconst run = (fn: Effect<P, E>) => {\n\t\tconst cleanup = fn(host, target)\n\t\tif (cleanup) cleanups.push(cleanup)\n\t}\n\n\tif (Array.isArray(effects)) for (const fn of effects) run(fn)\n\telse run(effects)\n\n\treturn () => {\n\t\tcleanups.forEach(cleanup => cleanup())\n\t\tcleanups.length = 0\n\t}\n}\n\n/**\n * Run collection effects\n *\n * @since 0.15.0\n * @param {Component<P>} host - Host component\n * @param {Collection<E>} collection - Collection of elements\n * @param {ElementEffects<P, E>} effects - Element effects\n * @returns {Cleanup} - Cleanup function that runs collected cleanup functions\n * @throws {InvalidEffectsError} - If the effects are invalid\n */\nconst runCollectionEffects = <P extends ComponentProps, E extends Element>(\n\thost: Component<P>,\n\tcollection: Collection<E>,\n\teffects: ElementEffects<P, E>,\n): Cleanup => {\n\tconst cleanups: Map<E, Cleanup> = new Map()\n\n\tconst attach = (targets: readonly E[]) => {\n\t\tfor (const target of targets) {\n\t\t\tconst cleanup = runElementEffects(host, target, effects)\n\t\t\tif (cleanup) cleanups.set(target, cleanup)\n\t\t}\n\t}\n\tconst detach = (targets: readonly E[]) => {\n\t\tfor (const target of targets) {\n\t\t\tcleanups.get(target)?.()\n\t\t\tcleanups.delete(target)\n\t\t}\n\t}\n\n\tcollection.on('add', attach)\n\tcollection.on('remove', detach)\n\tattach(collection.get())\n\treturn () => {\n\t\tfor (const cleanup of cleanups.values()) cleanup()\n\t\tcleanups.clear()\n\t}\n}\n\n/**\n * Run component effects\n *\n * @since 0.15.0\n * @param {ComponentUI<P, U>} ui - Component UI\n * @param {Effects<P, U>} effects - Effect functions to run\n * @returns {Cleanup} - Cleanup function that runs collected cleanup functions\n * @throws {InvalidEffectsError} - If the effects are invalid\n */\nconst runEffects = <\n\tP extends ComponentProps,\n\tU extends UI & { host: Component<P> },\n>(\n\tui: U,\n\teffects: Effects<P, U>,\n): Cleanup => {\n\tif (!isRecord(effects)) throw new InvalidEffectsError(ui.host)\n\n\tconst cleanups: Cleanup[] = []\n\tconst keys = Object.keys(effects)\n\tfor (const key of keys) {\n\t\tconst k = key as keyof U\n\t\tif (!effects[k]) continue\n\n\t\tconst elementEffects = Array.isArray(effects[k]) ? effects[k] : [effects[k]]\n\t\tif (isCollection<ElementFromKey<U, typeof k>>(ui[k])) {\n\t\t\tcleanups.push(runCollectionEffects(ui.host, ui[k], elementEffects))\n\t\t} else if (ui[k]) {\n\t\t\tconst cleanup = runElementEffects(\n\t\t\t\tui.host,\n\t\t\t\tui[k] as ElementFromKey<U, typeof k>,\n\t\t\t\telementEffects,\n\t\t\t)\n\t\t\tif (cleanup) cleanups.push(cleanup)\n\t\t}\n\t}\n\treturn () => {\n\t\tfor (const cleanup of cleanups) cleanup()\n\t\tcleanups.length = 0\n\t}\n}\n\n/**\n * Resolve reactive property name, reader function or signal\n *\n * @param {Reactive<T, P, E>} reactive - Reactive property name, reader function or signal\n * @param {Component<P, U>} host - Component host element\n * @param {E} target - Element to resolve reactive value for\n * @param {string} [context] - Context for error logging\n * @returns {T} - Resolved reactive value\n */\nconst resolveReactive = <\n\tT extends {},\n\tP extends ComponentProps,\n\tE extends Element,\n>(\n\treactive: Reactive<T, P, E>,\n\thost: Component<P>,\n\ttarget: E,\n\tcontext?: string,\n): T => {\n\ttry {\n\t\treturn isString(reactive)\n\t\t\t? (host[reactive] as unknown as T)\n\t\t\t: isSignal(reactive)\n\t\t\t\t? reactive.get()\n\t\t\t\t: isFunction(reactive)\n\t\t\t\t\t? (reactive(target) as unknown as T)\n\t\t\t\t\t: RESET\n\t} catch (error) {\n\t\tif (context) {\n\t\t\tlog(\n\t\t\t\terror,\n\t\t\t\t`Failed to resolve value of ${valueString(reactive)}${\n\t\t\t\t\tcontext ? ` for ${context}` : ''\n\t\t\t\t} in ${elementName(target)}${\n\t\t\t\t\t(host as unknown as E) !== target ? ` in ${elementName(host)}` : ''\n\t\t\t\t}`,\n\t\t\t\tLOG_ERROR,\n\t\t\t)\n\t\t}\n\t\treturn RESET\n\t}\n}\n\n/**\n * Core effect function for updating element properties based on reactive values.\n * This function handles the lifecycle of reading, updating, and deleting element properties\n * while providing proper error handling and debugging support.\n *\n * @since 0.9.0\n * @param {Reactive<T, P, E>} reactive - The reactive value that drives the element updates\n * @param {ElementUpdater<E, T>} updater - Configuration object defining how to read, update, and delete the element property\n * @returns {Effect<P, E>} Effect function that manages the element property updates\n */\nconst updateElement =\n\t<T extends {}, P extends ComponentProps, E extends Element>(\n\t\treactive: Reactive<T, P, E>,\n\t\tupdater: ElementUpdater<E, T>,\n\t): Effect<P, E> =>\n\t(host, target): Cleanup => {\n\t\tconst { op, name = '', read, update } = updater\n\t\tconst operationDesc = getUpdateDescription(op, name)\n\n\t\tconst ok = (verb: string) => () => {\n\t\t\tif (DEV_MODE && host.debug) {\n\t\t\t\tlog(\n\t\t\t\t\ttarget,\n\t\t\t\t\t`${verb} ${operationDesc} of ${elementName(target)} in ${elementName(host)}`,\n\t\t\t\t)\n\t\t\t}\n\t\t\tupdater.resolve?.(target)\n\t\t}\n\n\t\tconst err = (verb: string) => (error: unknown) => {\n\t\t\tlog(\n\t\t\t\terror,\n\t\t\t\t`Failed to ${verb} ${operationDesc} of ${elementName(target)} in ${elementName(host)}`,\n\t\t\t\tLOG_ERROR,\n\t\t\t)\n\t\t\tupdater.reject?.(error)\n\t\t}\n\n\t\tconst fallback = read(target)\n\n\t\treturn createEffect(() => {\n\t\t\tconst value = resolveReactive(reactive, host, target, operationDesc)\n\t\t\tconst resolvedValue =\n\t\t\t\tvalue === RESET\n\t\t\t\t\t? fallback\n\t\t\t\t\t: value === UNSET\n\t\t\t\t\t\t? updater.delete\n\t\t\t\t\t\t\t? null\n\t\t\t\t\t\t\t: fallback\n\t\t\t\t\t\t: value\n\n\t\t\tif (updater.delete && resolvedValue === null) {\n\t\t\t\ttry {\n\t\t\t\t\tupdater.delete!(target)\n\t\t\t\t\tok('delete')()\n\t\t\t\t} catch (error) {\n\t\t\t\t\terr('delete')(error)\n\t\t\t\t}\n\t\t\t} else if (resolvedValue != null) {\n\t\t\t\tconst current = read(target)\n\t\t\t\tif (Object.is(resolvedValue, current)) return\n\t\t\t\ttry {\n\t\t\t\t\tupdate(target, resolvedValue)\n\t\t\t\t\tok('update')()\n\t\t\t\t} catch (error) {\n\t\t\t\t\terr('update')(error)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n/**\n * Effect for dynamically inserting or removing elements based on a reactive numeric value.\n * Positive values insert elements, negative values remove them.\n *\n * @since 0.12.1\n * @param {Reactive<number, P, E>} reactive - Reactive value determining number of elements to insert (positive) or remove (negative)\n * @param {ElementInserter<E>} inserter - Configuration object defining how to create and position elements\n * @returns {Effect<P, E>} Effect function that manages element insertion and removal\n * /\nconst insertOrRemoveElement =\n\t<P extends ComponentProps, E extends Element = HTMLElement>(\n\t\treactive: Reactive<number, P, E>,\n\t\tinserter?: ElementInserter<E>,\n\t): Effect<P, E> =>\n\t(host, target) => {\n\t\tconst ok = (verb: string) => () => {\n\t\t\tif (DEV_MODE && host.debug) {\n\t\t\t\tlog(\n\t\t\t\t\ttarget,\n\t\t\t\t\t`${verb} element in ${elementName(target)} in ${elementName(host)}`,\n\t\t\t\t)\n\t\t\t}\n\t\t\tif (isFunction(inserter?.resolve)) {\n\t\t\t\tinserter.resolve(target)\n\t\t\t} else {\n\t\t\t\tconst signal = isSignal<number>(reactive) ? reactive : undefined\n\t\t\t\tif (isState(signal)) signal.set(0)\n\t\t\t}\n\t\t}\n\n\t\tconst err = (verb: string) => (error: unknown) => {\n\t\t\tlog(\n\t\t\t\terror,\n\t\t\t\t`Failed to ${verb} element in ${elementName(target)} in ${elementName(host)}`,\n\t\t\t\tLOG_ERROR,\n\t\t\t)\n\t\t\tinserter?.reject?.(error)\n\t\t}\n\n\t\treturn createEffect(() => {\n\t\t\tconst diff = resolveReactive(\n\t\t\t\treactive,\n\t\t\t\thost,\n\t\t\t\ttarget,\n\t\t\t\t'insertion or deletion',\n\t\t\t)\n\t\t\tconst resolvedDiff = diff === RESET ? 0 : diff\n\n\t\t\tif (resolvedDiff > 0) {\n\t\t\t\t// Positive diff => insert element\n\t\t\t\tif (!inserter) throw new TypeError(`No inserter provided`)\n\t\t\t\ttry {\n\t\t\t\t\tfor (let i = 0; i < resolvedDiff; i++) {\n\t\t\t\t\t\tconst element = inserter.create(target)\n\t\t\t\t\t\tif (!element) continue\n\t\t\t\t\t\ttarget.insertAdjacentElement(\n\t\t\t\t\t\t\tinserter.position ?? 'beforeend',\n\t\t\t\t\t\t\telement,\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\tok('insert')()\n\t\t\t\t} catch (error) {\n\t\t\t\t\terr('insert')(error)\n\t\t\t\t}\n\t\t\t} else if (resolvedDiff < 0) {\n\t\t\t\ttry {\n\t\t\t\t\tif (\n\t\t\t\t\t\tinserter &&\n\t\t\t\t\t\t(inserter.position === 'afterbegin' ||\n\t\t\t\t\t\t\tinserter.position === 'beforeend')\n\t\t\t\t\t) {\n\t\t\t\t\t\tfor (let i = 0; i > resolvedDiff; i--) {\n\t\t\t\t\t\t\tif (inserter.position === 'afterbegin')\n\t\t\t\t\t\t\t\ttarget.firstElementChild?.remove()\n\t\t\t\t\t\t\telse target.lastElementChild?.remove()\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget.remove()\n\t\t\t\t\t}\n\t\t\t\t\tok('remove')()\n\t\t\t\t} catch (error) {\n\t\t\t\t\terr('remove')(error)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\t} */\n\nexport {\n\ttype Effect,\n\ttype Effects,\n\ttype ElementEffects,\n\ttype ElementUpdater,\n\ttype Reactive,\n\trunEffects,\n\trunElementEffects,\n\tresolveReactive,\n\tupdateElement,\n\tRESET,\n}\n",
    "import { isFunction, isString } from '@zeix/cause-effect'\nimport type { UI } from './ui'\n\n/* === Types === */\n\ntype Parser<T extends {}, U extends UI> = (\n\tui: U,\n\tvalue: string | null | undefined,\n\told?: string | null,\n) => T\n\ntype LooseReader<T extends {}, U extends UI> = (\n\tui: U,\n) => T | string | null | undefined\ntype Reader<T extends {}, U extends UI> = (ui: U) => T\n\ntype Fallback<T extends {}, U extends UI> = T | Reader<T, U>\n\ntype ParserOrFallback<T extends {}, U extends UI> =\n\t| Parser<T, U>\n\t| Fallback<T, U>\n\n/* === Exported Functions === */\n\n/**\n * Check if a value is a parser\n *\n * @since 0.14.0\n * @param {unknown} value - Value to check if it is a parser\n * @returns {boolean} True if the value is a parser, false otherwise\n */\nconst isParser = <T extends {}, U extends UI>(\n\tvalue: unknown,\n): value is Parser<T, U> => isFunction<T>(value) && value.length >= 2\n\n/**\n * Check if a value is a reader\n *\n * @since 0.15.0\n * @param {unknown} value - Value to check if it is a reader\n * @returns {boolean} True if the value is a reader, false otherwise\n */\nconst isReader = <T extends {}, U extends UI>(\n\tvalue: unknown,\n): value is Reader<T, U> => isFunction<T>(value)\n\n/**\n * Get a fallback value for an element\n *\n * @since 0.14.0\n * @param {U} ui - Component UI\n * @param {ParserOrFallback<T, U>} fallback - Fallback value or parser function\n * @returns {T} Fallback value or parsed value\n */\nconst getFallback = <T extends {}, U extends UI>(\n\tui: U,\n\tfallback: ParserOrFallback<T, U>,\n): T => (isReader<T, U>(fallback) ? fallback(ui) : (fallback as T))\n\n/**\n * Read a value from a UI element\n *\n * @since 0.15.0\n * @param {LooseReader<T, U>} reader - Reader function returning T | string | null | undefined\n * @param {ParserOrFallback<T, U>} fallback - Fallback value or parser function\n * @returns {Reader<T, U>} Parsed value or fallback value\n */\nconst read =\n\t<T extends {}, U extends UI>(\n\t\treader: LooseReader<T, U>,\n\t\tfallback: ParserOrFallback<T, U>,\n\t): Reader<T, U> =>\n\t(ui: U): T => {\n\t\tconst value = reader(ui)\n\t\treturn isString(value) && isParser<T, U>(fallback)\n\t\t\t? fallback(ui, value)\n\t\t\t: ((value as T) ?? getFallback(ui, fallback))\n\t}\n\nexport {\n\ttype Parser,\n\ttype LooseReader,\n\ttype Reader,\n\ttype Fallback,\n\ttype ParserOrFallback,\n\tisParser,\n\tisReader,\n\tgetFallback,\n\tread,\n}\n",
    "import { DependencyTimeoutError, MissingElementError } from './errors'\nimport { type Collection, createCollection } from './signals/collection'\nimport { isNotYetDefinedComponent } from './util'\n\n/* === Types === */\n\n// Split a comma-separated selector into individual selectors\ntype SplitByComma<S extends string> = S extends `${infer First},${infer Rest}`\n\t? [TrimWhitespace<First>, ...SplitByComma<Rest>]\n\t: [TrimWhitespace<S>]\n\n// Trim leading/trailing whitespace from a string\ntype TrimWhitespace<S extends string> = S extends ` ${infer Rest}`\n\t? TrimWhitespace<Rest>\n\t: S extends `${infer Rest} `\n\t\t? TrimWhitespace<Rest>\n\t\t: S\n\n// Extract the rightmost selector part from combinator selectors (space, >, +, ~)\ntype ExtractRightmostSelector<S extends string> =\n\tS extends `${string} ${infer Rest}`\n\t\t? ExtractRightmostSelector<Rest>\n\t\t: S extends `${string}>${infer Rest}`\n\t\t\t? ExtractRightmostSelector<Rest>\n\t\t\t: S extends `${string}+${infer Rest}`\n\t\t\t\t? ExtractRightmostSelector<Rest>\n\t\t\t\t: S extends `${string}~${infer Rest}`\n\t\t\t\t\t? ExtractRightmostSelector<Rest>\n\t\t\t\t\t: S\n\n// Extract tag name from a simple selector (without combinators)\ntype ExtractTagFromSimpleSelector<S extends string> =\n\tS extends `${infer T}.${string}`\n\t\t? T\n\t\t: S extends `${infer T}#${string}`\n\t\t\t? T\n\t\t\t: S extends `${infer T}:${string}`\n\t\t\t\t? T\n\t\t\t\t: S extends `${infer T}[${string}`\n\t\t\t\t\t? T\n\t\t\t\t\t: S\n\n// Main extraction logic for a single selector\ntype ExtractTag<S extends string> = ExtractTagFromSimpleSelector<\n\tExtractRightmostSelector<S>\n>\n\n// Normalize to lowercase and ensure it's a known HTML tag\ntype KnownTag<S extends string> =\n\tLowercase<ExtractTag<S>> extends\n\t\t| keyof HTMLElementTagNameMap\n\t\t| keyof SVGElementTagNameMap\n\t\t| keyof MathMLElementTagNameMap\n\t\t? Lowercase<ExtractTag<S>>\n\t\t: never\n\n// Get element type from a single selector\ntype ElementFromSingleSelector<S extends string> =\n\tKnownTag<S> extends never\n\t\t? HTMLElement\n\t\t: KnownTag<S> extends keyof HTMLElementTagNameMap\n\t\t\t? HTMLElementTagNameMap[KnownTag<S>]\n\t\t\t: KnownTag<S> extends keyof SVGElementTagNameMap\n\t\t\t\t? SVGElementTagNameMap[KnownTag<S>]\n\t\t\t\t: KnownTag<S> extends keyof MathMLElementTagNameMap\n\t\t\t\t\t? MathMLElementTagNameMap[KnownTag<S>]\n\t\t\t\t\t: HTMLElement\n\n// Map a tuple of selectors to a union of their element types\ntype ElementsFromSelectorArray<Selectors extends readonly string[]> = {\n\t[K in keyof Selectors]: Selectors[K] extends string\n\t\t? ElementFromSingleSelector<Selectors[K]>\n\t\t: never\n}[number]\n\n// Main type: handle both single selectors and comma-separated selectors\ntype ElementFromSelector<S extends string> = S extends `${string},${string}`\n\t? ElementsFromSelectorArray<SplitByComma<S>>\n\t: ElementFromSingleSelector<S>\n\ntype FirstElement = {\n\t<S extends string>(selector: S, required: string): ElementFromSelector<S>\n\t<S extends string>(selector: S): ElementFromSelector<S> | undefined\n\t<E extends Element>(selector: string, required: string): E\n\t<E extends Element>(selector: string): E | undefined\n}\n\ntype AllElements = {\n\t<S extends string>(\n\t\tselector: S,\n\t\trequired?: string,\n\t): Collection<ElementFromSelector<S>>\n\t<E extends Element>(selector: string, required?: string): Collection<E>\n}\ntype UI = Record<string, Element | Collection<Element>>\n\ntype ElementFromKey<U extends UI, K extends keyof U> = NonNullable<\n\tU[K] extends Collection<infer E extends Element>\n\t\t? E\n\t\t: U[K] extends Element\n\t\t\t? U[K]\n\t\t\t: never\n>\n\ntype ElementQueries = {\n\tfirst: FirstElement\n\tall: AllElements\n}\n\n/* === Constants === */\n\nconst DEPENDENCY_TIMEOUT = 50\n\n/* === Exported Functions === */\n\n/**\n * Create partially applied helper functions to get descendants and run effects on them\n *\n * @since 0.14.0\n * @param {HTMLElement} host - Host component\n * @returns {ElementSelectors<P>} - Helper functions for selecting descendants\n */\nconst getHelpers = (\n\thost: HTMLElement,\n): [ElementQueries, (run: () => void) => void] => {\n\tconst root = host.shadowRoot ?? host\n\tconst dependencies: Set<string> = new Set()\n\n\t/**\n\t * Get the first descendant element matching a selector\n\t * If the element is a custom elements it will be added to dependencies\n\t *\n\t * @since 0.15.0\n\t * @param {S} selector - Selector for element to check for\n\t * @param {string} [required] - Optional reason for the assertion; if provided, throws on missing element\n\t * @returns {ElementFromSelector<S> | undefined} First matching descendant element, or void if not found and not required\n\t * @throws {MissingElementError} - Thrown when the element is required but not found\n\t */\n\tfunction first<S extends string>(\n\t\tselector: S,\n\t\trequired: string,\n\t): ElementFromSelector<S>\n\tfunction first<S extends string>(\n\t\tselector: S,\n\t): ElementFromSelector<S> | undefined\n\tfunction first<E extends Element>(selector: string, required: string): E\n\tfunction first<E extends Element>(selector: string): E | undefined\n\tfunction first<S extends string>(\n\t\tselector: S,\n\t\trequired?: string,\n\t): ElementFromSelector<S> | undefined {\n\t\tconst target = root.querySelector<ElementFromSelector<S>>(selector)\n\t\tif (required != null && !target)\n\t\t\tthrow new MissingElementError(host, selector, required)\n\n\t\t// Only add to dependencies if element is a custom element that's not yet defined\n\t\tif (target && isNotYetDefinedComponent(target))\n\t\t\tdependencies.add(target.localName)\n\t\treturn target ?? undefined\n\t}\n\n\t/**\n\t * Get all descendant elements matching a selector\n\t * If any element is a custom element it will be added to dependencies\n\t *\n\t * @since 0.15.0\n\t * @param {S} selector - Selector for elements to check for\n\t * @param {string} [required] - Optional reason for the assertion; if provided, throws on missing elements\n\t * @returns {ElementFromSelector<S>[]} All matching descendant elements\n\t * @throws {MissingElementError} - Thrown when elements are required but not found\n\t */\n\tfunction all<S extends string>(\n\t\tselector: S,\n\t\trequired?: string,\n\t): Collection<ElementFromSelector<S>>\n\tfunction all<E extends Element>(\n\t\tselector: string,\n\t\trequired?: string,\n\t): Collection<E>\n\tfunction all<S extends string>(\n\t\tselector: S,\n\t\trequired?: string,\n\t): Collection<ElementFromSelector<S>> {\n\t\tconst collection = createCollection(root, selector)\n\t\tconst targets = collection.get()\n\t\tif (required != null && !targets.length)\n\t\t\tthrow new MissingElementError(host, selector, required)\n\t\tif (targets.length)\n\t\t\ttargets.forEach(target => {\n\t\t\t\t// Only add to dependencies if element is a custom element that's not yet defined\n\t\t\t\tif (isNotYetDefinedComponent(target)) dependencies.add(target.localName)\n\t\t\t})\n\t\treturn collection\n\t}\n\n\t/**\n\t * Resolve dependencies and thereafter run the provided function\n\t *\n\t * @param {() => void} callback - Function to run after resolving dependencies\n\t */\n\tconst resolveDependencies = (callback: () => void) => {\n\t\tif (dependencies.size) {\n\t\t\tconst deps = Array.from(dependencies)\n\t\t\tPromise.race([\n\t\t\t\tPromise.all(deps.map(dep => customElements.whenDefined(dep))),\n\t\t\t\tnew Promise((_, reject) => {\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\treject(\n\t\t\t\t\t\t\tnew DependencyTimeoutError(\n\t\t\t\t\t\t\t\thost,\n\t\t\t\t\t\t\t\tdeps.filter(dep => !customElements.get(dep)),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t)\n\t\t\t\t\t}, DEPENDENCY_TIMEOUT)\n\t\t\t\t}),\n\t\t\t])\n\t\t\t\t.then(callback)\n\t\t\t\t.catch(() => {\n\t\t\t\t\t// Error during setup of <${name}>. Trying to run effects anyway.\n\t\t\t\t\tcallback()\n\t\t\t\t})\n\t\t} else {\n\t\t\tcallback()\n\t\t}\n\t}\n\n\treturn [{ first, all }, resolveDependencies]\n}\n\nexport {\n\ttype ElementFromKey,\n\ttype ElementFromSelector,\n\ttype ElementQueries,\n\tgetHelpers,\n\ttype UI,\n}\n",
    "import {\n\ttype ComputedCallback,\n\tcreateComputed,\n\tcreateState,\n\tisComputed,\n\tisComputedCallback,\n\tisFunction,\n\tisMutableSignal,\n\tisSignal,\n\tisState,\n\tisStore,\n\ttype MaybeCleanup,\n\ttype Signal,\n\tUNSET,\n} from '@zeix/cause-effect'\n\nimport { type Effects, runEffects } from './effects'\nimport { InvalidComponentNameError, InvalidPropertyNameError } from './errors'\nimport { isParser, type Parser, type Reader } from './parsers'\nimport { type ElementQueries, getHelpers, type UI } from './ui'\nimport { validatePropertyName } from './util'\n\n/* === Types === */\n\ntype ReservedWords =\n\t| 'constructor'\n\t| 'prototype'\n\t| '__proto__'\n\t| 'toString'\n\t| 'valueOf'\n\t| 'hasOwnProperty'\n\t| 'isPrototypeOf'\n\t| 'propertyIsEnumerable'\n\t| 'toLocaleString'\n\ntype ComponentProp = Exclude<string, keyof HTMLElement | ReservedWords>\ntype ComponentProps = Record<ComponentProp, NonNullable<unknown>>\n\ntype Component<P extends ComponentProps> = HTMLElement & P\ntype ComponentUI<P extends ComponentProps, U extends UI> = U & {\n\thost: Component<P>\n}\n\ntype ComponentSetup<P extends ComponentProps, U extends UI> = (\n\tui: ComponentUI<P, U>,\n) => Effects<P, ComponentUI<P, U>>\n\ntype MethodProducer<P extends ComponentProps, U extends UI> = (\n\tui: U & { host: Component<P> },\n) => void\n\ntype Initializers<P extends ComponentProps, U extends UI> = {\n\t[K in keyof P]?:\n\t\t| P[K]\n\t\t| Signal<P[K]>\n\t\t| Parser<P[K], ComponentUI<P, U>>\n\t\t| Reader<MaybeSignal<P[K]>, ComponentUI<P, U>>\n\t\t| MethodProducer<P, ComponentUI<P, U>>\n}\n\ntype MaybeSignal<T extends {}> = T | Signal<T> | ComputedCallback<T>\n\n/* === Exported Functions === */\n\n/**\n * Define a component with dependency resolution and setup function (connectedCallback)\n *\n * @since 0.15.0\n * @param {string} name - Custom element name\n * @param {object} props - Component properties\n * @param {function} select - Function to select UI elements\n * @param {function} setup - Setup function\n * @throws {InvalidComponentNameError} If component name is invalid\n * @throws {InvalidPropertyNameError} If property name is invalid\n */\nfunction defineComponent<P extends ComponentProps, U extends UI = {}>(\n\tname: string,\n\tprops: Initializers<P, U> = {} as Initializers<P, U>,\n\tselect: (elementQueries: ElementQueries) => U = () => ({}) as U,\n\tsetup: (ui: ComponentUI<P, U>) => Effects<P, ComponentUI<P, U>> = () => ({}),\n): Component<P> {\n\tif (!name.includes('-') || !name.match(/^[a-z][a-z0-9-]*$/))\n\t\tthrow new InvalidComponentNameError(name)\n\tfor (const prop of Object.keys(props)) {\n\t\tconst error = validatePropertyName(prop)\n\t\tif (error) throw new InvalidPropertyNameError(name, prop, error)\n\t}\n\n\tclass Truc extends HTMLElement {\n\t\tdebug?: boolean\n\t\t#ui: ComponentUI<P, U> | undefined\n\t\t#signals = {} as { [K in keyof P]: Signal<P[K]> }\n\t\t#cleanup: MaybeCleanup\n\n\t\tstatic observedAttributes =\n\t\t\tObject.entries(props)\n\t\t\t\t?.filter(([, initializer]) => isParser(initializer))\n\t\t\t\t.map(([prop]) => prop) ?? []\n\n\t\t/**\n\t\t * Native callback when the custom element is first connected to the document\n\t\t */\n\t\tconnectedCallback() {\n\t\t\t// Initialize UI\n\t\t\tconst [elementQueries, resolveDependencies] = getHelpers(this)\n\t\t\tconst ui = {\n\t\t\t\t...select(elementQueries),\n\t\t\t\thost: this as unknown as Component<P>,\n\t\t\t}\n\t\t\tthis.#ui = ui\n\t\t\tObject.freeze(this.#ui)\n\n\t\t\t// Initialize signals\n\t\t\tconst isReaderOrMethodProducer = <K extends keyof P & string>(\n\t\t\t\tvalue: unknown,\n\t\t\t): value is\n\t\t\t\t| Reader<P[K], ComponentUI<P, U>>\n\t\t\t\t| MethodProducer<P, ComponentUI<P, U>> => {\n\t\t\t\treturn isFunction(value)\n\t\t\t}\n\t\t\tconst createSignal = <K extends keyof P & string>(\n\t\t\t\tkey: K,\n\t\t\t\tinitializer: Initializers<P, U>[K],\n\t\t\t) => {\n\t\t\t\tconst result = isParser<P[K], ComponentUI<P, U>>(initializer)\n\t\t\t\t\t? initializer(ui, this.getAttribute(key))\n\t\t\t\t\t: isReaderOrMethodProducer<K>(initializer)\n\t\t\t\t\t\t? initializer(ui)\n\t\t\t\t\t\t: (initializer as MaybeSignal<P[K]>)\n\t\t\t\tif (result != null) this.#setAccessor(key, result)\n\t\t\t}\n\t\t\tfor (const [prop, initializer] of Object.entries(props)) {\n\t\t\t\tif (initializer == null || prop in this) continue\n\t\t\t\tcreateSignal(prop, initializer)\n\t\t\t}\n\n\t\t\t// Resolve dependencies and run setup function\n\t\t\tresolveDependencies(() => {\n\t\t\t\tthis.#cleanup = runEffects(ui, setup(ui))\n\t\t\t})\n\t\t}\n\n\t\t/**\n\t\t * Native callback when the custom element is disconnected from the document\n\t\t */\n\t\tdisconnectedCallback() {\n\t\t\tif (isFunction(this.#cleanup)) this.#cleanup()\n\t\t}\n\n\t\t/**\n\t\t * Native callback when an observed attribute of the custom element changes\n\t\t *\n\t\t * @param {K} name - Name of the modified attribute\n\t\t * @param {string | null} oldValue - Old value of the modified attribute\n\t\t * @param {string | null} newValue - New value of the modified attribute\n\t\t */\n\t\tattributeChangedCallback<K extends keyof P>(\n\t\t\tname: K,\n\t\t\toldValue: string | null,\n\t\t\tnewValue: string | null,\n\t\t) {\n\t\t\t// Not connected yet, unchanged value or controlled by computed\n\t\t\tif (!this.#ui || newValue === oldValue || isComputed(this.#signals[name]))\n\t\t\t\treturn\n\n\t\t\t// Check whether we have a parser for the attribute\n\t\t\tconst parser = props[name]\n\t\t\tif (!isParser<P[K], ComponentUI<P, U>>(parser)) return\n\n\t\t\tconst parsed = parser(this.#ui, newValue, oldValue)\n\t\t\tif (name in this) (this as unknown as P)[name] = parsed\n\t\t\telse this.#setAccessor(name, parsed)\n\t\t}\n\n\t\t/**\n\t\t * Set the signal for a given key\n\t\t *\n\t\t * @since 0.15.0\n\t\t * @param {K} key - Key to set accessor for\n\t\t * @param {MaybeSignal<P[K]>} value - Initial value, signal or computed callback to create signal\n\t\t */\n\t\t#setAccessor<K extends keyof P>(key: K, value: MaybeSignal<P[K]>): void {\n\t\t\tconst signal = isSignal(value)\n\t\t\t\t? value\n\t\t\t\t: isComputedCallback(value)\n\t\t\t\t\t? createComputed(value)\n\t\t\t\t\t: createState(value)\n\t\t\tconst prev = this.#signals[key]\n\t\t\tconst mutable = isMutableSignal(signal)\n\t\t\tthis.#signals[key] = signal as Signal<P[K]>\n\t\t\tObject.defineProperty(this, key, {\n\t\t\t\tget: signal.get,\n\t\t\t\tset: mutable ? signal.set : undefined,\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: mutable,\n\t\t\t})\n\t\t\tif ((prev && isState(prev)) || isStore(prev)) prev.set(UNSET)\n\t\t}\n\t}\n\n\tcustomElements.define(name, Truc)\n\treturn customElements.get(name) as unknown as Component<P>\n}\n\nexport {\n\ttype Component,\n\ttype ComponentProp,\n\ttype ComponentProps,\n\ttype ComponentUI,\n\ttype ComponentSetup,\n\ttype MaybeSignal,\n\ttype ReservedWords,\n\ttype Initializers,\n\tdefineComponent,\n}\n",
    "import {\n\ttype Cleanup,\n\ttype Computed,\n\tcreateComputed,\n\tisFunction,\n\tisString,\n} from '@zeix/cause-effect'\n\nimport type { Component, ComponentProps } from './component'\nimport { type Fallback, getFallback, type Reader } from './parsers'\nimport type { UI } from './ui'\n\n/** @see https://github.com/webcomponents-cg/community-protocols/blob/main/proposals/context.md */\n\n/* === Types === */\n\n/**\n * A context key.\n *\n * A context key can be any type of object, including strings and symbols. The\n *  Context type brands the key type with the `__context__` property that\n * carries the type of the value the context references.\n */\ntype Context<K, V> = K & { __context__: V }\n\n/**\n * An unknown context type\n */\ntype UnknownContext = Context<unknown, unknown>\n\n/**\n * A helper type which can extract a Context value type from a Context type\n */\ntype ContextType<T extends UnknownContext> =\n\tT extends Context<infer _, infer V> ? V : never\n\n/**\n * A callback which is provided by a context requester and is called with the value satisfying the request.\n * This callback can be called multiple times by context providers as the requested value is changed.\n */\ntype ContextCallback<V> = (value: V, unsubscribe?: () => void) => void\n\ndeclare global {\n\tinterface HTMLElementEventMap {\n\t\t/**\n\t\t * A 'context-request' event can be emitted by any element which desires\n\t\t * a context value to be injected by an external provider.\n\t\t */\n\t\t'context-request': ContextRequestEvent<UnknownContext>\n\t}\n}\n\n/* === Constants === */\n\nconst CONTEXT_REQUEST = 'context-request'\n\n/* === Exported class === */\n\n/**\n * Class for context-request events\n *\n * An event fired by a context requester to signal it desires a named context.\n *\n * A provider should inspect the `context` property of the event to determine if it has a value that can\n * satisfy the request, calling the `callback` with the requested value if so.\n *\n * If the requested context event contains a truthy `subscribe` value, then a provider can call the callback\n * multiple times if the value is changed, if this is the case the provider should pass an `unsubscribe`\n * function to the callback which requesters can invoke to indicate they no longer wish to receive these updates.\n *\n * @class ContextRequestEvent\n * @extends {Event}\n *\n * @property {T} context - context key\n * @property {ContextCallback<ContextType<T>>} callback - callback function for value getter and unsubscribe function\n * @property {boolean} [subscribe=false] - whether to subscribe to context changes\n */\nclass ContextRequestEvent<T extends UnknownContext> extends Event {\n\treadonly context: T\n\treadonly callback: ContextCallback<ContextType<T>>\n\treadonly subscribe: boolean\n\n\tconstructor(\n\t\tcontext: T,\n\t\tcallback: ContextCallback<ContextType<T>>,\n\t\tsubscribe: boolean = false,\n\t) {\n\t\tsuper(CONTEXT_REQUEST, {\n\t\t\tbubbles: true,\n\t\t\tcomposed: true,\n\t\t})\n\t\tthis.context = context\n\t\tthis.callback = callback\n\t\tthis.subscribe = subscribe\n\t}\n}\n\n/**\n * Provide a context for descendant component consumers\n *\n * @since 0.13.3\n * @param {Context<string, P[K]>[]} contexts - Array of contexts to provide\n * @returns {(host: Component<P>) => Cleanup} Function to add an event listener for ContextRequestEvent returning a cleanup function to remove the event listener\n */\nconst provideContexts =\n\t<P extends ComponentProps>(\n\t\tcontexts: Array<keyof P>,\n\t): ((host: Component<P>) => Cleanup) =>\n\t(host: Component<P>) => {\n\t\tconst listener = (e: ContextRequestEvent<UnknownContext>) => {\n\t\t\tconst { context, callback } = e\n\t\t\tif (\n\t\t\t\tisString(context) &&\n\t\t\t\tcontexts.includes(context as unknown as Extract<keyof P, string>) &&\n\t\t\t\tisFunction(callback)\n\t\t\t) {\n\t\t\t\te.stopImmediatePropagation()\n\t\t\t\tcallback(() => host[context])\n\t\t\t}\n\t\t}\n\t\thost.addEventListener(CONTEXT_REQUEST, listener)\n\t\treturn () => host.removeEventListener(CONTEXT_REQUEST, listener)\n\t}\n\n/**\n * Consume a context value for a component\n *\n * @since 0.15.0\n * @param {Context<string, () => T>} context - Context key to consume\n * @param {Fallback<T, U>} fallback - Fallback value or reader function for fallback\n * @returns {Reader<Computed<T>, U>} Computed signal that returns the consumed context the fallback value\n */\nconst requestContext =\n\t<T extends {}, P extends ComponentProps, U extends UI>(\n\t\tcontext: Context<string, () => T>,\n\t\tfallback: Fallback<T, U & { host: Component<P> }>,\n\t): Reader<Computed<T>, U & { host: Component<P> }> =>\n\t(ui: U & { host: Component<P> }) => {\n\t\tlet consumed = () => getFallback(ui, fallback)\n\t\tui.host.dispatchEvent(\n\t\t\tnew ContextRequestEvent(context, (getter: () => T) => {\n\t\t\t\tconsumed = getter\n\t\t\t}),\n\t\t)\n\t\treturn createComputed(consumed)\n\t}\n\nexport {\n\ttype Context,\n\ttype UnknownContext,\n\ttype ContextType,\n\tCONTEXT_REQUEST,\n\tContextRequestEvent,\n\tprovideContexts,\n\trequestContext,\n}\n",
    "import type { ComponentProps } from '../component'\nimport { type Effect, type Reactive, updateElement } from '../effects'\n\n/* === Internal Functions === */\n\nconst isSafeURL = (value: string): boolean => {\n\tif (/^(mailto|tel):/i.test(value)) return true\n\tif (value.includes('://')) {\n\t\ttry {\n\t\t\tconst url = new URL(value, window.location.origin)\n\t\t\treturn ['http:', 'https:', 'ftp:'].includes(url.protocol)\n\t\t} catch {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nconst safeSetAttribute = (\n\telement: Element,\n\tattr: string,\n\tvalue: string,\n): void => {\n\tif (/^on/i.test(attr)) throw new Error(`Unsafe attribute: ${attr}`)\n\tvalue = String(value).trim()\n\tif (!isSafeURL(value)) throw new Error(`Unsafe URL for ${attr}: ${value}`)\n\telement.setAttribute(attr, value)\n}\n\n/* === Exported Functions === */\n\n/**\n * Effect for setting an attribute on an element.\n * Sets the specified attribute with security validation for unsafe values.\n *\n * @since 0.8.0\n * @param {string} name - Name of the attribute to set\n * @param {Reactive<string, P, E>} reactive - Reactive value bound to the attribute value (defaults to attribute name)\n * @returns {Effect<P, E>} Effect function that sets the attribute on the element\n */\nconst setAttribute = <P extends ComponentProps, E extends Element>(\n\tname: string,\n\treactive: Reactive<string, P, E> = name as Reactive<string, P, E>,\n): Effect<P, E> =>\n\tupdateElement(reactive, {\n\t\top: 'a',\n\t\tname,\n\t\tread: el => el.getAttribute(name),\n\t\tupdate: (el, value) => {\n\t\t\tsafeSetAttribute(el, name, value)\n\t\t},\n\t\tdelete: el => {\n\t\t\tel.removeAttribute(name)\n\t\t},\n\t})\n\n/**\n * Effect for toggling a boolean attribute on an element.\n * When the reactive value is true, the attribute is present; when false, it's absent.\n *\n * @since 0.8.0\n * @param {string} name - Name of the attribute to toggle\n * @param {Reactive<boolean, P, E>} reactive - Reactive value bound to the attribute presence (defaults to attribute name)\n * @returns {Effect<P, E>} Effect function that toggles the attribute on the element\n */\nconst toggleAttribute = <\n\tP extends ComponentProps,\n\tE extends Element = HTMLElement,\n>(\n\tname: string,\n\treactive: Reactive<boolean, P, E> = name as Reactive<boolean, P, E>,\n): Effect<P, E> =>\n\tupdateElement(reactive, {\n\t\top: 'a',\n\t\tname,\n\t\tread: el => el.hasAttribute(name),\n\t\tupdate: (el, value) => {\n\t\t\tel.toggleAttribute(name, value)\n\t\t},\n\t})\n\nexport { setAttribute, toggleAttribute }\n",
    "import type { ComponentProps } from '../component'\nimport { type Effect, type Reactive, updateElement } from '../effects'\n\n/* === Exported Function === */\n\n/**\n * Effect for toggling a CSS class token on an element.\n * When the reactive value is true, the class is added; when false, it's removed.\n *\n * @since 0.8.0\n * @param {string} token - CSS class token to toggle\n * @param {Reactive<boolean, P, E>} reactive - Reactive value bound to the class presence (defaults to class name)\n * @returns {Effect<P, U, E>} Effect function that toggles the class on the element\n */\nconst toggleClass = <P extends ComponentProps, E extends Element>(\n\ttoken: string,\n\treactive: Reactive<boolean, P, E> = token as Reactive<boolean, P, E>,\n): Effect<P, E> =>\n\tupdateElement(reactive, {\n\t\top: 'c',\n\t\tname: token,\n\t\tread: el => el.classList.contains(token),\n\t\tupdate: (el, value) => {\n\t\t\tel.classList.toggle(token, value)\n\t\t},\n\t})\n\nexport { toggleClass }\n",
    "/* === Constants === */\n\n// High-frequency events that are passive by default and should be scheduled\nconst PASSIVE_EVENTS = new Set([\n\t'scroll',\n\t'resize',\n\t'mousewheel',\n\t'touchstart',\n\t'touchmove',\n\t'wheel',\n])\n\n/* === Internal === */\n\nconst pendingElements = new Set<Element>()\nconst tasks = new WeakMap<Element, () => void>()\nlet requestId: number | undefined\n\nconst runTasks = () => {\n\trequestId = undefined\n\tconst elements = Array.from(pendingElements)\n\tpendingElements.clear()\n\tfor (const element of elements) tasks.get(element)?.()\n}\n\nconst requestTick = () => {\n\tif (requestId) cancelAnimationFrame(requestId)\n\trequestId = requestAnimationFrame(runTasks)\n}\n\n/* === Exported Function === */\n\n/**\n * Schedule a task to be executed on the next animation frame, with automatic\n * deduplication per component. If the same component schedules multiple tasks\n * before the next frame, only the latest task will be executed.\n *\n * @param element - Element for deduplication\n * @param task - Function to execute (typically calls batch() or sets a signal)\n */\nconst schedule = (element: Element, task: () => void) => {\n\ttasks.set(element, task)\n\tpendingElements.add(element)\n\trequestTick()\n}\n\nexport { PASSIVE_EVENTS, schedule }\n",
    "import { batch, type Cleanup, isRecord } from '@zeix/cause-effect'\nimport type { ComponentProps } from '../component'\nimport { type Effect } from '../effects'\nimport { PASSIVE_EVENTS, schedule } from '../scheduler'\nimport { elementName, LOG_ERROR, log } from '../util'\n\n/* === Types === */\n\ntype EventType<K extends string> = K extends keyof HTMLElementEventMap\n\t? HTMLElementEventMap[K]\n\t: Event\n\ntype EventHandler<P extends ComponentProps, Evt extends Event> = (\n\tevent: Evt,\n) => { [K in keyof P]?: P[K] } | void | Promise<void>\n\n/* === Exported Function === */\n\n/**\n * Effect for attaching an event listener to an element.\n * Provides proper cleanup when the effect is disposed.\n *\n * @since 0.14.0\n * @param {K} type - Event type\n * @param {EventHandler<P, E, EventType<K>>} handler - Event handler function\n * @param {AddEventListenerOptions | boolean} options - Event listener options\n * @returns {Effect<ComponentProps, E>} Effect function that manages the event listener\n */\nconst on =\n\t<\n\t\tK extends keyof HTMLElementEventMap | string,\n\t\tP extends ComponentProps,\n\t\tE extends Element = HTMLElement,\n\t>(\n\t\ttype: K,\n\t\thandler: EventHandler<P, EventType<K>>,\n\t\toptions: AddEventListenerOptions = {},\n\t): Effect<P, E> =>\n\t(host, target): Cleanup => {\n\t\tif (!('passive' in options))\n\t\t\toptions = { ...options, passive: PASSIVE_EVENTS.has(type) }\n\t\tconst listener = (e: Event) => {\n\t\t\tconst task = () => {\n\t\t\t\tconst result = handler(e as EventType<K>)\n\t\t\t\tif (!isRecord(result)) return\n\t\t\t\tbatch(() => {\n\t\t\t\t\tfor (const [key, value] of Object.entries(result)) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\thost[key as keyof P] = value\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\tlog(\n\t\t\t\t\t\t\t\terror,\n\t\t\t\t\t\t\t\t`Reactive property \"${key}\" on ${elementName(host)} from event ${type} on ${elementName(target)} could not be set, because it is read-only.`,\n\t\t\t\t\t\t\t\tLOG_ERROR,\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t\tif (options.passive) schedule(target, task)\n\t\t\telse task()\n\t\t}\n\t\ttarget.addEventListener(type, listener, options)\n\t\treturn () => target.removeEventListener(type, listener)\n\t}\n\nexport { type EventHandler, type EventType, on }\n",
    "import type { ComponentProps } from '../component'\nimport { type Effect, type Reactive, updateElement } from '../effects'\nimport { schedule } from '../scheduler'\n\n/* === Types === */\n\ntype DangerouslySetInnerHTMLOptions = {\n\tshadowRootMode?: ShadowRootMode\n\tallowScripts?: boolean\n}\n\n/* === Exported Function === */\n\n/**\n * Effect for setting the inner HTML of an element with optional Shadow DOM support.\n * Provides security options for script execution and shadow root creation.\n *\n * @since 0.11.0\n * @param {Reactive<string, P, E>} reactive - Reactive value bound to the inner HTML content\n * @param {DangerouslySetInnerHTMLOptions} options - Configuration options: shadowRootMode, allowScripts\n * @returns {Effect<P, E>} Effect function that sets the inner HTML of the element\n */\nconst dangerouslySetInnerHTML = <P extends ComponentProps, E extends Element>(\n\treactive: Reactive<string, P, E>,\n\toptions: DangerouslySetInnerHTMLOptions = {},\n): Effect<P, E> =>\n\tupdateElement(reactive, {\n\t\top: 'h',\n\t\tread: el =>\n\t\t\t(el.shadowRoot || !options.shadowRootMode ? el : null)?.innerHTML ?? '',\n\t\tupdate: (el, html) => {\n\t\t\tconst { shadowRootMode, allowScripts } = options\n\t\t\tif (!html) {\n\t\t\t\tif (el.shadowRoot) el.shadowRoot.innerHTML = '<slot></slot>'\n\t\t\t\treturn ''\n\t\t\t}\n\t\t\tif (shadowRootMode && !el.shadowRoot)\n\t\t\t\tel.attachShadow({ mode: shadowRootMode })\n\t\t\tconst target = el.shadowRoot || el\n\t\t\tschedule(el, () => {\n\t\t\t\ttarget.innerHTML = html\n\t\t\t\tif (allowScripts) {\n\t\t\t\t\ttarget.querySelectorAll('script').forEach(script => {\n\t\t\t\t\t\tconst newScript = document.createElement('script')\n\t\t\t\t\t\tnewScript.appendChild(\n\t\t\t\t\t\t\tdocument.createTextNode(script.textContent ?? ''),\n\t\t\t\t\t\t)\n\t\t\t\t\t\t// Safely copy only the type attribute to preserve module/MIME type info\n\t\t\t\t\t\tconst typeAttr = script.getAttribute('type')\n\t\t\t\t\t\tif (typeAttr) newScript.setAttribute('type', typeAttr)\n\t\t\t\t\t\ttarget.appendChild(newScript)\n\t\t\t\t\t\tscript.remove()\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t})\n\t\t\treturn allowScripts ? ' with scripts' : ''\n\t\t},\n\t})\n\nexport { type DangerouslySetInnerHTMLOptions, dangerouslySetInnerHTML }\n",
    "import {\n\tcreateComputed,\n\tisComputedCallback,\n\tisFunction,\n\tisRecord,\n\tisSignal,\n\tisString,\n\ttype MaybeCleanup,\n\tUNSET,\n} from '@zeix/cause-effect'\nimport type { Component, ComponentProps } from '../component'\nimport type { Effect, Reactive } from '../effects'\nimport { InvalidCustomElementError, InvalidReactivesError } from '../errors'\nimport { elementName, isCustomElement } from '../util'\n\n/* === Types === */\n\ntype PassedProp<T, P extends ComponentProps, E extends HTMLElement> =\n\t| Reactive<T, P, E>\n\t| [Reactive<T, P, E>, (value: T) => void]\n\ntype PassedProps<P extends ComponentProps, Q extends ComponentProps> = {\n\t[K in keyof Q & string]?: PassedProp<Q[K], P, Component<Q>>\n}\n\n/* === Exported Function === */\n\n/**\n * Effect for passing reactive values to a descendant Le Truc component.\n *\n * @since 0.15.0\n * @param {MutableReactives<Component<Q>, P>} props - Reactive values to pass\n * @returns {Effect<P, Component<Q>>} Effect function that passes reactive values to the descendant component\n * @throws {InvalidCustomElementError} When the target element is not a valid custom element\n * @throws {InvalidReactivesError} When the provided reactives is not a record of signals, reactive property names or functions\n * @throws {Error} When passing signals failed for some other reason\n */\nconst pass =\n\t<P extends ComponentProps, Q extends ComponentProps>(\n\t\tprops: PassedProps<P, Q> | ((target: Component<Q>) => PassedProps<P, Q>),\n\t): Effect<P, Component<Q>> =>\n\t(host, target): MaybeCleanup => {\n\t\tif (!isCustomElement(target))\n\t\t\tthrow new InvalidCustomElementError(\n\t\t\t\ttarget,\n\t\t\t\t`pass from ${elementName(host)}`,\n\t\t\t)\n\t\tconst reactives = isFunction(props) ? props(target) : props\n\t\tif (!isRecord(reactives))\n\t\t\tthrow new InvalidReactivesError(host, target, reactives)\n\n\t\tconst resetProperties: PropertyDescriptorMap = {}\n\n\t\t// Return getter from signal, reactive property name or function\n\t\tconst getGetter = (value: unknown) => {\n\t\t\tif (isSignal(value)) return value.get\n\t\t\tconst fn =\n\t\t\t\tisString(value) && value in host\n\t\t\t\t\t? () => host[value as keyof typeof host]\n\t\t\t\t\t: isComputedCallback(value)\n\t\t\t\t\t\t? value\n\t\t\t\t\t\t: undefined\n\t\t\treturn fn ? createComputed(fn).get : undefined\n\t\t}\n\n\t\t// Iterate through reactives\n\t\tfor (const [prop, reactive] of Object.entries(reactives)) {\n\t\t\tif (reactive == null) continue\n\n\t\t\t// Ensure target has configurable property\n\t\t\tconst descriptor = Object.getOwnPropertyDescriptor(target, prop)\n\t\t\tif (!(prop in target) || !descriptor?.configurable) continue\n\n\t\t\t// Determine getter\tand setter\n\t\t\tconst applied =\n\t\t\t\tisFunction(reactive) && reactive.length === 1\n\t\t\t\t\t? reactive(target)\n\t\t\t\t\t: reactive\n\t\t\tconst isArray = Array.isArray(applied) && applied.length === 2\n\t\t\tconst getter = getGetter(isArray ? applied[0] : applied)\n\t\t\tconst setter = isArray && isFunction(applied[1]) ? applied[1] : undefined\n\t\t\tif (!getter) continue\n\n\t\t\t// Store original descriptor for reset and assign new descriptor\n\t\t\tresetProperties[prop] = descriptor\n\t\t\tObject.defineProperty(target, prop, {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tget: getter,\n\t\t\t\tset: setter,\n\t\t\t})\n\n\t\t\t// Unset previous value so subscribers are notified\n\t\t\tdescriptor.set?.call(target, UNSET)\n\t\t}\n\n\t\t// Reset to original descriptors on cleanup\n\t\treturn () => {\n\t\t\tObject.defineProperties(target, resetProperties)\n\t\t}\n\t}\n\nexport { type PassedProp, type PassedProps, pass }\n",
    "import { UNSET } from '@zeix/cause-effect'\nimport type { ComponentProps } from '../component'\nimport { type Effect, type Reactive, updateElement } from '../effects'\n\n/* === Exported Functions === */\n\n/**\n * Effect for setting a property on an element.\n * Sets the specified property directly on the element object.\n *\n * @since 0.8.0\n * @param {K} key - Name of the property to set\n * @param {Reactive<E[K], P, E>} reactive - Reactive value bound to the property value (defaults to property name)\n * @returns {Effect<P, E>} Effect function that sets the property on the element\n */\nconst setProperty = <\n\tP extends ComponentProps,\n\tE extends Element,\n\tK extends keyof E & string,\n>(\n\tkey: K,\n\treactive: Reactive<E[K] & {}, P, E> = key as unknown as Reactive<\n\t\tE[K] & {},\n\t\tP,\n\t\tE\n\t>,\n): Effect<P, E> =>\n\tupdateElement(reactive, {\n\t\top: 'p',\n\t\tname: key,\n\t\tread: el => (key in el ? el[key] : UNSET),\n\t\tupdate: (el, value) => {\n\t\t\tel[key] = value\n\t\t},\n\t})\n\n/**\n * Effect for controlling element visibility by setting the 'hidden' property.\n * When the reactive value is true, the element is shown; when false, it's hidden.\n *\n * @since 0.13.1\n * @param {Reactive<boolean, P, E>} reactive - Reactive value bound to the visibility state\n * @returns {Effect<P, E>} Effect function that controls element visibility\n */\nconst show = <P extends ComponentProps, E extends HTMLElement = HTMLElement>(\n\treactive: Reactive<boolean, P, E>,\n): Effect<P, E> =>\n\tupdateElement(reactive, {\n\t\top: 'p',\n\t\tname: 'hidden',\n\t\tread: el => !el.hidden,\n\t\tupdate: (el, value) => {\n\t\t\tel.hidden = !value\n\t\t},\n\t})\n\nexport { setProperty, show }\n",
    "import type { ComponentProps } from '../component'\nimport { type Effect, type Reactive, updateElement } from '../effects'\n\n/* === Exported Function === */\n\n/**\n * Effect for setting the text content of an element.\n * Replaces all child nodes (except comments) with a single text node.\n *\n * @since 0.8.0\n * @param {Reactive<string, P, E>} reactive - Reactive value bound to the text content\n * @returns {Effect<P, E>} Effect function that sets the text content of the element\n */\nconst setText = <P extends ComponentProps, E extends Element>(\n\treactive: Reactive<string, P, E>,\n): Effect<P, E> =>\n\tupdateElement(reactive, {\n\t\top: 't',\n\t\tread: el => el.textContent,\n\t\tupdate: (el, value) => {\n\t\t\tArray.from(el.childNodes)\n\t\t\t\t.filter(node => node.nodeType !== Node.COMMENT_NODE)\n\t\t\t\t.forEach(node => node.remove())\n\t\t\tel.append(document.createTextNode(value))\n\t\t},\n\t})\n\nexport { setText }\n",
    "import type { Parser } from '../parsers'\nimport type { UI } from '../ui'\n\n/**\n * Parse a boolean attribute as an actual boolean value\n *\n * @since 0.13.1\n * @returns {Parser<boolean, UI>}\n */\nconst asBoolean =\n\t(): Parser<boolean, UI> => (_: UI, value: string | null | undefined) =>\n\t\tvalue != null && value !== 'false'\n\nexport { asBoolean }\n",
    "import { type Fallback, getFallback, type Parser } from '../parsers'\nimport type { UI } from '../ui'\n\n/* === Internal Functions === */\n\nconst parseNumber = (\n\tparseFn: (v: string) => number,\n\tvalue: string | null | undefined,\n) => {\n\tif (value == null) return\n\tconst parsed = parseFn(value)\n\treturn Number.isFinite(parsed) ? parsed : undefined\n}\n\n/* === Exported Functions === */\n\n/**\n * Parse a string as a number forced to integer with a fallback\n *\n * Supports hexadecimal and scientific notation\n *\n * @since 0.11.0\n * @param {Fallback<number, U>} [fallback=0] - Fallback value or reader function\n * @returns {Parser<number, U>} Parser function\n */\nconst asInteger =\n\t<U extends UI>(fallback: Fallback<number, U> = 0): Parser<number, U> =>\n\t(ui: U, value: string | null | undefined) => {\n\t\tif (value == null) return getFallback(ui, fallback)\n\n\t\t// Handle hexadecimal notation\n\t\tconst trimmed = value.trim()\n\t\tif (trimmed.toLowerCase().startsWith('0x'))\n\t\t\treturn (\n\t\t\t\tparseNumber(v => parseInt(v, 16), trimmed) ?? getFallback(ui, fallback)\n\t\t\t)\n\n\t\t// Handle other formats (including scientific notation)\n\t\tconst parsed = parseNumber(parseFloat, value)\n\t\treturn parsed != null ? Math.trunc(parsed) : getFallback(ui, fallback)\n\t}\n\n/**\n * Parse a string as a number with a fallback\n *\n * @since 0.11.0\n * @param {Fallback<number, U>} [fallback=0] - Fallback value or reader function\n * @returns {Parser<number, U>} Parser function\n */\nconst asNumber =\n\t<U extends UI>(fallback: Fallback<number, U> = 0): Parser<number, U> =>\n\t(ui: U, value: string | null | undefined) =>\n\t\tparseNumber(parseFloat, value) ?? getFallback(ui, fallback)\n\nexport { asInteger, asNumber }\n",
    "import { type Fallback, getFallback, type Parser } from '../parsers'\nimport type { UI } from '../ui'\n\n/**\n * Pass through string with a fallback\n *\n * @since 0.11.0\n * @param {Fallback<string, U>} [fallback=''] - Fallback value or reader function\n * @returns {Parser<string, U>} Parser function\n */\nconst asString =\n\t<U extends UI>(fallback: Fallback<string, U> = ''): Parser<string, U> =>\n\t(ui: U, value: string | null | undefined) =>\n\t\tvalue ?? getFallback(ui, fallback)\n\n/**\n * Parse a string as a multi-state value (for example: ['true', 'false', 'mixed'], defaulting to the first valid option\n *\n * @since 0.9.0\n * @param {[string, ...string[]]} valid - Array of valid values\n * @returns {Parser<string, UI>} Parser function\n */\nconst asEnum =\n\t(valid: [string, ...string[]]): Parser<string, UI> =>\n\t(_: UI, value: string | null | undefined) => {\n\t\tif (value == null) return valid[0]\n\t\tconst lowerValue = value.toLowerCase()\n\t\tconst matchingValid = valid.find(v => v.toLowerCase() === lowerValue)\n\t\treturn matchingValid ? value : valid[0]\n\t}\n\nexport { asString, asEnum }\n",
    "import {\n\ttype Computed,\n\ttype MaybeCleanup,\n\tnotify,\n\tsubscribe,\n\tTYPE_COMPUTED,\n\ttype Watcher,\n} from '@zeix/cause-effect'\nimport type { Component, ComponentProps } from '../component'\nimport { getFallback, type ParserOrFallback } from '../parsers'\nimport { PASSIVE_EVENTS, schedule } from '../scheduler'\nimport type { ElementFromKey, UI } from '../ui'\nimport { isCollection } from './collection'\n\n/* === Types === */\n\ntype EventType<K extends string> = K extends keyof HTMLElementEventMap\n\t? HTMLElementEventMap[K]\n\t: Event\n\ntype SensorHandler<\n\tT extends {},\n\tEvt extends Event,\n\tU extends UI,\n\tE extends Element,\n> = (context: {\n\tevent: Evt\n\tui: U\n\ttarget: E\n\tprev: T\n}) => T | void | Promise<void>\n\ntype SensorEvents<T extends {}, U extends UI, E extends Element> = {\n\t[K in keyof HTMLElementEventMap]?: SensorHandler<T, EventType<K>, U, E>\n}\n\n/* === Exported Functions === */\n\n/**\n * Produce a computed signal from transformed event data\n *\n * @since 0.14.0\n * @param {S} key - name of UI key\n * @param {ParserOrFallback<T>} init - Initial value, reader or parser\n * @param {SensorEvents<T, ElementFromSelector<S>, C>} events - Transformation functions for events\n * @returns {Extractor<Computed<T>, C>} Extractor function for value from event\n */\nconst createSensor =\n\t<T extends {}, P extends ComponentProps, U extends UI, K extends keyof U>(\n\t\tinit: ParserOrFallback<T, U>,\n\t\tkey: K,\n\t\tevents: SensorEvents<T, U, ElementFromKey<U, K>>,\n\t): ((ui: U & { host: Component<P> }) => Computed<T>) =>\n\t(ui: U & { host: Component<P> }) => {\n\t\tconst { host } = ui\n\t\tconst watchers: Set<Watcher> = new Set()\n\t\tlet value: T = getFallback(ui, init)\n\t\tconst targets = isCollection(ui[key])\n\t\t\t? ui[key].get()\n\t\t\t: [ui[key] as ElementFromKey<U & { host: Component<P> }, K>]\n\t\tconst eventMap = new Map<string, EventListener>()\n\t\tlet cleanup: MaybeCleanup\n\n\t\tconst getTarget = (eventTarget: Node): ElementFromKey<U, K> | undefined => {\n\t\t\tfor (const t of targets) {\n\t\t\t\tif (t.contains(eventTarget)) return t as ElementFromKey<U, K>\n\t\t\t}\n\t\t}\n\n\t\tconst listen = () => {\n\t\t\tfor (const [type, handler] of Object.entries(events)) {\n\t\t\t\tconst options = { passive: PASSIVE_EVENTS.has(type) }\n\t\t\t\tconst listener = (e: Event) => {\n\t\t\t\t\tconst eventTarget = e.target as Node\n\t\t\t\t\tif (!eventTarget) return\n\t\t\t\t\tconst target = getTarget(eventTarget)\n\t\t\t\t\tif (!target) return\n\t\t\t\t\te.stopPropagation()\n\n\t\t\t\t\tconst task = () => {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst next = handler({\n\t\t\t\t\t\t\t\tevent: e as any,\n\t\t\t\t\t\t\t\tui,\n\t\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\t\tprev: value,\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\tif (next == null || next instanceof Promise) return\n\t\t\t\t\t\t\tif (!Object.is(next, value)) {\n\t\t\t\t\t\t\t\tvalue = next\n\t\t\t\t\t\t\t\tif (watchers.size) notify(watchers)\n\t\t\t\t\t\t\t\telse if (cleanup) cleanup()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\te.stopImmediatePropagation()\n\t\t\t\t\t\t\tthrow error\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (options.passive) schedule(host, task)\n\t\t\t\t\telse task()\n\t\t\t\t}\n\t\t\t\teventMap.set(type, listener)\n\t\t\t\thost.addEventListener(type, listener, options)\n\t\t\t}\n\t\t\tcleanup = () => {\n\t\t\t\tif (eventMap.size) {\n\t\t\t\t\tfor (const [type, listener] of eventMap)\n\t\t\t\t\t\thost.removeEventListener(type, listener)\n\t\t\t\t\teventMap.clear()\n\t\t\t\t}\n\t\t\t\tcleanup = undefined\n\t\t\t}\n\t\t}\n\n\t\tconst sensor = {} as Computed<T>\n\t\tObject.defineProperties(sensor, {\n\t\t\t[Symbol.toStringTag]: {\n\t\t\t\tvalue: TYPE_COMPUTED,\n\t\t\t},\n\t\t\tget: {\n\t\t\t\tvalue: () => {\n\t\t\t\t\tsubscribe(watchers)\n\t\t\t\t\tif (watchers.size && !eventMap.size) listen()\n\t\t\t\t\treturn value\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\treturn sensor\n\t}\n\nexport { createSensor, type SensorEvents }\n",
    "import { asString, type Component, defineComponent, on, setText } from '../..'\n\nexport type BasicHelloProps = {\n\tname: string\n}\n\ntype BasicHelloUI = {\n\tinput: HTMLInputElement\n\toutput: HTMLOutputElement\n}\n\ndeclare global {\n\tinterface HTMLElementTagNameMap {\n\t\t'basic-hello': Component<BasicHelloProps>\n\t}\n}\n\nexport default defineComponent<BasicHelloProps, BasicHelloUI>(\n\t'basic-hello',\n\t{\n\t\tname: asString(ui => ui.output.textContent),\n\t},\n\t({ first }) => ({\n\t\tinput: first('input', 'Needed to enter the name.'),\n\t\toutput: first('output', 'Needed to display the name.'),\n\t}),\n\t({ host, input }) => {\n\t\tconst fallback = host.name\n\t\treturn {\n\t\t\tinput: on('input', () => {\n\t\t\t\thost.name = input.value || fallback\n\t\t\t}),\n\t\t\toutput: setText('name'),\n\t\t}\n\t},\n)\n",
    "import {\n\tasBoolean,\n\tasString,\n\ttype Component,\n\tdefineComponent,\n\tsetProperty,\n\tsetText,\n} from '../..'\n\nexport type BasicButtonProps = {\n\tdisabled: boolean\n\tlabel: string\n\tbadge: string\n}\n\ntype BasicButtonUI = {\n\tbutton: HTMLButtonElement\n\tlabel?: HTMLSpanElement\n\tbadge?: HTMLSpanElement\n}\n\ndeclare global {\n\tinterface HTMLElementTagNameMap {\n\t\t'basic-button': Component<BasicButtonProps>\n\t}\n}\n\nexport default defineComponent<BasicButtonProps, BasicButtonUI>(\n\t'basic-button',\n\t{\n\t\tdisabled: asBoolean(),\n\t\tlabel: asString(ui => ui.label?.textContent ?? ui.button.textContent),\n\t\tbadge: asString(ui => ui.badge?.textContent ?? ''),\n\t},\n\t({ first }) => ({\n\t\tbutton: first('button', 'Add a native button as descendant.'),\n\t\tlabel: first('span.label'),\n\t\tbadge: first('span.badge'),\n\t}),\n\t() => ({\n\t\tbutton: setProperty('disabled'),\n\t\tlabel: setText('label'),\n\t\tbadge: setText('badge'),\n\t}),\n)\n",
    "import {\n\tasInteger,\n\ttype Component,\n\tdefineComponent,\n\ton,\n\tread,\n\tsetText,\n} from '../..'\n\nexport type BasicCounterProps = {\n\tcount: number\n}\n\ntype BasicCounterUI = {\n\tincrement: HTMLButtonElement\n\tcount: HTMLSpanElement\n}\n\ndeclare global {\n\tinterface HTMLElementTagNameMap {\n\t\t'basic-counter': Component<BasicCounterProps>\n\t}\n}\n\nexport default defineComponent<BasicCounterProps, BasicCounterUI>(\n\t'basic-counter',\n\t{\n\t\tcount: read(ui => ui.count.textContent, asInteger()),\n\t},\n\t({ first }) => ({\n\t\tincrement: first(\n\t\t\t'button',\n\t\t\t'Add a native button element to increment the count.',\n\t\t),\n\t\tcount: first('span', 'Add a span to display the count.'),\n\t}),\n\t({ host }) => ({\n\t\tincrement: on('click', () => {\n\t\t\thost.count++\n\t\t}),\n\t\tcount: setText('count'),\n\t}),\n)\n",
    "import { asNumber, type Component, defineComponent, setText } from '../..'\n\nexport type BasicNumberProps = {\n\tvalue: number\n}\n\ndeclare global {\n\tinterface HTMLElementTagNameMap {\n\t\t'basic-number': Component<BasicNumberProps>\n\t}\n}\n\ntype Logger = {\n\tonWarn: (message: string) => void\n\tonError: (message: string) => void\n}\n\nconst FALLBACK_LOCALE = 'en'\n\nfunction getNumberFormatter(\n\tlocale: string,\n\trawOptions: string | null,\n\tlogger: Logger = {\n\t\tonWarn: console.warn,\n\t\tonError: console.error,\n\t},\n) {\n\tconst useFallback = () => new Intl.NumberFormat(locale)\n\tif (!rawOptions) return useFallback()\n\tconst { onWarn, onError } = logger\n\n\tlet o: Intl.NumberFormatOptions = {}\n\ttry {\n\t\to = JSON.parse(rawOptions)\n\t} catch (error) {\n\t\tonError?.(`Invalid JSON: ${error}`)\n\t\treturn useFallback()\n\t}\n\n\tconst style = o.style ?? 'decimal'\n\n\tconst drops: string[] = []\n\tif (style === 'currency') {\n\t\tif (\n\t\t\t!o.currency ||\n\t\t\ttypeof o.currency !== 'string' ||\n\t\t\to.currency.length !== 3\n\t\t) {\n\t\t\tonError?.(\n\t\t\t\t`style=\"currency\" requires a 3-letter ISO currency (e.g. \"CHF\").`,\n\t\t\t)\n\t\t\treturn useFallback()\n\t\t}\n\t} else {\n\t\tdrops.push('currency', 'currencyDisplay', 'currencySign')\n\t}\n\n\tif (style === 'unit') {\n\t\tif (!o.unit || typeof o.unit !== 'string') {\n\t\t\tonError?.(\n\t\t\t\t`style=\"unit\" requires a \"unit\" (e.g. \"liter\", \"kilometer-per-hour\").`,\n\t\t\t)\n\t\t\treturn useFallback()\n\t\t}\n\t} else {\n\t\tdrops.push('unit', 'unitDisplay')\n\t}\n\n\tif (o.notation && o.notation !== 'compact') drops.push('compactDisplay')\n\n\tconst sanitized: Intl.NumberFormatOptions = {}\n\tfor (const [k, v] of Object.entries(o)) {\n\t\tif (!drops.includes(k)) sanitized[k] = v\n\t\telse onWarn?.(`Option \"${k}\" is ignored for style=\"${style}\".`)\n\t}\n\n\tconst { minimumFractionDigits: minFD, maximumFractionDigits: maxFD } =\n\t\tsanitized\n\tif (minFD != null && maxFD != null && minFD > maxFD) {\n\t\tonWarn?.(\n\t\t\t`minimumFractionDigits (${minFD}) > maximumFractionDigits (${maxFD}); swapping.`,\n\t\t)\n\t\tsanitized.minimumFractionDigits = maxFD\n\t\tsanitized.maximumFractionDigits = minFD\n\t}\n\tconst { minimumSignificantDigits: minSD, maximumSignificantDigits: maxSD } =\n\t\tsanitized\n\tif (minSD != null && maxSD != null && minSD > maxSD) {\n\t\tonWarn?.(\n\t\t\t`minimumSignificantDigits (${minSD}) > maximumSignificantDigits (${maxSD}); swapping.`,\n\t\t)\n\t\tsanitized.minimumSignificantDigits = maxSD\n\t\tsanitized.maximumSignificantDigits = minSD\n\t}\n\n\ttry {\n\t\tconst formatter = new Intl.NumberFormat(locale, sanitized)\n\t\tif (formatter.resolvedOptions().locale !== locale)\n\t\t\tonWarn(\n\t\t\t\t`Fall back to locale ${formatter.resolvedOptions().locale} instead of ${locale}`,\n\t\t\t)\n\t\treturn formatter\n\t} catch (e) {\n\t\tonError?.(\n\t\t\t`Options rejected by Intl.NumberFormat: ${e instanceof Error ? e.message : String(e)}`,\n\t\t)\n\t\treturn useFallback()\n\t}\n}\n\nexport default defineComponent<BasicNumberProps>(\n\t'basic-number',\n\t{ value: asNumber() },\n\tundefined,\n\t({ host }) => {\n\t\tconst formatter = getNumberFormatter(\n\t\t\thost.closest('[lang]')?.getAttribute('lang') || FALLBACK_LOCALE,\n\t\t\thost.getAttribute('options'),\n\t\t)\n\t\treturn {\n\t\t\thost: setText(() => formatter.format(host.value)),\n\t\t}\n\t},\n)\n",
    "import {\n\tasInteger,\n\ttype Component,\n\tdefineComponent,\n\tsetText,\n\tshow,\n\tUI,\n} from '../..'\n\nexport type BasicPluralizeProps = {\n\tcount: number\n}\n\ntype BasicPluralizeUI = Partial<\n\tRecord<\n\t\t| 'count'\n\t\t| 'none'\n\t\t| 'some'\n\t\t| 'zero'\n\t\t| 'one'\n\t\t| 'two'\n\t\t| 'few'\n\t\t| 'many'\n\t\t| 'other',\n\t\tHTMLElement\n\t>\n>\n\ndeclare global {\n\tinterface HTMLElementTagNameMap {\n\t\t'basic-pluralize': Component<BasicPluralizeProps>\n\t}\n}\n\nconst FALLBACK_LOCALE = 'en'\n\n/**\n * Parse a string as a positive integer (>= 0), falling back to 0 for negative values\n */\nconst asPositiveInteger =\n\t() =>\n\t<U extends UI>(ui: U, value: string | null | undefined) => {\n\t\tconst parsed = asInteger()(ui, value)\n\t\treturn parsed < 0 ? 0 : parsed\n\t}\n\nexport default defineComponent<BasicPluralizeProps, BasicPluralizeUI>(\n\t'basic-pluralize',\n\t{\n\t\tcount: asPositiveInteger(),\n\t},\n\t({ first }) => ({\n\t\tcount: first('.count'),\n\t\tnone: first('.none'),\n\t\tsome: first('.some'),\n\t\tzero: first('.zero'),\n\t\tone: first('.one'),\n\t\ttwo: first('.two'),\n\t\tfew: first('.few'),\n\t\tmany: first('.many'),\n\t\tother: first('.other'),\n\t}),\n\t({ host }) => {\n\t\tconst pluralizer = new Intl.PluralRules(\n\t\t\thost.closest('[lang]')?.getAttribute('lang') || FALLBACK_LOCALE,\n\t\t\thost.hasAttribute('ordinal') ? { type: 'ordinal' } : undefined,\n\t\t)\n\n\t\t// Basic effects\n\t\tconst effects = {\n\t\t\tcount: setText(() => String(host.count)),\n\t\t\tnone: show(() => host.count === 0),\n\t\t\tsome: show(() => host.count > 0),\n\t\t}\n\n\t\t// Subset of plural categories for applicable pluralizer: ['zero', 'one', 'two', 'few', 'many', 'other']\n\t\tconst categories = pluralizer.resolvedOptions().pluralCategories\n\t\tfor (const category of categories)\n\t\t\teffects[category] = show(() => pluralizer.select(host.count) === category)\n\t\treturn effects\n\t},\n)\n",
    "import {\n\ttype Component,\n\ttype Context,\n\tcreateState,\n\tdefineComponent,\n\tprovideContexts,\n} from '../..'\n\nexport type ContextMediaMotion = 'no-preference' | 'reduce'\nexport type ContextMediaTheme = 'light' | 'dark'\nexport type ContextMediaViewport = 'xs' | 'sm' | 'md' | 'lg' | 'xl'\nexport type ContextMediaOrientation = 'portrait' | 'landscape'\n\nexport type ContextMediaProps = {\n\treadonly 'media-motion': ContextMediaMotion\n\treadonly 'media-theme': ContextMediaTheme\n\treadonly 'media-viewport': ContextMediaViewport\n\treadonly 'media-orientation': ContextMediaOrientation\n}\n\ndeclare global {\n\tinterface HTMLElementTagNameMap {\n\t\t'context-media': Component<ContextMediaProps>\n\t}\n}\n\n/* === Exported Contexts === */\n\nexport const MEDIA_MOTION = 'media-motion' as Context<\n\t'media-motion',\n\t() => ContextMediaMotion\n>\nexport const MEDIA_THEME = 'media-theme' as Context<\n\t'media-theme',\n\t() => ContextMediaTheme\n>\nexport const MEDIA_VIEWPORT = 'media-viewport' as Context<\n\t'media-viewport',\n\t() => ContextMediaViewport\n>\nexport const MEDIA_ORIENTATION = 'media-orientation' as Context<\n\t'media-orientation',\n\t() => ContextMediaOrientation\n>\n\n/* === Component === */\n\nexport default defineComponent<ContextMediaProps>(\n\t'context-media',\n\t{\n\t\t// Context for motion preference; true for no-preference, false for reduce\n\t\t[MEDIA_MOTION]: () => {\n\t\t\tconst mql = matchMedia('(prefers-reduced-motion: reduce)')\n\t\t\tconst motion = createState(mql.matches ? 'reduce' : 'no-preference')\n\t\t\tmql.addEventListener('change', e => {\n\t\t\t\tmotion.set(e.matches ? 'reduce' : 'no-preference')\n\t\t\t})\n\t\t\treturn motion\n\t\t},\n\n\t\t// Context for preferred color scheme\n\t\t[MEDIA_THEME]: () => {\n\t\t\tconst mql = matchMedia('(prefers-color-scheme: dark)')\n\t\t\tconst theme = createState(mql.matches ? 'dark' : 'light')\n\t\t\tmql.addEventListener('change', e => {\n\t\t\t\ttheme.set(e.matches ? 'dark' : 'light')\n\t\t\t})\n\t\t\treturn theme\n\t\t},\n\n\t\t// Context for screen viewport size\n\t\t[MEDIA_VIEWPORT]: (ui: { host: HTMLElement }) => {\n\t\t\tconst getBreakpoint = (attr: string, fallback: string) => {\n\t\t\t\tconst value = ui.host.getAttribute(attr)\n\t\t\t\tconst trimmed = value?.trim()\n\t\t\t\tif (!trimmed) return fallback\n\t\t\t\tconst unit = trimmed.match(/em$/) ? 'em' : 'px'\n\t\t\t\tconst v = parseFloat(trimmed)\n\t\t\t\treturn Number.isFinite(v) ? v + unit : fallback\n\t\t\t}\n\t\t\tconst mqlSM = matchMedia(`(min-width: ${getBreakpoint('sm', '32em')})`)\n\t\t\tconst mqlMD = matchMedia(`(min-width: ${getBreakpoint('md', '48em')})`)\n\t\t\tconst mqlLG = matchMedia(`(min-width: ${getBreakpoint('lg', '72em')})`)\n\t\t\tconst mqlXL = matchMedia(`(min-width: ${getBreakpoint('xl', '104em')})`)\n\t\t\tconst getViewport = () => {\n\t\t\t\tif (mqlXL.matches) return 'xl'\n\t\t\t\tif (mqlLG.matches) return 'lg'\n\t\t\t\tif (mqlMD.matches) return 'md'\n\t\t\t\tif (mqlSM.matches) return 'sm'\n\t\t\t\treturn 'xs'\n\t\t\t}\n\t\t\tconst viewport = createState(getViewport())\n\t\t\tmqlSM.addEventListener('change', () => {\n\t\t\t\tviewport.set(getViewport())\n\t\t\t})\n\t\t\tmqlMD.addEventListener('change', () => {\n\t\t\t\tviewport.set(getViewport())\n\t\t\t})\n\t\t\tmqlLG.addEventListener('change', () => {\n\t\t\t\tviewport.set(getViewport())\n\t\t\t})\n\t\t\tmqlXL.addEventListener('change', () => {\n\t\t\t\tviewport.set(getViewport())\n\t\t\t})\n\t\t\treturn viewport\n\t\t},\n\n\t\t// Context for screen orientation\n\t\t[MEDIA_ORIENTATION]: () => {\n\t\t\tconst mql = matchMedia('(orientation: landscape)')\n\t\t\tconst orientation = createState(mql.matches ? 'landscape' : 'portrait')\n\t\t\tmql.addEventListener('change', e => {\n\t\t\t\torientation.set(e.matches ? 'landscape' : 'portrait')\n\t\t\t})\n\t\t\treturn orientation\n\t\t},\n\t},\n\tundefined,\n\t() => ({\n\t\thost: provideContexts([\n\t\t\tMEDIA_MOTION,\n\t\t\tMEDIA_THEME,\n\t\t\tMEDIA_VIEWPORT,\n\t\t\tMEDIA_ORIENTATION,\n\t\t]),\n\t}),\n)\n",
    "import { Component, defineComponent, requestContext, setText } from '../..'\nimport {\n\tMEDIA_MOTION,\n\tMEDIA_ORIENTATION,\n\tMEDIA_THEME,\n\tMEDIA_VIEWPORT,\n} from '../context-media/context-media'\n\ntype CardMediaqueriesPropKeys = 'motion' | 'theme' | 'viewport' | 'orientation'\n\nexport type CardMediaqueriesProps = Record<CardMediaqueriesPropKeys, string>\n\ntype CardMediaqueriesUI = Partial<Record<CardMediaqueriesPropKeys, HTMLElement>>\n\ndeclare global {\n\tinterface HTMLElementTagNameMap {\n\t\t'card-mediaqueries': Component<CardMediaqueriesProps>\n\t}\n}\n\nexport default defineComponent<CardMediaqueriesProps, CardMediaqueriesUI>(\n\t'card-mediaqueries',\n\t{\n\t\tmotion: requestContext(MEDIA_MOTION, 'unknown'),\n\t\ttheme: requestContext(MEDIA_THEME, 'unknown'),\n\t\tviewport: requestContext(MEDIA_VIEWPORT, 'unknown'),\n\t\torientation: requestContext(MEDIA_ORIENTATION, 'unknown'),\n\t},\n\t({ first }) => ({\n\t\tmotion: first('.motion'),\n\t\ttheme: first('.theme'),\n\t\tviewport: first('.viewport'),\n\t\torientation: first('.orientation'),\n\t}),\n\t() => ({\n\t\tmotion: setText('motion'),\n\t\ttheme: setText('theme'),\n\t\tviewport: setText('viewport'),\n\t\torientation: setText('orientation'),\n\t}),\n)\n",
    "import {\n\tasString,\n\ttype Component,\n\tcreateSensor,\n\tdefineComponent,\n\tread,\n\tsetText,\n\ttoggleAttribute,\n} from '../..'\n\nexport type FormCheckboxProps = {\n\treadonly checked: boolean\n\tlabel: string\n}\n\ntype FormCheckboxUI = {\n\tcheckbox: HTMLInputElement\n\tlabel?: HTMLElement\n}\n\ndeclare global {\n\tinterface HTMLElementTagNameMap {\n\t\t'form-checkbox': Component<FormCheckboxProps>\n\t}\n}\n\nexport default defineComponent<FormCheckboxProps, FormCheckboxUI>(\n\t'form-checkbox',\n\t{\n\t\tchecked: createSensor(\n\t\t\tread(ui => ui.checkbox.checked, false),\n\t\t\t'checkbox',\n\t\t\t{\n\t\t\t\tchange: ({ target }) => target.checked,\n\t\t\t},\n\t\t),\n\t\tlabel: asString(\n\t\t\t({ host, label }) =>\n\t\t\t\tlabel?.textContent ?? host.querySelector('label')?.textContent ?? '',\n\t\t),\n\t},\n\t({ first }) => ({\n\t\tcheckbox: first('input[type=\"checkbox\"]', 'Add a native checkbox.'),\n\t\tlabel: first('.label'),\n\t}),\n\t() => ({\n\t\thost: toggleAttribute('checked'),\n\t\tlabel: setText('label'),\n\t}),\n)\n",
    "import { type Component, ComponentUI, type Effect, on, show, UI } from '../..'\n\n/**\n * Creates a clear method for input components\n *\n * @param {HTMLInputElement | HTMLTextAreaElement} selector - The native input or textarea element\n */\nexport const clearMethod = <\n\tP extends {\n\t\tclear: () => void\n\t\tvalue: string | number\n\t\treadonly length: number\n\t},\n\tU extends {\n\t\thost: Component<P>\n\t\ttextbox: HTMLInputElement | HTMLTextAreaElement\n\t},\n>({\n\thost,\n\ttextbox,\n}: ComponentUI<P, U>) => {\n\thost.clear = () => {\n\t\thost.value = ''\n\t\ttextbox.value = ''\n\t\ttextbox.setCustomValidity('')\n\t\ttextbox.checkValidity()\n\t\ttextbox.dispatchEvent(new Event('input', { bubbles: true }))\n\t\ttextbox.dispatchEvent(new Event('change', { bubbles: true }))\n\t\ttextbox.focus()\n\t}\n}\n\n/**\n * Standard effects for clearing input components on button elements\n *\n * @param {ComponentUI<P, U>} ui - The component UI with a host that has clear, length properties\n * @returns {Effect<P, HTMLElement>[]} - Effects for clearing the input component\n */\nexport const clearEffects = <\n\tP extends { clear: () => void; readonly length: number },\n\tU extends UI,\n>(\n\tui: ComponentUI<P, U>,\n): Effect<P, HTMLElement>[] => [\n\tshow(() => !!ui.host.length),\n\ton('click', () => {\n\t\tui.host.clear()\n\t}),\n]\n",
    "import {\n\tbatch,\n\ttype Component,\n\tcreateComputed,\n\tcreateSensor,\n\tcreateState,\n\tdefineComponent,\n\ton,\n\tpass,\n\tread,\n\tsetAttribute,\n\tsetProperty,\n\tsetText,\n\tshow,\n} from '../..'\nimport { clearEffects, clearMethod } from '../_common/clear'\nimport { FormListboxProps } from '../form-listbox/form-listbox'\n\nexport type FormComboboxProps = {\n\tvalue: string\n\treadonly length: number\n\terror: string\n\tdescription: string\n\treadonly clear: () => void\n}\n\ntype FormComboboxUI = {\n\ttextbox: HTMLInputElement\n\tlistbox: Component<FormListboxProps>\n\tclear?: HTMLButtonElement\n\terror?: HTMLElement\n\tdescription?: HTMLElement\n}\n\ndeclare global {\n\tinterface HTMLElementTagNameMap {\n\t\t'form-combobox': Component<FormComboboxProps>\n\t}\n}\n\nexport default defineComponent<FormComboboxProps, FormComboboxUI>(\n\t'form-combobox',\n\t{\n\t\tvalue: read(ui => ui.textbox.value, ''),\n\t\tlength: createSensor(\n\t\t\tread(ui => ui.textbox.value.length, 0),\n\t\t\t'textbox',\n\t\t\t{\n\t\t\t\tinput: ({ target }) => target.value.length,\n\t\t\t},\n\t\t),\n\t\terror: '',\n\t\tdescription: read(ui => ui.description?.textContent, ''),\n\t\tclear: clearMethod,\n\t},\n\t({ first }) => ({\n\t\ttextbox: first('input', 'Needed to enter value.'),\n\t\tlistbox: first('form-listbox', 'Needed to display options.'),\n\t\tclear: first('button.clear'),\n\t\terror: first('form-combobox > .error'),\n\t\tdescription: first('.description'),\n\t}),\n\tui => {\n\t\tconst { host, error, description, listbox, textbox } = ui\n\t\tconst errorId = error?.id\n\t\tconst descriptionId = description?.id\n\n\t\tconst showPopup = createState(false)\n\t\tconst isExpanded = createComputed(\n\t\t\t() => showPopup.get() && listbox.options.length > 0,\n\t\t)\n\n\t\treturn {\n\t\t\thost: [\n\t\t\t\tsetAttribute('value'),\n\t\t\t\ton('keyup', ({ key }) => {\n\t\t\t\t\tif (key === 'Escape') showPopup.set(false)\n\t\t\t\t\tif (key === 'Delete') host.clear()\n\t\t\t\t}),\n\t\t\t],\n\t\t\ttextbox: [\n\t\t\t\tsetProperty('ariaInvalid', () => String(!!host.error)),\n\t\t\t\tsetAttribute('aria-errormessage', () =>\n\t\t\t\t\thost.error && errorId ? errorId : null,\n\t\t\t\t),\n\t\t\t\tsetAttribute('aria-describedby', () =>\n\t\t\t\t\thost.description && descriptionId ? descriptionId : null,\n\t\t\t\t),\n\t\t\t\tsetProperty('ariaExpanded', () => String(isExpanded.get())),\n\t\t\t\ton('input', () => {\n\t\t\t\t\ttextbox.checkValidity()\n\t\t\t\t\tbatch(() => {\n\t\t\t\t\t\thost.value = textbox.value\n\t\t\t\t\t\thost.error = textbox.validationMessage ?? ''\n\t\t\t\t\t\tshowPopup.set(true)\n\t\t\t\t\t})\n\t\t\t\t}),\n\t\t\t\ton('keydown', e => {\n\t\t\t\t\tconst { key, altKey } = e\n\t\t\t\t\tif (key === 'ArrowDown') {\n\t\t\t\t\t\tif (altKey) showPopup.set(true)\n\t\t\t\t\t\tif (isExpanded.get()) listbox.options[0]?.focus()\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t],\n\t\t\tlistbox: [\n\t\t\t\tshow(isExpanded),\n\t\t\t\tpass({\n\t\t\t\t\tfilter: () => host.value,\n\t\t\t\t}),\n\t\t\t\ton('change', ({ target }) => {\n\t\t\t\t\tif (target instanceof HTMLInputElement) {\n\t\t\t\t\t\ttextbox.value = target.value\n\t\t\t\t\t\ttextbox.checkValidity()\n\t\t\t\t\t\tbatch(() => {\n\t\t\t\t\t\t\thost.value = target.value\n\t\t\t\t\t\t\thost.error = textbox.validationMessage ?? ''\n\t\t\t\t\t\t\tshowPopup.set(false)\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t],\n\t\t\tclear: [...clearEffects(ui)],\n\t\t\terror: [setText('error')],\n\t\t\tdescription: [setText('description')],\n\t\t}\n\t},\n)\n",
    "/* === Types === */\n\ntype CacheEntry<T = unknown> = {\n\tcontent: T\n\ttimestamp: number\n\tetag?: string\n\tlastModified?: string\n\tmaxAge?: number\n}\n\n/* === Internal Stuff === */\n\nconst cache = new Map<string, CacheEntry>()\n\nconst parseCacheControl = (\n\theader: string,\n): { maxAge?: number; noCache: boolean; noStore: boolean } => {\n\tconst directives = header\n\t\t.toLowerCase()\n\t\t.split(',')\n\t\t.map(d => d.trim())\n\tconst result = {\n\t\tnoCache: false,\n\t\tnoStore: false,\n\t\tmaxAge: undefined as number | undefined,\n\t}\n\n\tfor (const directive of directives) {\n\t\tif (directive === 'no-cache') result.noCache = true\n\t\telse if (directive === 'no-store') result.noStore = true\n\t\telse if (directive.startsWith('max-age=')) {\n\t\t\tconst value = parseInt(directive.substring(8), 10)\n\t\t\tif (!isNaN(value)) result.maxAge = value\n\t\t}\n\t}\n\n\treturn result\n}\n\nconst isCacheEntryValid = (entry: CacheEntry): boolean => {\n\tif (entry.maxAge !== undefined) {\n\t\tconst age = (Date.now() - entry.timestamp) / 1000\n\t\treturn age < entry.maxAge\n\t}\n\treturn true\n}\n\n/* === Exported Functions === */\n\n/**\n * Check if an URL is recursive\n *\n * @param {string} value - URL to check\n * @param {HTMLElement} host - Host element\n * @param {string} attr - Attribute name\n * @returns {boolean} - True if the URL is recursive, false otherwise\n */\nexport const isRecursiveURL = (\n\tvalue: string,\n\thost: HTMLElement,\n\tattr: string = 'src',\n): boolean =>\n\t!!value &&\n\t!!(host.parentElement || (host.getRootNode() as ShadowRoot).host)?.closest(\n\t\t`${host.localName}[${attr}=\"${value}\"]`,\n\t)\n\n/**\n * Check if an URL is valid\n *\n * @param {string} value - URL to check\n * @returns {boolean} - True if the URL is valid, false otherwise\n */\nexport const isValidURL = (value: string): boolean => {\n\tif (!value) return false\n\ttry {\n\t\tconst url = new URL(value, location.href)\n\t\tif (url.origin === location.origin) return true\n\t} catch {\n\t\treturn false\n\t}\n\treturn false\n}\n\n/**\n * Fetch with HTTP caching support\n *\n * @param url - URL to fetch\n * @param signal - AbortSignal for cancellation\n * @param parseResponse - Function to parse the response body (defaults to text)\n * @returns Promise with parsed content and cache status\n */\nexport const fetchWithCache = async <T = string>(\n\turl: string,\n\tsignal?: AbortSignal,\n\tparseResponse: (response: Response) => Promise<T> = (response: Response) =>\n\t\tresponse.text() as Promise<T>,\n): Promise<{ content: T; fromCache: boolean }> => {\n\tconst cached = cache.get(url) as CacheEntry<T> | undefined\n\tconst headers: HeadersInit = {}\n\n\t// Add conditional headers if we have cached data\n\tif (cached?.etag) headers['If-None-Match'] = cached.etag\n\tif (cached?.lastModified) headers['If-Modified-Since'] = cached.lastModified\n\n\tconst response = await fetch(url, { signal, headers })\n\n\t// Handle 304 Not Modified\n\tif (response.status === 304 && cached)\n\t\treturn { content: cached.content, fromCache: true }\n\n\tif (!response.ok) throw new Error(`HTTP error: ${response.statusText}`)\n\n\tconst content = await parseResponse(response)\n\tconst cacheControl = response.headers.get('cache-control')\n\tconst etag = response.headers.get('etag')\n\tconst lastModified = response.headers.get('last-modified')\n\n\t// Parse cache directives\n\tconst cacheDirectives = cacheControl\n\t\t? parseCacheControl(cacheControl)\n\t\t: { noCache: false, noStore: false }\n\n\t// Store in cache if allowed\n\tif (!cacheDirectives.noStore) {\n\t\tconst entry: CacheEntry<T> = {\n\t\t\tcontent,\n\t\t\ttimestamp: Date.now(),\n\t\t\tetag: etag || undefined,\n\t\t\tlastModified: lastModified || undefined,\n\t\t\tmaxAge: cacheDirectives.maxAge,\n\t\t}\n\n\t\tif (!cacheDirectives.noCache || isCacheEntryValid(entry))\n\t\t\tcache.set(url, entry)\n\t}\n\n\treturn { content, fromCache: false }\n}\n\n/**\n * Clear the entire cache\n */\nexport const clearCache = (): void => {\n\tcache.clear()\n}\n\n/**\n * Remove a specific URL from cache\n */\nexport const removeCacheEntry = (url: string): boolean => {\n\treturn cache.delete(url)\n}\n\n/**\n * Get cache size\n */\nexport const getCacheSize = (): number => {\n\treturn cache.size\n}\n",
    "import { type Collection, on } from '../..'\n\n/* === Constants ===  */\n\nconst ENTER_KEY = 'Enter'\nconst DECREMENT_KEYS = ['ArrowLeft', 'ArrowUp']\nconst INCREMENT_KEYS = ['ArrowRight', 'ArrowDown']\nconst FIRST_KEY = 'Home'\nconst LAST_KEY = 'End'\nconst HANDLED_KEYS = [...DECREMENT_KEYS, ...INCREMENT_KEYS, FIRST_KEY, LAST_KEY]\n\n/* === Exported Functions === */\n\nexport const manageFocus = <E extends HTMLInputElement | HTMLButtonElement>(\n\tcollection: Collection<E>,\n\tgetSelectedIndex: (radios: Collection<E>) => number,\n) => {\n\tlet index = getSelectedIndex(collection)\n\n\treturn [\n\t\ton('click', ({ target }) => {\n\t\t\tif (!(target instanceof HTMLElement)) return\n\t\t\tif (target && target.hasAttribute('value'))\n\t\t\t\tindex = collection.get().findIndex(item => item === target)\n\t\t}),\n\t\ton('keydown', e => {\n\t\t\tconst { key } = e\n\t\t\tif (!HANDLED_KEYS.includes(key)) return\n\t\t\te.preventDefault()\n\t\t\te.stopPropagation()\n\t\t\tif (key === FIRST_KEY) index = 0\n\t\t\telse if (key === LAST_KEY) index = collection.length - 1\n\t\t\telse\n\t\t\t\tindex =\n\t\t\t\t\t(index +\n\t\t\t\t\t\t(INCREMENT_KEYS.includes(key) ? 1 : -1) +\n\t\t\t\t\t\tcollection.length) %\n\t\t\t\t\tcollection.length\n\t\t\tif (collection[index]) collection[index].focus()\n\t\t}),\n\t\ton('keyup', ({ key }) => {\n\t\t\tif (key === ENTER_KEY && collection[index]) collection[index].click()\n\t\t}),\n\t]\n}\n",
    "export const highlightMatch = (text: string, query: string): string => {\n\tif (!query) return text\n\tconst regex = new RegExp(query.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'), 'gi')\n\treturn text.replace(regex, '<mark>$&</mark>')\n}\n",
    "import {\n\tasString,\n\ttype Collection,\n\ttype Component,\n\tcreateCollection,\n\tcreateComputed,\n\tdangerouslySetInnerHTML,\n\tdefineComponent,\n\ton,\n\tsetAttribute,\n\tsetProperty,\n\tsetText,\n\tshow,\n\ttoggleClass,\n} from '../..'\n\nimport { fetchWithCache, isRecursiveURL, isValidURL } from '../_common/fetch'\nimport { manageFocus } from '../_common/focus'\nimport { highlightMatch } from '../_common/highlight'\n\n/**\n * Form-aware Listbox Component\n *\n * A filterable listbox that loads options from remote JSON sources and integrates\n * seamlessly with HTML forms. Includes keyboard navigation, accessibility features,\n * and automatic form value synchronization via a built-in hidden input element.\n */\n\nexport type FormListboxOption = {\n\tvalue: string\n\tlabel: string\n}\n\nexport type FormListboxGroups = Record<\n\tstring,\n\t{\n\t\tlabel: string\n\t\titems: FormListboxOption[]\n\t}\n>\n\nexport type FormListboxProps = {\n\tvalue: string\n\toptions: Collection<HTMLButtonElement>\n\tfilter: string\n\tsrc: string\n}\n\ntype FormListboxUI = {\n\tinput: HTMLInputElement\n\tcallout?: HTMLElement\n\tloading?: HTMLElement\n\terror?: HTMLElement\n\tlistbox: HTMLElement\n\toptions: Collection<HTMLButtonElement>\n}\n\ndeclare global {\n\tinterface HTMLElementTagNameMap {\n\t\t'form-listbox': Component<FormListboxProps>\n\t}\n}\n\nexport default defineComponent<FormListboxProps, FormListboxUI>(\n\t'form-listbox',\n\t{\n\t\tvalue: '',\n\t\toptions: ({ listbox }) =>\n\t\t\tcreateCollection(listbox, 'button[role=\"option\"]:not([hidden])'),\n\t\tfilter: '',\n\t\tsrc: asString(),\n\t},\n\t({ first, all }) => ({\n\t\tinput: first('input[type=\"hidden\"]', 'Needed to store the selected value.'),\n\t\tcallout: first('card-callout'),\n\t\tloading: first('.loading'),\n\t\terror: first('.error'),\n\t\tlistbox: first('[role=\"listbox\"]', 'Needed to display list of options.'),\n\t\toptions: all('button[role=\"option\"]'),\n\t}),\n\tui => {\n\t\tconst { host, input } = ui\n\n\t\tconst renderOptions = (items: FormListboxOption[]) =>\n\t\t\titems\n\t\t\t\t.map(\n\t\t\t\t\titem => `\n\t\t\t\t\t<button type=\"button\" role=\"option\" tabindex=\"-1\" value=\"${item.value}\">\n\t\t\t\t\t\t${item.label}\n\t\t\t\t\t</button>`,\n\t\t\t\t)\n\t\t\t\t.join('')\n\n\t\tconst renderGroups = (items: FormListboxGroups) => {\n\t\t\tconst id = host.id\n\t\t\tlet html = ''\n\t\t\tfor (const [key, value] of Object.entries(items)) {\n\t\t\t\thtml += `\n\t\t\t\t<div role=\"group\" aria-labelledby=\"${id}-${key}\">\n\t\t\t\t\t<div role=\"presentation\" id=\"${id}-${key}\">${value.label}</div>\n\t\t\t\t\t${renderOptions(value.items)}\n\t\t\t\t</div>`\n\t\t\t}\n\t\t\treturn html\n\t\t}\n\n\t\tconst maybeRender = () =>\n\t\t\thost.src\n\t\t\t\t? [\n\t\t\t\t\t\tshow(() => html.get().ok),\n\t\t\t\t\t\tdangerouslySetInnerHTML(() => html.get().value),\n\t\t\t\t\t]\n\t\t\t\t: []\n\n\t\tconst html = createComputed<{\n\t\t\tok: boolean\n\t\t\tvalue: string\n\t\t\terror: string\n\t\t\tpending: boolean\n\t\t}>(\n\t\t\tasync (_prev, abort) => {\n\t\t\t\tconst url = host.src\n\t\t\t\tconst error = !url\n\t\t\t\t\t? 'No URL provided'\n\t\t\t\t\t: !isValidURL(url)\n\t\t\t\t\t\t? 'Invalid URL'\n\t\t\t\t\t\t: isRecursiveURL(url, host)\n\t\t\t\t\t\t\t? 'Recursive URL detected'\n\t\t\t\t\t\t\t: ''\n\t\t\t\tif (error) return { ok: false, value: '', error, pending: false }\n\n\t\t\t\ttry {\n\t\t\t\t\tconst { content } = await fetchWithCache(url, abort, response =>\n\t\t\t\t\t\tresponse.json(),\n\t\t\t\t\t)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tok: true,\n\t\t\t\t\t\tvalue: Array.isArray(content)\n\t\t\t\t\t\t\t? renderOptions(content)\n\t\t\t\t\t\t\t: renderGroups(content),\n\t\t\t\t\t\terror: '',\n\t\t\t\t\t\tpending: false,\n\t\t\t\t\t}\n\t\t\t\t} catch (err) {\n\t\t\t\t\treturn { ok: false, value: '', error: String(err), pending: false }\n\t\t\t\t}\n\t\t\t},\n\t\t\t{ ok: false, value: '', error: '', pending: true },\n\t\t)\n\t\tconst isSelected = (target: HTMLButtonElement) =>\n\t\t\thost.value === target.value\n\t\tconst hasError = () => (host.src ? !!html.get().error : false)\n\n\t\treturn {\n\t\t\thost: setAttribute('value'),\n\t\t\tinput: setProperty('value'),\n\t\t\tcallout: [\n\t\t\t\tshow(() => (host.src ? !html.get().ok : false)),\n\t\t\t\ttoggleClass('danger', hasError),\n\t\t\t],\n\t\t\tloading: show(() => (host.src ? html.get().pending : false)),\n\t\t\terror: [\n\t\t\t\tshow(hasError),\n\t\t\t\tsetText(() => (host.src ? html.get().error : '')),\n\t\t\t],\n\t\t\tlistbox: [\n\t\t\t\t...manageFocus(host.options, options =>\n\t\t\t\t\toptions.get().findIndex(option => option.ariaSelected === 'true'),\n\t\t\t\t),\n\t\t\t\ton('click', ({ target }) => {\n\t\t\t\t\tconst option = (target as HTMLElement).closest(\n\t\t\t\t\t\t'[role=\"option\"]',\n\t\t\t\t\t) as HTMLButtonElement\n\t\t\t\t\tif (option && option.value !== host.value) {\n\t\t\t\t\t\thost.value = option.value\n\t\t\t\t\t\tinput.dispatchEvent(new Event('change', { bubbles: true }))\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t\t...maybeRender(),\n\t\t\t],\n\t\t\toptions: [\n\t\t\t\tsetProperty('tabIndex', target => (isSelected(target) ? 0 : -1)),\n\t\t\t\tshow(target =>\n\t\t\t\t\ttarget.textContent\n\t\t\t\t\t\t?.trim()\n\t\t\t\t\t\t.toLowerCase()\n\t\t\t\t\t\t.includes(host.filter.toLowerCase()),\n\t\t\t\t),\n\t\t\t\tdangerouslySetInnerHTML(target =>\n\t\t\t\t\thighlightMatch(target.textContent ?? '', host.filter),\n\t\t\t\t),\n\t\t\t\tsetProperty('ariaSelected', target => String(isSelected(target))),\n\t\t\t],\n\t\t}\n\t},\n)\n",
    "import {\n\ttype Collection,\n\ttype Component,\n\tcreateSensor,\n\tdefineComponent,\n\tread,\n\tsetProperty,\n\ttoggleClass,\n} from '../..'\nimport { manageFocus } from '../_common/focus'\n\nexport type FormRadiogroupProps = {\n\treadonly value: string\n}\n\ntype FormRadiogroupUI = {\n\tradios: Collection<HTMLInputElement>\n\tlabels: Collection<HTMLLabelElement>\n}\n\ndeclare global {\n\tinterface HTMLElementTagNameMap {\n\t\t'form-radiogroup': Component<FormRadiogroupProps>\n\t}\n}\n\nconst getIndex = (radios: Collection<HTMLInputElement>) =>\n\tradios.get().findIndex(radio => radio.checked)\n\nexport default defineComponent<FormRadiogroupProps, FormRadiogroupUI>(\n\t'form-radiogroup',\n\t{\n\t\tvalue: createSensor(\n\t\t\tread(({ radios }) => radios[getIndex(radios)]?.value, ''),\n\t\t\t'radios',\n\t\t\t{\n\t\t\t\tchange: ({ target }) => target.value,\n\t\t\t},\n\t\t),\n\t},\n\t({ all }) => ({\n\t\tradios: all(\n\t\t\t'input[type=\"radio\"]',\n\t\t\t'Add at least two native radio buttons.',\n\t\t),\n\t\tlabels: all('label', 'Wrap radio buttons with labels.'),\n\t}),\n\t({ host, radios }) => ({\n\t\thost: manageFocus(radios, getIndex),\n\t\tradios: setProperty('tabIndex', target =>\n\t\t\ttarget.value === host.value ? 0 : -1,\n\t\t),\n\t\tlabels: toggleClass(\n\t\t\t'selected',\n\t\t\ttarget => host.value === target.querySelector('input')?.value,\n\t\t),\n\t}),\n)\n",
    "import {\n\tasInteger,\n\ttype Collection,\n\ttype Component,\n\tcreateComputed,\n\tcreateSensor,\n\tdefineComponent,\n\tread,\n\tsetProperty,\n\tshow,\n} from '../..'\n\nexport type FormSpinbuttonProps = {\n\treadonly value: number\n\tmax: number\n}\n\ntype FormSpinbuttonUI = {\n\tcontrols: Collection<HTMLButtonElement | HTMLInputElement>\n\tincrement: HTMLButtonElement\n\tdecrement: HTMLButtonElement\n\tinput: HTMLInputElement\n\tzero?: HTMLElement\n\tother?: HTMLElement\n}\n\ndeclare global {\n\tinterface HTMLElementTagNameMap {\n\t\t'form-spinbutton': Component<FormSpinbuttonProps>\n\t}\n}\n\nexport default defineComponent<FormSpinbuttonProps, FormSpinbuttonUI>(\n\t'form-spinbutton',\n\t{\n\t\tvalue: createSensor(\n\t\t\tread(ui => ui.input.value, asInteger()),\n\t\t\t'controls',\n\t\t\t{\n\t\t\t\tchange: ({ ui, target, prev }) => {\n\t\t\t\t\tif (!(target instanceof HTMLInputElement)) return prev\n\n\t\t\t\t\tconst resetTo = (next: number) => {\n\t\t\t\t\t\ttarget.value = String(next)\n\t\t\t\t\t\ttarget.checkValidity()\n\t\t\t\t\t\treturn next\n\t\t\t\t\t}\n\n\t\t\t\t\tconst next = Number(target.value)\n\t\t\t\t\tif (!Number.isInteger(next)) return resetTo(prev)\n\t\t\t\t\tconst clamped = Math.min(ui.host.max, Math.max(0, next))\n\t\t\t\t\tif (next !== clamped) return resetTo(clamped)\n\t\t\t\t\treturn clamped\n\t\t\t\t},\n\t\t\t\tclick: ({ target, prev }) =>\n\t\t\t\t\tprev +\n\t\t\t\t\t(target.classList.contains('decrement')\n\t\t\t\t\t\t? -1\n\t\t\t\t\t\t: target.classList.contains('increment')\n\t\t\t\t\t\t\t? 1\n\t\t\t\t\t\t\t: 0),\n\t\t\t\tkeydown: ({ ui, event, prev }) => {\n\t\t\t\t\tconst { key } = event as KeyboardEvent\n\t\t\t\t\tif (['ArrowUp', 'ArrowDown', '-', '+'].includes(key)) {\n\t\t\t\t\t\tevent.stopPropagation()\n\t\t\t\t\t\tevent.preventDefault()\n\t\t\t\t\t\tconst next = prev + (key === 'ArrowDown' || key === '-' ? -1 : 1)\n\t\t\t\t\t\treturn Math.min(ui.host.max, Math.max(0, next))\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t},\n\t\t),\n\t\tmax: read(ui => ui.input.max, asInteger(10)),\n\t},\n\t({ all, first }) => ({\n\t\tcontrols: all('button, input:not([disabled])'),\n\t\tincrement: first(\n\t\t\t'button.increment',\n\t\t\t'Add a native button to increment the value',\n\t\t),\n\t\tdecrement: first(\n\t\t\t'button.decrement',\n\t\t\t'Add a native button to decrement the value',\n\t\t),\n\t\tinput: first('input.value', 'Add a native input to display the value'),\n\t\tzero: first('.zero'),\n\t\tother: first('.other'),\n\t}),\n\t({ host, increment, zero }) => {\n\t\tconst nonZero = createComputed(() => host.value !== 0)\n\t\tconst incrementLabel = increment.ariaLabel || 'Increment'\n\t\tconst ariaLabel = createComputed(() =>\n\t\t\tnonZero.get() || !zero ? incrementLabel : zero.textContent,\n\t\t)\n\n\t\treturn {\n\t\t\tinput: [\n\t\t\t\tshow(nonZero),\n\t\t\t\tsetProperty('value'),\n\t\t\t\tsetProperty('max', () => String(host.max)),\n\t\t\t],\n\t\t\tdecrement: show(nonZero),\n\t\t\tincrement: [\n\t\t\t\tsetProperty('disabled', () => host.value >= host.max),\n\t\t\t\tsetProperty('ariaLabel', ariaLabel),\n\t\t\t],\n\t\t\tzero: show(() => !nonZero.get()),\n\t\t\tother: show(nonZero),\n\t\t}\n\t},\n)\n",
    "import {\n\ttype Component,\n\ttype ComponentUI,\n\tcreateSensor,\n\tdefineComponent,\n\ton,\n\tread,\n\tsetAttribute,\n\tsetProperty,\n\tsetText,\n} from '../..'\nimport { clearEffects, clearMethod } from '../_common/clear'\n\nexport type FormTextboxProps = {\n\tvalue: string\n\treadonly length: number\n\terror: string\n\tdescription: string\n\treadonly clear: () => void\n}\n\ntype FormTextboxUI = {\n\ttextbox: HTMLInputElement | HTMLTextAreaElement\n\tclear?: HTMLButtonElement\n\terror?: HTMLElement\n\tdescription?: HTMLElement\n}\n\ndeclare global {\n\tinterface HTMLElementTagNameMap {\n\t\t'form-textbox': Component<FormTextboxProps>\n\t}\n}\n\nexport default defineComponent<FormTextboxProps, FormTextboxUI>(\n\t'form-textbox',\n\t{\n\t\tvalue: read(ui => ui.textbox.value, ''),\n\t\tlength: createSensor(\n\t\t\tread(ui => ui.textbox.value.length, 0),\n\t\t\t'textbox',\n\t\t\t{\n\t\t\t\tinput: ({ target }) => target.value.length,\n\t\t\t},\n\t\t),\n\t\terror: '',\n\t\tdescription: ({\n\t\t\thost,\n\t\t\tdescription,\n\t\t\ttextbox,\n\t\t}: ComponentUI<FormTextboxProps, FormTextboxUI>) => {\n\t\t\tif (description) {\n\t\t\t\tif (textbox && textbox.maxLength && description.dataset.remaining) {\n\t\t\t\t\treturn () =>\n\t\t\t\t\t\tdescription.dataset.remaining!.replace(\n\t\t\t\t\t\t\t'${n}',\n\t\t\t\t\t\t\tString(textbox.maxLength - host.length),\n\t\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t\treturn description.textContent?.trim() ?? ''\n\t\t\t} else {\n\t\t\t\treturn ''\n\t\t\t}\n\t\t},\n\t\tclear: clearMethod,\n\t},\n\t({ first }) => ({\n\t\ttextbox: first(\n\t\t\t'input, textarea',\n\t\t\t'Add a native input or textarea as descendant element.',\n\t\t),\n\t\tclear: first('button.clear'),\n\t\terror: first('.error'),\n\t\tdescription: first('.description'),\n\t}),\n\tui => {\n\t\tconst { host, textbox, error, description } = ui\n\t\tconst errorId = error?.id\n\t\tconst descriptionId = description?.id\n\n\t\treturn {\n\t\t\ttextbox: [\n\t\t\t\ton('change', () => {\n\t\t\t\t\ttextbox.checkValidity()\n\t\t\t\t\treturn {\n\t\t\t\t\t\tvalue: textbox.value,\n\t\t\t\t\t\terror: textbox.validationMessage,\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t\tsetProperty('value'),\n\t\t\t\tsetProperty('ariaInvalid', () => String(!!host.error)),\n\t\t\t\tsetAttribute('aria-errormessage', () =>\n\t\t\t\t\thost.error && errorId ? errorId : null,\n\t\t\t\t),\n\t\t\t\tsetAttribute('aria-describedby', () =>\n\t\t\t\t\tdescription && descriptionId ? descriptionId : null,\n\t\t\t\t),\n\t\t\t],\n\t\t\tclear: clearEffects(ui),\n\t\t\terror: setText('error'),\n\t\t\tdescription: setText('description'),\n\t\t}\n\t},\n)\n",
    "import {\n\tasInteger,\n\ttype Collection,\n\ttype Component,\n\tcreateEffect,\n\tdefineComponent,\n\ton,\n\tsetProperty,\n} from '../..'\n\nexport type ModuleCarouselProps = {\n\tindex: number\n}\n\ntype ModuleCarouselUI = {\n\tdots: Collection<HTMLElement>\n\tslides: Collection<HTMLElement>\n\tbuttons: Collection<HTMLElement>\n}\n\ndeclare global {\n\tinterface HTMLElementTagNameMap {\n\t\t'module-carousel': Component<ModuleCarouselProps>\n\t}\n}\n\nconst wrapAround = (index: number, total: number) => (index + total) % total\n\nexport default defineComponent<ModuleCarouselProps, ModuleCarouselUI>(\n\t'module-carousel',\n\t{\n\t\tindex: asInteger(ui =>\n\t\t\tMath.max(\n\t\t\t\tui.slides.get().findIndex(slide => slide.ariaCurrent === 'true'),\n\t\t\t\t0,\n\t\t\t),\n\t\t),\n\t},\n\t({ all }) => ({\n\t\tdots: all('[role=\"tab\"]'),\n\t\tslides: all('[role=\"tabpanel\"]'),\n\t\tbuttons: all('nav button'),\n\t}),\n\t({ host, slides }) => {\n\t\tlet isNavigating = false\n\t\tlet isScrolling = false\n\n\t\tconst scrollToSlide = (index: number) => {\n\t\t\tconst slide = slides[index]\n\t\t\tif (!slide) return\n\n\t\t\tisNavigating = true\n\t\t\tslide.scrollIntoView({\n\t\t\t\tbehavior: 'smooth',\n\t\t\t\tblock: 'nearest',\n\t\t\t})\n\t\t}\n\n\t\tconst isCurrentDot = (target: HTMLElement) =>\n\t\t\ttarget.dataset.index === String(host.index)\n\n\t\treturn {\n\t\t\thost: [\n\t\t\t\t() => {\n\t\t\t\t\tconst config = {\n\t\t\t\t\t\troot: host,\n\t\t\t\t\t\tthreshold: 0.5,\n\t\t\t\t\t}\n\t\t\t\t\tconst observer = new IntersectionObserver(entries => {\n\t\t\t\t\t\tfor (const entry of entries) {\n\t\t\t\t\t\t\tif (entry.intersectionRatio > config.threshold) {\n\t\t\t\t\t\t\t\tconst slideIndex = slides\n\t\t\t\t\t\t\t\t\t.get()\n\t\t\t\t\t\t\t\t\t.findIndex(slide => slide === entry.target)\n\n\t\t\t\t\t\t\t\tif (isNavigating) {\n\t\t\t\t\t\t\t\t\tif (slideIndex === host.index) isNavigating = false\n\t\t\t\t\t\t\t\t} else if (slideIndex !== host.index && slideIndex >= 0) {\n\t\t\t\t\t\t\t\t\tisScrolling = true\n\t\t\t\t\t\t\t\t\thost.index = slideIndex\n\t\t\t\t\t\t\t\t\tisScrolling = false\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}, config)\n\n\t\t\t\t\tfor (const slide of slides) observer.observe(slide)\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tobserver.disconnect()\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t() => {\n\t\t\t\t\tlet prevIndex = host.index\n\t\t\t\t\treturn createEffect(() => {\n\t\t\t\t\t\tif (prevIndex === host.index) return\n\t\t\t\t\t\tconst newIndex = host.index\n\t\t\t\t\t\tprevIndex = newIndex\n\n\t\t\t\t\t\t// Only scroll if this change wasn't from user scroll\n\t\t\t\t\t\tif (!isScrolling) {\n\t\t\t\t\t\t\tscrollToSlide(newIndex)\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t},\n\t\t\t],\n\n\t\t\t// Handle navigation button click and keyup events\n\t\t\tbuttons: [\n\t\t\t\ton('click', ({ target }) => {\n\t\t\t\t\tif (!(target instanceof HTMLElement)) return\n\t\t\t\t\tconst total = slides.length\n\t\t\t\t\tconst nextIndex = target.classList.contains('prev')\n\t\t\t\t\t\t? host.index - 1\n\t\t\t\t\t\t: target.classList.contains('next')\n\t\t\t\t\t\t\t? host.index + 1\n\t\t\t\t\t\t\t: parseInt(target.dataset.index || '0')\n\t\t\t\t\thost.index = Number.isInteger(nextIndex)\n\t\t\t\t\t\t? wrapAround(nextIndex, total)\n\t\t\t\t\t\t: 0\n\t\t\t\t}),\n\t\t\t\ton('keyup', e => {\n\t\t\t\t\tconst { key } = e\n\t\t\t\t\tif (['ArrowLeft', 'ArrowRight', 'Home', 'End'].includes(key)) {\n\t\t\t\t\t\te.preventDefault()\n\t\t\t\t\t\te.stopPropagation()\n\t\t\t\t\t\tconst total = slides.length\n\t\t\t\t\t\tconst nextIndex =\n\t\t\t\t\t\t\tkey === 'Home'\n\t\t\t\t\t\t\t\t? 0\n\t\t\t\t\t\t\t\t: key === 'End'\n\t\t\t\t\t\t\t\t\t? total - 1\n\t\t\t\t\t\t\t\t\t: wrapAround(\n\t\t\t\t\t\t\t\t\t\t\thost.index + (key === 'ArrowLeft' ? -1 : 1),\n\t\t\t\t\t\t\t\t\t\t\ttotal,\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\thost.index = nextIndex\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t],\n\n\t\t\t// Set the active slide in the navigation\n\t\t\tdots: [\n\t\t\t\tsetProperty('ariaSelected', target => String(isCurrentDot(target))),\n\t\t\t\tsetProperty('tabIndex', target => (isCurrentDot(target) ? 0 : -1)),\n\t\t\t],\n\n\t\t\t// Set the active slide in the slides\n\t\t\tslides: setProperty('ariaCurrent', target =>\n\t\t\t\tString(target.id === slides[host.index].id),\n\t\t\t),\n\t\t}\n\t},\n)\n",
    "import {\n\ttype Collection,\n\ttype Component,\n\tcreateComputed,\n\tdefineComponent,\n\tpass,\n} from '../..'\nimport { BasicButtonProps } from '../basic-button/basic-button'\nimport { FormSpinbuttonProps } from '../form-spinbutton/form-spinbutton'\n\ntype ModuleCatalogUI = {\n\tbutton: Component<BasicButtonProps>\n\tspinbuttons: Collection<Component<FormSpinbuttonProps>>\n}\n\nexport default defineComponent<{}, ModuleCatalogUI>(\n\t'module-catalog',\n\t{},\n\t({ all, first }) => ({\n\t\tbutton: first('basic-button', 'Add a button to go go the Shopping Cart'),\n\t\tspinbuttons: all(\n\t\t\t'form-spinbutton',\n\t\t\t'Add spinbutton components to calculate sum from.',\n\t\t),\n\t}),\n\t({ spinbuttons }) => {\n\t\tconst total = createComputed(() =>\n\t\t\tspinbuttons.get().reduce((sum, item) => sum + item.value, 0),\n\t\t)\n\t\treturn {\n\t\t\tbutton: pass({\n\t\t\t\tdisabled: () => !total.get(),\n\t\t\t\tbadge: () => (total.get() > 0 ? String(total.get()) : ''),\n\t\t\t}),\n\t\t}\n\t},\n)\n",
    "import { type Component, type ComponentProps, type Effect, on } from '../..'\n\nimport type { BasicButtonProps } from './basic-button'\n\ntype CopyStatus = 'success' | 'error'\n\nconst COPY_SUCCESS = 'success'\nconst COPY_ERROR = 'error'\n\nexport const copyToClipboard =\n\t(\n\t\tcontainer: HTMLElement,\n\t\tmessages: { [COPY_ERROR]?: string; [COPY_SUCCESS]?: string },\n\t): Effect<ComponentProps, Component<BasicButtonProps>> =>\n\t(_, button) =>\n\t\ton('click', async () => {\n\t\t\tconst label = button.label\n\t\t\tlet status: CopyStatus = COPY_SUCCESS\n\t\t\ttry {\n\t\t\t\tawait navigator.clipboard.writeText(container.textContent?.trim() ?? '')\n\t\t\t} catch (err) {\n\t\t\t\tconsole.error(\n\t\t\t\t\t'Error while trying to use navigator.clipboard.writeText()',\n\t\t\t\t\terr,\n\t\t\t\t)\n\t\t\t\tstatus = COPY_ERROR\n\t\t\t}\n\t\t\tbutton.disabled = true\n\t\t\tbutton.label = messages[status] ?? label\n\t\t\tsetTimeout(\n\t\t\t\t() => {\n\t\t\t\t\tbutton.disabled = false\n\t\t\t\t\tbutton.label = label\n\t\t\t\t},\n\t\t\t\tstatus === COPY_SUCCESS ? 1000 : 3000,\n\t\t\t)\n\t\t})(_, button)\n",
    "import {\n\tasBoolean,\n\ttype Component,\n\tdefineComponent,\n\ton,\n\ttoggleAttribute,\n} from '../..'\nimport type { BasicButtonProps } from '../basic-button/basic-button'\nimport { copyToClipboard } from '../basic-button/copyToClipboard'\n\nexport type ModuleCodeblockProps = {\n\tcollapsed: boolean\n}\n\ntype ModuleCodeblockUI = {\n\tcode: HTMLElement\n\toverlay?: HTMLButtonElement\n\tcopy?: Component<BasicButtonProps>\n}\n\ndeclare global {\n\tinterface HTMLElementTagNameMap {\n\t\t'module-codeblock': Component<ModuleCodeblockProps>\n\t}\n}\n\nexport default defineComponent<ModuleCodeblockProps, ModuleCodeblockUI>(\n\t'module-codeblock',\n\t{ collapsed: asBoolean() },\n\t({ first }) => ({\n\t\tcode: first('code', 'Needed as source container to copy from.'),\n\t\toverlay: first('button.overlay'),\n\t\tcopy: first('basic-button.copy'),\n\t}),\n\t({ host, code, copy }) => ({\n\t\thost: toggleAttribute('collapsed'),\n\t\toverlay: on('click', () => {\n\t\t\thost.collapsed = false\n\t\t}),\n\t\tcopy: copyToClipboard(code, {\n\t\t\tsuccess: copy?.getAttribute('copy-success') || 'Copied!',\n\t\t\terror:\n\t\t\t\tcopy?.getAttribute('copy-error') ||\n\t\t\t\t'Error trying to copy to clipboard!',\n\t\t}),\n\t}),\n)\n",
    "import { type Component, createEffect, defineComponent, on } from '../..'\n\nexport type ModuleDialogProps = {\n\topen: boolean\n}\n\ntype ModuleDialogUI = {\n\topenButton: HTMLButtonElement\n\tdialog: HTMLDialogElement\n\tcloseButton: HTMLButtonElement\n}\n\ndeclare global {\n\tinterface HTMLElementTagNameMap {\n\t\t'module-dialog': Component<ModuleDialogProps>\n\t}\n}\n\nconst SCROLL_LOCK_CLASS = 'scroll-lock'\n\nexport default defineComponent<ModuleDialogProps, ModuleDialogUI>(\n\t'module-dialog',\n\t{\n\t\topen: false,\n\t},\n\t({ first }) => ({\n\t\topenButton: first(\n\t\t\t'button[aria-haspopup=\"dialog\"]',\n\t\t\t'Add a button to open the dialog.',\n\t\t),\n\t\tdialog: first('dialog', 'Add a native dialog element.'),\n\t\tcloseButton: first(\n\t\t\t'dialog button.close',\n\t\t\t'Add a close button in the dialog.',\n\t\t),\n\t}),\n\t({ host, dialog }) => {\n\t\tlet scrollTop = 0\n\t\tlet activeElement: HTMLElement | null = null\n\n\t\treturn {\n\t\t\thost: () =>\n\t\t\t\tcreateEffect(() => {\n\t\t\t\t\tif (host.open) {\n\t\t\t\t\t\tscrollTop = document.documentElement.scrollTop\n\t\t\t\t\t\tactiveElement = document.activeElement as HTMLElement | null\n\t\t\t\t\t\tdialog.showModal()\n\t\t\t\t\t\tdocument.body.classList.add(SCROLL_LOCK_CLASS)\n\t\t\t\t\t\tdocument.body.style.setProperty('top', `-${scrollTop}px`)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdocument.body.classList.remove(SCROLL_LOCK_CLASS)\n\t\t\t\t\t\twindow.scrollTo({\n\t\t\t\t\t\t\ttop: scrollTop,\n\t\t\t\t\t\t\tleft: 0,\n\t\t\t\t\t\t\tbehavior: 'instant',\n\t\t\t\t\t\t})\n\t\t\t\t\t\tdocument.body.style.removeProperty('top')\n\t\t\t\t\t\tdialog.close()\n\t\t\t\t\t\tif (activeElement) activeElement.focus()\n\t\t\t\t\t}\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\thost.open = false\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\topenButton: on('click', () => {\n\t\t\t\thost.open = true\n\t\t\t}),\n\t\t\tdialog: [\n\t\t\t\ton('click', ({ target }) => {\n\t\t\t\t\tif (target === dialog) host.open = false\n\t\t\t\t}),\n\t\t\t\ton('keydown', ({ key }) => {\n\t\t\t\t\tif (key === 'Escape') host.open = false\n\t\t\t\t}),\n\t\t\t],\n\t\t\tcloseButton: on('click', () => {\n\t\t\t\thost.open = false\n\t\t\t}),\n\t\t}\n\t},\n)\n",
    "import {\n\tasString,\n\ttype Component,\n\tcreateComputed,\n\tdangerouslySetInnerHTML,\n\tdefineComponent,\n\tsetText,\n\tshow,\n\ttoggleClass,\n} from '../..'\nimport { fetchWithCache, isRecursiveURL, isValidURL } from '../_common/fetch'\n\nexport type ModuleLazyloadProps = {\n\tsrc: string\n}\n\ntype ModuleLazyloadUI = Record<\n\t'callout' | 'loading' | 'error' | 'content',\n\tHTMLElement\n>\n\ndeclare global {\n\tinterface HTMLElementTagNameMap {\n\t\t'module-lazyload': Component<ModuleLazyloadProps>\n\t}\n}\n\nexport default defineComponent<ModuleLazyloadProps, ModuleLazyloadUI>(\n\t'module-lazyload',\n\t{\n\t\tsrc: asString(),\n\t},\n\t({ first }) => ({\n\t\tcallout: first(\n\t\t\t'card-callout',\n\t\t\t'Needed to display loading state and error messages.',\n\t\t),\n\t\tloading: first('.loading', 'Needed to display loading state.'),\n\t\terror: first('.error', 'Needed to display error messages.'),\n\t\tcontent: first('.content', 'Needed to display content.'),\n\t}),\n\tui => {\n\t\tconst { host } = ui\n\t\tconst result = createComputed<{\n\t\t\tok: boolean\n\t\t\tvalue: string\n\t\t\terror: string\n\t\t\tpending: boolean\n\t\t}>(\n\t\t\tasync (_prev, abort) => {\n\t\t\t\tconst url = host.src\n\t\t\t\tconst error = !url\n\t\t\t\t\t? 'No URL provided'\n\t\t\t\t\t: !isValidURL(url)\n\t\t\t\t\t\t? 'Invalid URL'\n\t\t\t\t\t\t: isRecursiveURL(url, host)\n\t\t\t\t\t\t\t? 'Recursive URL detected'\n\t\t\t\t\t\t\t: ''\n\t\t\t\tif (error) return { ok: false, value: '', error, pending: false }\n\n\t\t\t\ttry {\n\t\t\t\t\tconst { content } = await fetchWithCache(url, abort)\n\t\t\t\t\treturn { ok: true, value: content, error: '', pending: false }\n\t\t\t\t} catch (error) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tok: false,\n\t\t\t\t\t\tvalue: '',\n\t\t\t\t\t\terror: `Failed to fetch content for \"${url}\": ${String(error)}`,\n\t\t\t\t\t\tpending: false,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t{ ok: false, value: '', error: '', pending: true },\n\t\t)\n\t\tconst hasError = () => !!result.get().error\n\n\t\treturn {\n\t\t\tcallout: [show(() => !result.get().ok), toggleClass('danger', hasError)],\n\t\t\tloading: show(() => !!result.get().pending),\n\t\t\terror: [show(hasError), setText(() => result.get().error ?? '')],\n\t\t\tcontent: [\n\t\t\t\tshow(() => result.get().ok),\n\t\t\t\tdangerouslySetInnerHTML(() => result.get().value ?? '', {\n\t\t\t\t\tallowScripts: host.hasAttribute('allow-scripts'),\n\t\t\t\t}),\n\t\t\t],\n\t\t}\n\t},\n)\n",
    "import {\n\tasInteger,\n\ttype Component,\n\tdefineComponent,\n\tMissingElementError,\n\ton,\n\tpass,\n} from '../..'\nimport { BasicButtonProps } from '../basic-button/basic-button'\nimport { FormTextboxProps } from '../form-textbox/form-textbox'\n\nexport type ModuleListProps = {\n\tadd: (process?: (item: HTMLElement) => void) => void\n\tdelete: (key: string) => void\n}\n\ntype ModuleListUI = {\n\tcontainer: HTMLElement\n\ttemplate: HTMLTemplateElement\n\tform?: HTMLFormElement\n\ttextbox?: Component<FormTextboxProps>\n\tadd?: Component<BasicButtonProps>\n}\n\ndeclare global {\n\tinterface HTMLElementTagNameMap {\n\t\t'module-list': Component<ModuleListProps>\n\t}\n}\n\nconst MAX_ITEMS = 1000\n\nexport default defineComponent<ModuleListProps, ModuleListUI>(\n\t'module-list',\n\t{\n\t\tadd: ({ host, container, template }) => {\n\t\t\tlet key = 0\n\t\t\thost.add = (process?: (item: HTMLElement) => void) => {\n\t\t\t\tconst item = (template.content.cloneNode(true) as DocumentFragment)\n\t\t\t\t\t.firstElementChild\n\t\t\t\tif (item && item instanceof HTMLElement) {\n\t\t\t\t\titem.dataset.key = String(key++)\n\t\t\t\t\tif (process) process(item)\n\t\t\t\t\tcontainer.append(item)\n\t\t\t\t} else {\n\t\t\t\t\tthrow new MissingElementError(\n\t\t\t\t\t\thost,\n\t\t\t\t\t\t'*',\n\t\t\t\t\t\t'Template does not contain an item element.',\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tdelete: ({ host, container }) => {\n\t\t\thost.delete = (key: string) => {\n\t\t\t\tconst item = container.querySelector(`[data-key=\"${key}\"]`)\n\t\t\t\tif (item) item.remove()\n\t\t\t}\n\t\t},\n\t},\n\t({ first }) => ({\n\t\tcontainer: first('[data-container]', 'Add a container element for items.'),\n\t\ttemplate: first('template', 'Add a template element for items.'),\n\t\tform: first('form'),\n\t\ttextbox: first('form-textbox'),\n\t\tadd: first('basic-button.add'),\n\t}),\n\tui => {\n\t\tconst { host, container, textbox } = ui\n\t\tconst max = asInteger(MAX_ITEMS)(ui, host.getAttribute('max'))\n\n\t\treturn {\n\t\t\tform: on('submit', e => {\n\t\t\t\te.preventDefault()\n\t\t\t\tconst content = textbox?.value\n\t\t\t\tif (content) {\n\t\t\t\t\thost.add(item => {\n\t\t\t\t\t\titem.querySelector('slot')?.replaceWith(content)\n\t\t\t\t\t})\n\t\t\t\t\ttextbox.clear()\n\t\t\t\t}\n\t\t\t}),\n\t\t\tadd: pass({\n\t\t\t\tdisabled: () =>\n\t\t\t\t\t(textbox && !textbox.length) || container.children.length >= max,\n\t\t\t}),\n\t\t\thost: on('click', e => {\n\t\t\t\tconst { target } = e\n\t\t\t\tif (\n\t\t\t\t\ttarget instanceof HTMLElement &&\n\t\t\t\t\ttarget.closest('basic-button.delete')\n\t\t\t\t) {\n\t\t\t\t\te.stopPropagation()\n\t\t\t\t\ttarget.closest('[data-key]')?.remove()\n\t\t\t\t}\n\t\t\t}),\n\t\t}\n\t},\n)\n",
    "import {\n\tasInteger,\n\ttype Component,\n\tdefineComponent,\n\ton,\n\tread,\n\tsetAttribute,\n\tsetProperty,\n\tsetText,\n\tshow,\n} from '../..'\n\nexport type ModulePaginationProps = {\n\tvalue: number\n\tmax: number\n}\n\ntype ModulePaginationUI = {\n\tinput: HTMLInputElement\n\tprev: HTMLButtonElement\n\tnext: HTMLButtonElement\n\tvalue?: HTMLElement\n\tmax?: HTMLElement\n}\n\ndeclare global {\n\tinterface HTMLElementTagNameMap {\n\t\t'module-pagination': Component<ModulePaginationProps>\n\t}\n}\n\nexport default defineComponent<ModulePaginationProps, ModulePaginationUI>(\n\t'module-pagination',\n\t{\n\t\tvalue: read(ui => ui.input.value, asInteger(1)),\n\t\tmax: read(ui => ui.input.max, asInteger(1)),\n\t},\n\t({ first }) => ({\n\t\tinput: first(\n\t\t\t'input',\n\t\t\t'Add an <input[type=\"number\"]> to enter the page number to go to.',\n\t\t),\n\t\tprev: first(\n\t\t\t'button.prev',\n\t\t\t'Add a <button.prev> to go to the previous page.',\n\t\t),\n\t\tnext: first('button.next', 'Add a <button.next> to go to the next page.'),\n\t\tvalue: first('.value'),\n\t\tmax: first('.max'),\n\t}),\n\t({ host, input }) => ({\n\t\thost: [\n\t\t\tshow(() => host.max > 1),\n\t\t\tsetAttribute('value', () => String(host.value)),\n\t\t\tsetAttribute('max', () => String(host.max)),\n\t\t\ton('keyup', ({ target, key }) => {\n\t\t\t\tif (target instanceof HTMLInputElement) return\n\t\t\t\tif ((key === 'ArrowLeft' || key === '-') && host.value > 1) host.value--\n\t\t\t\telse if ((key === 'ArrowRight' || key === '+') && host.value < host.max)\n\t\t\t\t\thost.value++\n\t\t\t}),\n\t\t],\n\t\tinput: [\n\t\t\ton('change', () => {\n\t\t\t\tconst numValue = input.valueAsNumber\n\t\t\t\thost.value = Number.isNaN(numValue)\n\t\t\t\t\t? 1\n\t\t\t\t\t: Math.max(1, Math.min(numValue, host.max))\n\t\t\t}),\n\t\t\tsetProperty('value', () => String(host.value)),\n\t\t\tsetProperty('max', () => String(host.max)),\n\t\t],\n\t\tprev: [\n\t\t\ton('click', () => {\n\t\t\t\thost.value--\n\t\t\t}),\n\t\t\tsetProperty('disabled', () => host.value <= 1),\n\t\t],\n\t\tnext: [\n\t\t\ton('click', () => {\n\t\t\t\thost.value++\n\t\t\t}),\n\t\t\tsetProperty('disabled', () => host.value >= host.max),\n\t\t],\n\t\tvalue: setText(() => String(host.value)),\n\t\tmax: setText(() => String(host.max)),\n\t}),\n)\n",
    "import { batch, createState, defineComponent, on, toggleClass } from '../..'\n\nconst MIN_INTERSECTION_RATIO = 0\nconst MAX_INTERSECTION_RATIO = 0.99 // ignore rounding errors of fraction pixels\n\nconst observeOverflow =\n\t(\n\t\tcontent: Element,\n\t\toverflowCallback: () => void,\n\t\tnoOverflowCallback: () => void,\n\t) =>\n\t(container: HTMLElement) => {\n\t\tconst observer = new IntersectionObserver(\n\t\t\t([entry]) => {\n\t\t\t\tif (\n\t\t\t\t\tentry.intersectionRatio > MIN_INTERSECTION_RATIO &&\n\t\t\t\t\tentry.intersectionRatio < MAX_INTERSECTION_RATIO\n\t\t\t\t)\n\t\t\t\t\toverflowCallback()\n\t\t\t\telse batch(noOverflowCallback)\n\t\t\t},\n\t\t\t{\n\t\t\t\troot: container,\n\t\t\t\tthreshold: [MIN_INTERSECTION_RATIO, MAX_INTERSECTION_RATIO],\n\t\t\t},\n\t\t)\n\t\tobserver.observe(content)\n\t\treturn () => {\n\t\t\tobserver.disconnect()\n\t\t}\n\t}\n\nexport default defineComponent(\n\t'module-scrollarea',\n\tundefined,\n\tundefined,\n\t({ host }) => {\n\t\tconst child = host.firstElementChild\n\t\tif (!child) return {}\n\n\t\tconst overflowStart = createState(false)\n\t\tconst overflowEnd = createState(false)\n\t\tconst hasOverflow = () => overflowStart.get() || overflowEnd.get()\n\n\t\tconst scrollCallback =\n\t\t\thost.getAttribute('orientation') === 'horizontal'\n\t\t\t\t? () => {\n\t\t\t\t\t\toverflowStart.set(host.scrollLeft > 0)\n\t\t\t\t\t\toverflowEnd.set(\n\t\t\t\t\t\t\thost.scrollLeft < host.scrollWidth - host.offsetWidth,\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t: () => {\n\t\t\t\t\t\toverflowStart.set(host.scrollTop > 0)\n\t\t\t\t\t\toverflowEnd.set(\n\t\t\t\t\t\t\thost.scrollTop < host.scrollHeight - host.offsetHeight,\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\n\t\treturn {\n\t\t\thost: [\n\t\t\t\ttoggleClass('overflow', hasOverflow),\n\t\t\t\ttoggleClass('overflow-start', overflowStart),\n\t\t\t\ttoggleClass('overflow-end', overflowEnd),\n\t\t\t\tobserveOverflow(\n\t\t\t\t\tchild,\n\t\t\t\t\t() => {\n\t\t\t\t\t\toverflowEnd.set(true)\n\t\t\t\t\t},\n\t\t\t\t\t() => {\n\t\t\t\t\t\toverflowStart.set(false)\n\t\t\t\t\t\toverflowEnd.set(false)\n\t\t\t\t\t},\n\t\t\t\t),\n\t\t\t\ton('scroll', () => {\n\t\t\t\t\tif (hasOverflow()) batch(scrollCallback)\n\t\t\t\t}),\n\t\t\t],\n\t\t}\n\t},\n)\n",
    "import {\n\ttype Collection,\n\ttype Component,\n\tcreateSensor,\n\tdefineComponent,\n\tread,\n\tsetProperty,\n\tshow,\n} from '../..'\n\nexport type ModuleTabgroupProps = {\n\treadonly selected: string\n}\n\ntype ModuleTabgroupUI = {\n\ttabs: Collection<HTMLButtonElement>\n\tpanels: Collection<HTMLElement>\n}\n\ndeclare global {\n\tinterface HTMLElementTagNameMap {\n\t\t'module-tabgroup': Component<ModuleTabgroupProps>\n\t}\n}\n\nconst getAriaControls = (element: HTMLElement) =>\n\telement.getAttribute('aria-controls') ?? ''\n\nconst getSelected = (\n\telements: Collection<HTMLElement>,\n\tisCurrent: (element: HTMLElement) => boolean,\n\toffset = 0,\n) => {\n\tconst tabs = elements.get()\n\tconst currentIndex = tabs.findIndex(isCurrent)\n\tconst newIndex = (currentIndex + offset + tabs.length) % tabs.length\n\treturn getAriaControls(tabs[newIndex])\n}\n\nexport default defineComponent<ModuleTabgroupProps, ModuleTabgroupUI>(\n\t'module-tabgroup',\n\t{\n\t\tselected: createSensor(\n\t\t\tread(ui => getSelected(ui.tabs, tab => tab.ariaSelected === 'true'), ''),\n\t\t\t'tabs',\n\t\t\t{\n\t\t\t\tclick: ({ target }) => getAriaControls(target),\n\t\t\t\tkeyup: ({ event, ui, target }) => {\n\t\t\t\t\tconst key = event.key\n\t\t\t\t\tif (\n\t\t\t\t\t\t[\n\t\t\t\t\t\t\t'ArrowLeft',\n\t\t\t\t\t\t\t'ArrowRight',\n\t\t\t\t\t\t\t'ArrowUp',\n\t\t\t\t\t\t\t'ArrowDown',\n\t\t\t\t\t\t\t'Home',\n\t\t\t\t\t\t\t'End',\n\t\t\t\t\t\t].includes(key)\n\t\t\t\t\t) {\n\t\t\t\t\t\tevent.preventDefault()\n\t\t\t\t\t\tevent.stopPropagation()\n\t\t\t\t\t\tconst tabs = ui.tabs.get()\n\t\t\t\t\t\tconst next =\n\t\t\t\t\t\t\tkey === 'Home'\n\t\t\t\t\t\t\t\t? getAriaControls(tabs[0])\n\t\t\t\t\t\t\t\t: key === 'End'\n\t\t\t\t\t\t\t\t\t? getAriaControls(tabs[tabs.length - 1])\n\t\t\t\t\t\t\t\t\t: getSelected(\n\t\t\t\t\t\t\t\t\t\t\tui.tabs,\n\t\t\t\t\t\t\t\t\t\t\ttab => tab === target,\n\t\t\t\t\t\t\t\t\t\t\tkey === 'ArrowLeft' || key === 'ArrowUp' ? -1 : 1,\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\ttabs.filter(tab => getAriaControls(tab) === next)[0].focus()\n\t\t\t\t\t\treturn next\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t},\n\t\t),\n\t},\n\t({ all }) => ({\n\t\ttabs: all(\n\t\t\t'button[role=\"tab\"]',\n\t\t\t'At least 2 tabs as children of a <[role=\"tablist\"]> element are needed. Each tab must reference a unique id of a <[role=\"tabpanel\"]> element.',\n\t\t),\n\t\tpanels: all(\n\t\t\t'[role=\"tabpanel\"]',\n\t\t\t'At least 2 tabpanels are needed. Each tabpanel must have a unique id.',\n\t\t),\n\t}),\n\t({ host }) => {\n\t\tconst isCurrentTab = (tab: HTMLButtonElement) =>\n\t\t\thost.selected === getAriaControls(tab)\n\n\t\treturn {\n\t\t\ttabs: [\n\t\t\t\tsetProperty('ariaSelected', target => String(isCurrentTab(target))),\n\t\t\t\tsetProperty('tabIndex', target => (isCurrentTab(target) ? 0 : -1)),\n\t\t\t],\n\t\t\tpanels: show(target => host.selected === target.id),\n\t\t}\n\t},\n)\n",
    "import {\n\ttype Component,\n\tcreateCollection,\n\tdefineComponent,\n\ton,\n\tpass,\n\tsetAttribute,\n} from '../..'\nimport { BasicButtonProps } from '../basic-button/basic-button'\nimport { BasicPluralizeProps } from '../basic-pluralize/basic-pluralize'\nimport { FormRadiogroupProps } from '../form-radiogroup/form-radiogroup'\nimport { FormTextboxProps } from '../form-textbox/form-textbox'\nimport { ModuleListProps } from '../module-list/module-list'\n\ntype ModuleTodoUI = {\n\tform: HTMLFormElement\n\ttextbox: Component<FormTextboxProps>\n\tsubmit: Component<BasicButtonProps>\n\tlist: Component<ModuleListProps>\n\tcount: Component<BasicPluralizeProps>\n\tfilter: Component<FormRadiogroupProps>\n\tclearCompleted: Component<BasicButtonProps>\n}\n\ndeclare global {\n\tinterface HTMLElementTagNameMap {\n\t\t'module-todo': Component<{}>\n\t}\n}\n\nexport default defineComponent<{}, ModuleTodoUI>(\n\t'module-todo',\n\t{},\n\t({ first }) => ({\n\t\tform: first('form', 'Add a form element to enter a new todo item.'),\n\t\ttextbox: first(\n\t\t\t'form-textbox',\n\t\t\t'Add <form-textbox> component to enter a new todo item.',\n\t\t),\n\t\tsubmit: first(\n\t\t\t'basic-button.submit',\n\t\t\t'Add <basic-button.submit> component to submit the form.',\n\t\t),\n\t\tlist: first(\n\t\t\t'module-list',\n\t\t\t'Add <module-list> component to display a list of todo items.',\n\t\t),\n\t\tcount: first(\n\t\t\t'basic-pluralize',\n\t\t\t'Add <basic-pluralize> component to display the number of todo items.',\n\t\t),\n\t\tfilter: first(\n\t\t\t'form-radiogroup',\n\t\t\t'Add <form-radiogroup> component to filter todo items.',\n\t\t),\n\t\tclearCompleted: first(\n\t\t\t'basic-button.clear-completed',\n\t\t\t'Add <basic-button.clear-completed> component to clear completed todo items.',\n\t\t),\n\t}),\n\t({ textbox, list, filter }) => {\n\t\tconst active = createCollection(list, 'form-checkbox:not([checked])')\n\t\tconst completed = createCollection(list, 'form-checkbox[checked]')\n\n\t\treturn {\n\t\t\tform: on('submit', e => {\n\t\t\t\te.preventDefault()\n\t\t\t\tconst value = textbox.value.trim()\n\t\t\t\tif (!value) return\n\t\t\t\tlist.add(item => {\n\t\t\t\t\titem.querySelector('slot')?.replaceWith(value)\n\t\t\t\t})\n\t\t\t\ttextbox.clear()\n\t\t\t}),\n\t\t\tsubmit: pass({ disabled: () => !textbox.length }),\n\t\t\tlist: setAttribute('filter', () => filter?.value || 'all'),\n\t\t\tcount: pass({ count: () => active.length }),\n\t\t\tclearCompleted: [\n\t\t\t\tpass({\n\t\t\t\t\tdisabled: () => !completed.length,\n\t\t\t\t\tbadge: () => (completed.length ? String(completed.length) : ''),\n\t\t\t\t}),\n\t\t\t\ton('click', () => {\n\t\t\t\t\tconst items = completed.get()\n\t\t\t\t\tfor (let i = items.length - 1; i >= 0; i--)\n\t\t\t\t\t\titems[i].closest('li')?.remove()\n\t\t\t\t}),\n\t\t\t],\n\t\t}\n\t},\n)\n"
  ],
  "mappings": "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",
  "debugId": "838AF33205D1F0AE64756E2164756E21",
  "names": []
}