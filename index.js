function P($){return typeof $==="function"}function t($){return P($)&&$.constructor.name==="AsyncFunction"}function P$($){return P($)&&$.constructor.name!=="AsyncFunction"}function S($,Z){return Object.prototype.toString.call($)===`[object ${Z}]`}function L($){return S($,"Object")}function BZ($,Z=(J)=>J!=null){return Array.isArray($)&&$.every(Z)}function a($){return typeof $==="string"?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($)}class U$ extends Error{constructor($){super(`[${$}] Circular dependency detected`);this.name="CircularDependencyError"}}class g$ extends TypeError{constructor($){super(`[${$}] Signal value cannot be null or undefined`);this.name="NullishSignalValueError"}}class e extends Error{constructor($){super(`[${$}] Signal value is unset`);this.name="UnsetSignalValueError"}}class M$ extends TypeError{constructor($,Z){super(`[${$}] Signal value ${a(Z)} is invalid`);this.name="InvalidSignalValueError"}}class p$ extends TypeError{constructor($,Z){super(`[${$}] Callback ${a(Z)} is invalid`);this.name="InvalidCallbackError"}}class S$ extends Error{constructor($){super(`[${$}] Signal is read-only`);this.name="ReadonlySignalError"}}class T$ extends Error{constructor($){super(`[${$}] Active owner is required`);this.name="RequiredOwnerError"}}class V$ extends Error{constructor($,Z,J){super(`[${$}] Could not add key "${Z}"${J?` with value ${JSON.stringify(J)}`:""} because it already exists`);this.name="DuplicateKeyError"}}function x($,Z,J){if(Z==null)throw new g$($);if(J&&!J(Z))throw new M$($,Z)}function x$($,Z){if(Z==null)throw new e($)}function g($,Z,J=P){if(!J(Z))throw new p$($,Z)}var $$="State",Z$="Memo",J$="Task",X$="Sensor",p="List",j$="Collection",Q$="Store",W$="Slot",v=0,G$=1,F=2,b$=4,y=8,Y=null,h=null,v$=[],A=0,zZ=!1,l=($,Z)=>$===Z,d$=($,Z)=>!1;function EZ($,Z){let J=Z.sourcesTail;if(J){let X=Z.sources;while(X){if(X===$)return!0;if(X===J)break;X=X.nextSource}}return!1}function O($,Z){let J=Z.sourcesTail;if(J?.source===$)return;let X=null,j=Z.flags&b$;if(j){if(X=J?J.nextSource:Z.sources,X?.source===$){Z.sourcesTail=X;return}}let Q=$.sinksTail;if(Q?.sink===Z&&(!j||EZ(Q,Z)))return;let M={source:$,sink:Z,nextSource:X,prevSink:Q,nextSink:null};if(Z.sourcesTail=$.sinksTail=M,J)J.nextSource=M;else Z.sources=M;if(Q)Q.nextSink=M;else $.sinks=M}function fZ($){let{source:Z,nextSource:J,nextSink:X,prevSink:j}=$;if(X)X.prevSink=j;else Z.sinksTail=j;if(j)j.nextSink=X;else Z.sinks=X;if(!Z.sinks){if(Z.stop)Z.stop(),Z.stop=void 0;if("sources"in Z&&Z.sources){let Q=Z;Q.sourcesTail=null,I$(Q)}}return J}function I$($){let Z=$.sourcesTail,J=Z?Z.nextSource:$.sources;while(J)J=fZ(J);if(Z)Z.nextSource=null;else $.sources=null}function w($,Z=F){let J=$.flags;if("sinks"in $){if((J&(F|G$))>=Z)return;if($.flags=J|Z,"controller"in $&&$.controller)$.controller.abort(),$.controller=void 0;for(let X=$.sinks;X;X=X.nextSink)w(X.sink,G$)}else{if((J&(F|G$))>=Z)return;let X=J&(F|G$);if($.flags=Z,!X)v$.push($)}}function y$($,Z){if($.equals($.value,Z))return;$.value=Z;for(let J=$.sinks;J;J=J.nextSink)w(J.sink);if(A===0)_()}function K$($,Z){if(!$.cleanup)$.cleanup=Z;else if(Array.isArray($.cleanup))$.cleanup.push(Z);else $.cleanup=[$.cleanup,Z]}function c$($){if(!$.cleanup)return;if(Array.isArray($.cleanup))for(let Z=0;Z<$.cleanup.length;Z++)$.cleanup[Z]();else $.cleanup();$.cleanup=null}function hZ($){let Z=Y;Y=$,$.sourcesTail=null,$.flags=b$;let J=!1;try{let X=$.fn($.value);if($.error||!$.equals(X,$.value))$.value=X,$.error=void 0,J=!0}catch(X){J=!0,$.error=X instanceof Error?X:Error(String(X))}finally{Y=Z,I$($)}if(J){for(let X=$.sinks;X;X=X.nextSink)if(X.sink.flags&G$)X.sink.flags|=F}$.flags=v}function kZ($){$.controller?.abort();let Z=new AbortController;$.controller=Z,$.error=void 0;let J=Y;Y=$,$.sourcesTail=null,$.flags=b$;let X;try{X=$.fn($.value,Z.signal)}catch(j){$.controller=void 0,$.error=j instanceof Error?j:Error(String(j));return}finally{Y=J,I$($)}X.then((j)=>{if(Z.signal.aborted)return;if($.controller=void 0,$.error||!$.equals(j,$.value)){$.value=j,$.error=void 0;for(let Q=$.sinks;Q;Q=Q.nextSink)w(Q.sink);if(A===0)_()}},(j)=>{if(Z.signal.aborted)return;$.controller=void 0;let Q=j instanceof Error?j:Error(String(j));if(!$.error||Q.name!==$.error.name||Q.message!==$.error.message){$.error=Q;for(let M=$.sinks;M;M=M.nextSink)w(M.sink);if(A===0)_()}}),$.flags=v}function qZ($){c$($);let Z=Y,J=h;Y=h=$,$.sourcesTail=null,$.flags=b$;try{let X=$.fn();if(typeof X==="function")K$($,X)}finally{Y=Z,h=J,I$($)}$.flags=v}function T($){if($.flags&G$)for(let Z=$.sources;Z;Z=Z.nextSource){if("fn"in Z.source)T(Z.source);if($.flags&F)break}if($.flags&b$)throw new U$("controller"in $?J$:("value"in $)?Z$:"Effect");if($.flags&F)if("controller"in $)kZ($);else if("value"in $)hZ($);else qZ($);else $.flags=v}function _(){if(zZ)return;zZ=!0;try{for(let $=0;$<v$.length;$++){let Z=v$[$];if(Z.flags&(F|G$))T(Z)}v$.length=0}finally{zZ=!1}}function r($){A++;try{$()}finally{if(A--,A===0)_()}}function u($){let Z=Y;Y=null;try{return $()}finally{Y=Z}}function n($){let Z=h,J={cleanup:null};h=J;try{let X=$();if(typeof X==="function")K$(J,X);let j=()=>c$(J);if(Z)K$(Z,j);return j}finally{h=Z}}function u$($){let Z=h;h=null;try{return $()}finally{h=Z}}function m($,Z){x($$,$,Z?.guard);let J={value:$,sinks:null,sinksTail:null,equals:Z?.equals??l,guard:Z?.guard};return{[Symbol.toStringTag]:$$,get(){if(Y)O(J,Y);return J.value},set(X){x($$,X,J.guard),y$(J,X)},update(X){g($$,X);let j=X(J.value);x($$,j,J.guard),y$(J,j)}}}function O$($){return S($,$$)}function H$($,Z,J){if(Object.is($,Z))return!0;if(typeof $!==typeof Z)return!1;if($==null||typeof $!=="object"||Z==null||typeof Z!=="object")return!1;if(!J)J=new WeakSet;if(J.has($)||J.has(Z))throw new U$("isEqual");J.add($),J.add(Z);try{let X=Array.isArray($);if(X!==Array.isArray(Z))return!1;if(X){let j=$,Q=Z;if(j.length!==Q.length)return!1;for(let M=0;M<j.length;M++)if(!H$(j[M],Q[M],J))return!1;return!0}if(L($)&&L(Z)){let j=Object.keys($),Q=Object.keys(Z);if(j.length!==Q.length)return!1;for(let M of j){if(!(M in Z))return!1;if(!H$($[M],Z[M],J))return!1}return!0}return!1}finally{J.delete($),J.delete(Z)}}function o$($,Z){if($.length!==Z.length)return!1;for(let J=0;J<$.length;J++)if($[J]!==Z[J])return!1;return!0}function UZ($){let Z=0,J=typeof $==="function";return[typeof $==="string"?()=>`${$}${Z++}`:J?(X)=>$(X)||String(Z++):()=>String(Z++),J]}function gZ($,Z,J,X,j){let Q=new WeakSet,M={},q={},z={},U=[],B=!1,W=new Map;for(let G=0;G<$.length;G++){let H=J[G];if(H&&$[G])W.set(H,$[G])}let K=new Set;for(let G=0;G<Z.length;G++){let H=Z[G];if(H===void 0)continue;let V=j?X(H):J[G]??X(H);if(K.has(V))throw new V$(p,V,H);if(U.push(V),K.add(V),!W.has(V))M[V]=H,B=!0;else if(!H$(W.get(V),H,Q))q[V]=H,B=!0}for(let[G]of W)if(!K.has(G))z[G]=null,B=!0;if(!B&&!o$(J,U))B=!0;return{add:M,change:q,remove:z,newKeys:U,changed:B}}function C$($,Z){x(p,$,Array.isArray);let J=new Map,X=[],[j,Q]=UZ(Z?.keyConfig),M=()=>X.map((H)=>J.get(H)?.get()).filter((H)=>H!==void 0),q={fn:M,value:$,flags:F,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:H$,error:void 0},z=(H)=>{let V={};for(let C=0;C<H.length;C++){let D=H[C];if(D===void 0)continue;let N=X[C];if(!N)N=j(D),X[C]=N;V[N]=D}return V},U=(H)=>{let V=!1;for(let C in H.add){let D=H.add[C];x(`${p} item for key "${C}"`,D),J.set(C,m(D)),V=!0}if(Object.keys(H.change).length)r(()=>{for(let C in H.change){let D=H.change[C];x(`${p} item for key "${C}"`,D);let N=J.get(C);if(N)N.set(D)}});for(let C in H.remove){J.delete(C);let D=X.indexOf(C);if(D!==-1)X.splice(D,1);V=!0}if(V)q.flags|=y;return H.changed},B=Z?.watched,W=B?()=>{if(Y){if(!q.sinks)q.stop=B();O(q,Y)}}:()=>{if(Y)O(q,Y)},K=z($);for(let H in K){let V=K[H];x(`${p} item for key "${H}"`,V),J.set(H,m(V))}q.value=$,q.flags=0;let G={[Symbol.toStringTag]:p,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let H of X){let V=J.get(H);if(V)yield V}},get length(){return W(),X.length},get(){if(W(),q.sources){if(q.flags){let H=q.flags&y;if(q.value=u(M),H){if(q.flags=F,T(q),q.error)throw q.error}else q.flags=v}}else if(T(q),q.error)throw q.error;return q.value},set(H){let V=q.flags&F?M():q.value,C=gZ(V,H,X,j,Q);if(C.changed){X=C.newKeys,U(C),q.flags|=F;for(let D=q.sinks;D;D=D.nextSink)w(D.sink);if(A===0)_()}},update(H){G.set(H(G.get()))},at(H){return J.get(X[H])},keys(){return W(),X.values()},byKey(H){return J.get(H)},keyAt(H){return X[H]},indexOfKey(H){return X.indexOf(H)},add(H){let V=j(H);if(J.has(V))throw new V$(p,V,H);if(!X.includes(V))X.push(V);x(`${p} item for key "${V}"`,H),J.set(V,m(H)),q.flags|=F|y;for(let C=q.sinks;C;C=C.nextSink)w(C.sink);if(A===0)_();return V},remove(H){let V=typeof H==="number"?X[H]:H;if(J.delete(V)){let D=typeof H==="number"?H:X.indexOf(V);if(D>=0)X.splice(D,1);q.flags|=F|y;for(let N=q.sinks;N;N=N.nextSink)w(N.sink);if(A===0)_()}},sort(H){let C=X.map((D)=>[D,J.get(D)?.get()]).sort(P(H)?(D,N)=>H(D[1],N[1]):(D,N)=>String(D[1]).localeCompare(String(N[1]))).map(([D])=>D);if(!o$(X,C)){X=C,q.flags|=F;for(let D=q.sinks;D;D=D.nextSink)w(D.sink);if(A===0)_()}},splice(H,V,...C){let D=X.length,N=H<0?Math.max(0,D+H):Math.min(H,D),I=Math.max(0,Math.min(V??Math.max(0,D-Math.max(0,N)),D-N)),b={},k={};for(let c=0;c<I;c++){let q$=N+c,HZ=X[q$];if(HZ){let FZ=J.get(HZ);if(FZ)k[HZ]=FZ.get()}}let WZ=X.slice(0,N);for(let c of C){let q$=j(c);if(J.has(q$)&&!(q$ in k))throw new V$(p,q$,c);WZ.push(q$),b[q$]=c}WZ.push(...X.slice(N+I));let DZ=!!(Object.keys(b).length||Object.keys(k).length);if(DZ){U({add:b,change:{},remove:k,changed:DZ}),X=WZ,q.flags|=F;for(let c=q.sinks;c;c=c.nextSink)w(c.sink);if(A===0)_()}return Object.values(k)},deriveCollection(H){return s$(G,H)}};return G}function m$($){return S($,p)}function o($,Z){if(g(Z$,$,P$),Z?.value!==void 0)x(Z$,Z.value,Z?.guard);let J={fn:$,value:Z?.value,flags:F,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:Z?.equals??l,error:void 0,stop:void 0},X=Z?.watched,j=X?()=>{if(Y){if(!J.sinks)J.stop=X(()=>{if(w(J),A===0)_()});O(J,Y)}}:()=>{if(Y)O(J,Y)};return{[Symbol.toStringTag]:Z$,get(){if(j(),T(J),J.error)throw J.error;return x$(Z$,J.value),J.value}}}function B$($){return S($,Z$)}function Y$($,Z){if(g(J$,$,t),Z?.value!==void 0)x(J$,Z.value,Z?.guard);let J={fn:$,value:Z?.value,sources:null,sourcesTail:null,sinks:null,sinksTail:null,flags:F,equals:Z?.equals??l,controller:void 0,error:void 0,stop:void 0},X=Z?.watched,j=X?()=>{if(Y){if(!J.sinks)J.stop=X(()=>{if(w(J),A===0)_()});O(J,Y)}}:()=>{if(Y)O(J,Y)};return{[Symbol.toStringTag]:J$,get(){if(j(),T(J),J.error)throw J.error;return x$(J$,J.value),J.value},isPending(){return!!J.controller},abort(){J.controller?.abort(),J.controller=void 0}}}function i$($){return S($,J$)}function s$($,Z){g(j$,Z);let J=t(Z),X=new Map,j=[],Q=(G)=>{let H=J?Y$(async(V,C)=>{let D=$.byKey(G)?.get();if(D==null)return V;return Z(D,C)}):o(()=>{let V=$.byKey(G)?.get();if(V==null)return;return Z(V)});X.set(G,H)};function M(G){if(!o$(j,G)){let H=new Set(j),V=new Set(G);for(let C of j)if(!V.has(C))X.delete(C);for(let C of G)if(!H.has(C))Q(C);j=G,U.flags|=y}}function q(){M(Array.from($.keys()));let G=[];for(let H of j)try{let V=X.get(H)?.get();if(V!=null)G.push(V)}catch(V){if(!(V instanceof e))throw V}return G}let U={fn:q,value:[],flags:F,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:(G,H)=>{if(G.length!==H.length)return!1;for(let V=0;V<G.length;V++)if(G[V]!==H[V])return!1;return!0},error:void 0};function B(){if(U.sources){if(U.flags)if(U.value=u(q),U.flags&y){if(U.flags=F,T(U),U.error)throw U.error}else U.flags=v}else if(U.sinks){if(T(U),U.error)throw U.error}else U.value=u(q)}let W=Array.from(u(()=>$.keys()));for(let G of W)Q(G);j=W;let K={[Symbol.toStringTag]:j$,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let G of j){let H=X.get(G);if(H)yield H}},get length(){if(Y)O(U,Y);return B(),j.length},keys(){if(Y)O(U,Y);return B(),j.values()},get(){if(Y)O(U,Y);return B(),U.value},at(G){return X.get(j[G])},byKey(G){return X.get(G)},keyAt(G){return j[G]},indexOfKey(G){return j.indexOf(G)},deriveCollection(G){return s$(K,G)}};return K}function NZ($,Z){let J=Z?.value??[];if(J.length)x(j$,J,Array.isArray);g(j$,$,P$);let X=new Map,j=[],Q=new Map,[M,q]=UZ(Z?.keyConfig),z=(H)=>Q.get(H)??(q?M(H):void 0),U=Z?.createItem??m;function B(){let H=[];for(let V of j)try{let C=X.get(V)?.get();if(C!=null)H.push(C)}catch(C){if(!(C instanceof e))throw C}return H}let W={fn:B,value:J,flags:F,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:d$,error:void 0};for(let H of J){let V=M(H);X.set(V,U(H)),Q.set(H,V),j.push(V)}W.value=J,W.flags=F;function K(){if(Y){if(!W.sinks)W.stop=$((H)=>{let{add:V,change:C,remove:D}=H;if(!V?.length&&!C?.length&&!D?.length)return;let N=!1;r(()=>{if(V)for(let I of V){let b=M(I);if(X.set(b,U(I)),Q.set(I,b),!j.includes(b))j.push(b);N=!0}if(C)for(let I of C){let b=z(I);if(!b)continue;let k=X.get(b);if(k&&O$(k))Q.delete(k.get()),k.set(I),Q.set(I,b)}if(D)for(let I of D){let b=z(I);if(!b)continue;Q.delete(I),X.delete(b);let k=j.indexOf(b);if(k!==-1)j.splice(k,1);N=!0}W.flags=F|(N?y:0);for(let I=W.sinks;I;I=I.nextSink)w(I.sink)})});O(W,Y)}}let G={[Symbol.toStringTag]:j$,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let H of j){let V=X.get(H);if(V)yield V}},get length(){return K(),j.length},keys(){return K(),j.values()},get(){if(K(),W.sources){if(W.flags){let H=W.flags&y;if(W.value=u(B),H){if(W.flags=F,T(W),W.error)throw W.error}else W.flags=v}}else if(T(W),W.error)throw W.error;return W.value},at(H){return X.get(j[H])},byKey(H){return X.get(H)},keyAt(H){return j[H]},indexOfKey(H){return j.indexOf(H)},deriveCollection(H){return s$(G,H)}};return G}function PZ($){return S($,j$)}function E$($){g("Effect",$);let Z={fn:$,flags:F,sources:null,sourcesTail:null,cleanup:null},J=()=>{c$(Z),Z.fn=void 0,Z.flags=v,Z.sourcesTail=null,I$(Z)};if(h)K$(h,J);return qZ(Z),J}function xZ($,Z){if(!h)throw new T$("match");let{ok:J,err:X=console.error,nil:j}=Z,Q,M=!1,q=Array($.length);for(let U=0;U<$.length;U++)try{q[U]=$[U].get()}catch(B){if(B instanceof e){M=!0;continue}if(!Q)Q=[];Q.push(B instanceof Error?B:Error(String(B)))}let z;try{if(M)z=j?.();else if(Q)z=X(Q);else z=J(q)}catch(U){X([U instanceof Error?U:Error(String(U))])}if(typeof z==="function")return z;if(z instanceof Promise){let U=h,B=new AbortController;K$(U,()=>B.abort()),z.then((W)=>{if(!B.signal.aborted&&typeof W==="function")K$(U,W)}).catch((W)=>{X([W instanceof Error?W:Error(String(W))])})}}function l$($,Z){if(g(X$,$,P$),Z?.value!==void 0)x(X$,Z.value,Z?.guard);let J={value:Z?.value,sinks:null,sinksTail:null,equals:Z?.equals??l,guard:Z?.guard,stop:void 0};return{[Symbol.toStringTag]:X$,get(){if(Y){if(!J.sinks)J.stop=$((X)=>{x(X$,X,J.guard),y$(J,X)});O(J,Y)}return x$(X$,J.value),J.value}}}function IZ($){return S($,X$)}function pZ($,Z){let J=L($)||Array.isArray($),X=L(Z)||Array.isArray(Z);if(!J||!X){let W=!Object.is($,Z);return{changed:W,add:W&&X?Z:{},change:{},remove:W&&J?$:{}}}let j=new WeakSet,Q={},M={},q={},z=!1,U=Object.keys($),B=Object.keys(Z);for(let W of B)if(W in $){if(!H$($[W],Z[W],j))M[W]=Z[W],z=!0}else Q[W]=Z[W],z=!0;for(let W of U)if(!(W in Z))q[W]=void 0,z=!0;return{add:Q,change:M,remove:q,changed:z}}function A$($,Z){x(Q$,$,L);let J=new Map,X=(B,W)=>{if(x(`${Q$} for key "${B}"`,W),Array.isArray(W))J.set(B,C$(W));else if(L(W))J.set(B,A$(W));else J.set(B,m(W))},j=()=>{let B={};return J.forEach((W,K)=>{B[K]=W.get()}),B},Q={fn:j,value:$,flags:F,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:H$,error:void 0},M=(B)=>{let W=!1;for(let K in B.add)X(K,B.add[K]),W=!0;if(Object.keys(B.change).length)r(()=>{for(let K in B.change){let G=B.change[K];x(`${Q$} for key "${K}"`,G);let H=J.get(K);if(H)if(L(G)!==f$(H))X(K,G),W=!0;else H.set(G)}});for(let K in B.remove)J.delete(K),W=!0;if(W)Q.flags|=y;return B.changed},q=Z?.watched,z=q?()=>{if(Y){if(!Q.sinks)Q.stop=q();O(Q,Y)}}:()=>{if(Y)O(Q,Y)};for(let B of Object.keys($))X(B,$[B]);let U={[Symbol.toStringTag]:Q$,[Symbol.isConcatSpreadable]:!1,*[Symbol.iterator](){for(let B of Array.from(J.keys())){let W=J.get(B);if(W)yield[B,W]}},keys(){return z(),J.keys()},byKey(B){return J.get(B)},get(){if(z(),Q.sources){if(Q.flags){let B=Q.flags&y;if(Q.value=u(j),B){if(Q.flags=F,T(Q),Q.error)throw Q.error}else Q.flags=v}}else if(T(Q),Q.error)throw Q.error;return Q.value},set(B){let W=Q.flags&F?j():Q.value,K=pZ(W,B);if(M(K)){Q.flags|=F;for(let G=Q.sinks;G;G=G.nextSink)w(G.sink);if(A===0)_()}},update(B){U.set(B(U.get()))},add(B,W){if(J.has(B))throw new V$(Q$,B,W);X(B,W),Q.flags|=F|y;for(let K=Q.sinks;K;K=K.nextSink)w(K.sink);if(A===0)_();return B},remove(B){if(J.delete(B)){Q.flags|=F|y;for(let K=Q.sinks;K;K=K.nextSink)w(K.sink);if(A===0)_()}}};return new Proxy(U,{get(B,W){if(W in B)return Reflect.get(B,W);if(typeof W!=="symbol")return B.byKey(W)},has(B,W){if(W in B)return!0;return B.byKey(String(W))!==void 0},ownKeys(B){return Array.from(B.keys())},getOwnPropertyDescriptor(B,W){if(W in B)return Reflect.getOwnPropertyDescriptor(B,W);if(typeof W==="symbol")return;let K=B.byKey(String(W));return K?{enumerable:!0,configurable:!0,writable:!0,value:K}:void 0}})}function f$($){return S($,Q$)}function w$($,Z){return t($)?Y$($,Z):o($,Z)}function OZ($){if(d($))return $;if($==null)throw new M$("createSignal",$);if(t($))return Y$($);if(P($))return o($);if(BZ($))return C$($);if(L($))return A$($);return m($)}function AZ($){if(D$($))return $;if($==null||P($)||d($))throw new M$("createMutableSignal",$);if(BZ($))return C$($);if(L($))return A$($);return m($)}function r$($){return B$($)||i$($)}function d($){let Z=[$$,Z$,J$,X$,W$,p,j$,Q$],J=Object.prototype.toString.call($).slice(8,-1);return Z.includes(J)}function D$($){return O$($)||f$($)||m$($)}function n$($,Z){x(W$,$,d);let J=$,X=Z?.guard,j={fn:()=>J.get(),value:void 0,flags:F,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:Z?.equals??l,error:void 0},Q=()=>{if(Y)O(j,Y);if(T(j),j.error)throw j.error;return j.value},M=(z)=>{if(!D$(J))throw new S$(W$);x(W$,z,X),J.set(z)},q=(z)=>{x(W$,z,d),J=z,j.flags|=F;for(let U=j.sinks;U;U=U.nextSink)w(U.sink);if(A===0)_()};return{[Symbol.toStringTag]:W$,configurable:!0,enumerable:!0,get:Q,set:M,replace:q,current:()=>J}}function R$($){return S($,W$)}var s=!1,vZ="debug";var z$="warn",L$="error",dZ=new Set(["constructor","prototype"]),cZ=new Set(["id","class","className","title","role","style","dataset","lang","dir","hidden","children","innerHTML","outerHTML","textContent","innerText"]),uZ=($)=>$?`#${$}`:"",oZ=($)=>$?.length?`.${Array.from($).join(".")}`:"";var MZ=($)=>$.localName.includes("-"),VZ=($)=>MZ($)&&$.matches(":not(:defined)"),R=($)=>$?`<${$.localName}${uZ($.id)}${oZ($.classList)}>`:"<unknown>";var F$=($,Z,J=vZ)=>{if(s||[L$,z$].includes(J))console[J](Z,$);return $},wZ=($)=>{if(dZ.has($))return`Property name "${$}" is a reserved word`;if(cZ.has($))return`Property name "${$}" conflicts with inherited HTMLElement property`;return null};class t$ extends TypeError{constructor($){super(`Invalid component name "${$}". Custom element names must contain a hyphen, start with a lowercase letter, and contain only lowercase letters, numbers, and hyphens.`);this.name="InvalidComponentNameError"}}class a$ extends TypeError{constructor($,Z,J){super(`Invalid property name "${Z}" for component <${$}>. ${J}`);this.name="InvalidPropertyNameError"}}class e$ extends TypeError{constructor($,Z){super(`Invalid effects in component ${R($)}. Effects must be a record of effects for UI elements or the component, or a Promise that resolves to effects.`);if(this.name="InvalidEffectsError",Z)this.cause=Z}}class RZ extends TypeError{constructor($,Z,J){super(`Invalid UI key "${Z}" in ${J} of component ${R($)}`);this.name="InvalidUIKeyError"}}class h$ extends Error{constructor($,Z,J){super(`Missing required element <${Z}> in component ${R($)}. ${J}`);this.name="MissingElementError"}}class $Z extends Error{constructor($,Z){super(`Timeout waiting for: [${Z.join(", ")}] in component ${R($)}.`);this.name="DependencyTimeoutError"}}class ZZ extends TypeError{constructor($,Z,J){super(`Expected reactives passed from ${R($)} to ${R(Z)} to be a record of signals, reactive property names or functions. Got ${a(J)}.`);this.name="InvalidReactivesError"}}class JZ extends TypeError{constructor($,Z){super(`Target ${R($)} is not a custom element in ${Z}.`);this.name="InvalidCustomElementError"}}var sZ=($,Z="")=>{return{a:"attribute ",c:"class ",d:"dataset ",h:"inner HTML",m:"method call ",p:"property ",s:"style property ",t:"text content"}[$]+Z},LZ=($,Z)=>{if(!L(Z))throw new e$($.host);return n(()=>{for(let J of Object.keys(Z)){let X=J;if(!Z[X])continue;let j=Array.isArray(Z[X])?Z[X]:[Z[X]];if(B$($[X]))E$(()=>{for(let Q of $[X].get())for(let M of j)M($.host,Q)});else if($[X])for(let Q of j)Q($.host,$[X])}})},iZ=($,Z,J,X)=>{try{if(typeof $==="string"){if(s&&!($ in Z))F$($,`resolveReactive: property '${$}' does not exist on ${R(Z)}`,z$);return Z[$]}return d($)?$.get():P($)?$(J):void 0}catch(j){if(X)F$(j,`Failed to resolve value of ${a($)}${X?` for ${X}`:""} in ${R(J)}${Z!==J?` in ${R(Z)}`:""}`,L$);return}},E=($,Z)=>(J,X)=>{let{op:j,name:Q="",read:M,update:q}=Z,z=sZ(j,Q),U=(K)=>()=>{if(s&&J.debug)F$(X,`${K} ${z} of ${R(X)} in ${R(J)}`);Z.resolve?.(X)},B=(K)=>(G)=>{F$(G,`Failed to ${K} ${z} of ${R(X)} in ${R(J)}`,L$),Z.reject?.(G)},W=M(X);return E$(()=>{let K=iZ($,J,X,z),G=K===void 0?W:K===null?Z.delete?null:W:K;if(Z.delete&&G===null)try{Z.delete(X),U("delete")()}catch(H){B("delete")(H)}else if(G!=null){let H=M(X);if(Object.is(G,H))return;try{q(X,G),U("update")()}catch(V){B("update")(V)}}})};var _Z=new WeakMap,k$=($)=>{let Z=_Z.get($);if(!Z)Z={},_Z.set($,Z);return Z};var SZ=Symbol("parser"),TZ=Symbol("method"),_$=($)=>{if(!P($))return!1;if(SZ in $)return!0;if($.length>=2){if(s)console.warn("isParser: unbranded two-argument function detected. Wrap custom parsers with asParser() to avoid misclassification when using default parameters or destructuring.",$);return!0}return!1},GZ=($)=>P($)&&(TZ in $),lZ=($)=>P($),f=($,Z)=>lZ(Z)?Z($):Z,i=($)=>Object.assign($,{[SZ]:!0}),rZ=($)=>Object.assign($,{[TZ]:!0}),nZ=($,Z)=>(J)=>{let X=$(J);return typeof X==="string"&&_$(Z)?Z(J,X):X??f(J,Z)};var tZ=200,aZ=($)=>{let Z=new Set;if($.includes("."))Z.add("class");if($.includes("#"))Z.add("id");if($.includes("[")){let J=$.split("[");for(let X=1;X<J.length;X++){let j=J[X];if(!j.includes("]"))continue;let Q=j.split("=")[0].trim().replace(/[^a-zA-Z0-9_-]/g,"");if(Q)Z.add(Q)}}return[...Z]};function bZ($,Z){return o(()=>Array.from($.querySelectorAll(Z)),{value:[],equals:(J,X)=>J.length===X.length&&J.every((j,Q)=>j===X[Q]),watched:(J)=>{let X={childList:!0,subtree:!0},j=aZ(Z);if(j.length)X.attributes=!0,X.attributeFilter=j;let Q=(z)=>z instanceof Element&&(z.matches(Z)||z.querySelector(Z)),M=(z)=>{if(z.type==="attributes")return!0;if(z.type==="childList")return Array.from(z.addedNodes).some(Q)||Array.from(z.removedNodes).some(Q);return!1},q=new MutationObserver((z)=>{for(let U of z)if(M(U)){J();return}});return q.observe($,X),()=>q.disconnect()}})}var yZ=($)=>{let Z=$.shadowRoot??$,J=new Set;function X(M,q){let z=Z.querySelector(M);if(q!=null&&!z)throw new h$($,M,q);if(z&&VZ(z))J.add(z.localName);return z??void 0}function j(M,q){let z=bZ(Z,M),U=z.get();if(q!=null&&!U.length)throw new h$($,M,q);if(U.length){for(let B of U)if(VZ(B))J.add(B.localName)}return z}return[{first:X,all:j},(M)=>{if(J.size)queueMicrotask(()=>{let q=Array.from(J).filter((z)=>!customElements.get(z));if(!q.length){M();return}Promise.race([Promise.all(q.map((z)=>customElements.whenDefined(z))),new Promise((z,U)=>{setTimeout(()=>{U(new $Z($,q.filter((B)=>!customElements.get(B))))},tZ)})]).then(M).catch((z)=>{if(s)console[z$](z);M()})});else M()}]};function eZ($,Z={},J=()=>({}),X=()=>({})){if(!$.includes("-")||!$.match(/^[a-z][a-z0-9-]*$/))throw new t$($);for(let Q of Object.keys(Z)){let M=wZ(Q);if(M)throw new a$($,Q,M)}class j extends HTMLElement{debug;#$;#J;static observedAttributes=Object.entries(Z)?.filter(([,Q])=>_$(Q)).map(([Q])=>Q)??[];connectedCallback(){let[Q,M]=yZ(this),q={...J(Q),host:this};this.#$=q,Object.freeze(this.#$);let z=(U,B)=>{if(_$(B)){let W=B(q,this.getAttribute(U));if(W!=null)this.#Z(U,W)}else if(GZ(B))B(q);else if(P(B)){let W=B(q);if(W!=null)this.#Z(U,W)}else{let W=B;if(W!=null)this.#Z(U,W)}};for(let[U,B]of Object.entries(Z)){if(B==null||U in this)continue;z(U,B)}M(()=>{this.#J=u$(()=>LZ(q,X(q)))})}disconnectedCallback(){if(P(this.#J))this.#J()}attributeChangedCallback(Q,M,q){if(!this.#$||q===M||r$(k$(this)[Q]))return;let z=Z[Q];if(!_$(z))return;let U=z(this.#$,q,M);if(Q in this)this[Q]=U;else this.#Z(Q,U)}#Z(Q,M){let q=d(M)?M:P(M)?w$(M):m(M),z=k$(this),U=Q,B=z[U];if(R$(B))B.replace(q);else if(D$(q)){let W=n$(q);z[U]=W,Object.defineProperty(this,Q,W)}else z[U]=q,Object.defineProperty(this,Q,{get:q.get,enumerable:!0})}}return customElements.define($,j),customElements.get($)}var XZ="context-request";class KZ extends Event{context;callback;subscribe;constructor($,Z,J=!1){super(XZ,{bubbles:!0,composed:!0});this.context=$,this.callback=Z,this.subscribe=J}}var $6=($)=>(Z)=>n(()=>{let J=(X)=>{let{context:j,callback:Q}=X;if(typeof j==="string"&&$.includes(j)&&P(Q))X.stopImmediatePropagation(),Q(()=>Z[j])};return Z.addEventListener(XZ,J),()=>Z.removeEventListener(XZ,J)}),Z6=($,Z)=>(J)=>{let X=()=>f(J,Z);return J.host.dispatchEvent(new KZ($,(j)=>{X=j})),o(X)};var J6=($)=>{if(/^(mailto|tel):/i.test($))return!0;if($.includes("://"))try{let Z=new URL($,window.location.origin);return["http:","https:","ftp:"].includes(Z.protocol)}catch{return!1}return!0},X6=($,Z,J)=>{if(/^on/i.test(Z))throw Error(`setAttribute: blocked unsafe attribute name '${Z}' on ${$.localName} — event handler attributes are not allowed`);if(J=String(J).trim(),!J6(J))throw Error(`setAttribute: blocked unsafe value for '${Z}' on <${$.localName}>: '${J}'`);$.setAttribute(Z,J)},j6=($,Z=$)=>E(Z,{op:"a",name:$,read:(J)=>J.getAttribute($),update:(J,X)=>{X6(J,$,X)},delete:(J)=>{J.removeAttribute($)}}),Q6=($,Z=$)=>E(Z,{op:"a",name:$,read:(J)=>J.hasAttribute($),update:(J,X)=>{J.toggleAttribute($,X)}});var W6=($,Z=$)=>E(Z,{op:"c",name:$,read:(J)=>J.classList.contains($),update:(J,X)=>{J.classList.toggle($,X)}});var QZ=new Set(["scroll","resize","mousewheel","touchstart","touchmove","wheel"]),CZ=new Set,mZ=new WeakMap,jZ,H6=()=>{jZ=void 0;let $=Array.from(CZ);CZ.clear();for(let Z of $)mZ.get(Z)?.()},B6=()=>{if(jZ)cancelAnimationFrame(jZ);jZ=requestAnimationFrame(H6)},N$=($,Z)=>{mZ.set($,Z),CZ.add($),B6()};var z6=($,Z,J={})=>(X,j)=>n(()=>{if(!("passive"in J))J={...J,passive:QZ.has($)};let Q=(M)=>{let q=()=>{let z=Z(M);if(!L(z))return;r(()=>{for(let[U,B]of Object.entries(z))try{X[U]=B}catch(W){F$(W,`Reactive property "${U}" on ${R(X)} from event ${$} on ${R(j)} could not be set, because it is read-only.`,L$)}})};if(J.passive)N$(j,q);else q()};return j.addEventListener($,Q,J),()=>j.removeEventListener($,Q)});var q6=($,Z={})=>E($,{op:"h",read:(J)=>(J.shadowRoot||!Z.shadowRootMode?J:null)?.innerHTML??"",update:(J,X)=>{let{shadowRootMode:j,allowScripts:Q}=Z;if(!X){if(J.shadowRoot)J.shadowRoot.innerHTML="<slot></slot>";return""}if(j&&!J.shadowRoot)J.attachShadow({mode:j});let M=J.shadowRoot||J;return N$(J,()=>{if(M.innerHTML=X,Q){let q=["type","src","async","defer","nomodule","crossorigin","integrity","referrerpolicy","fetchpriority"];M.querySelectorAll("script").forEach((z)=>{let U=document.createElement("script");for(let B of q)if(z.hasAttribute(B))U.setAttribute(B,z.getAttribute(B));if(!z.hasAttribute("src"))U.appendChild(document.createTextNode(z.textContent??""));M.appendChild(U),z.remove()})}}),Q?" with scripts":""}});var U6=($)=>(Z,J)=>n(()=>{if(!MZ(J))throw new JZ(J,`pass from ${R(Z)}`);let X=P($)?$(J):$;if(!L(X))throw new ZZ(Z,J,X);let j=(z)=>{if(d(z))return z;let U=typeof z==="string"&&z in Z?()=>Z[z]:P(z)?z:void 0;return U?w$(U):void 0},Q=k$(J),M=R(J),q=[];for(let[z,U]of Object.entries(X)){if(U==null)continue;if(!(z in J)){if(s)console[z$](`pass(): property '${z}' does not exist on ${M}`);continue}let B=j(U);if(!B)continue;let W=Q[z];if(R$(W)){let K=W.current();W.replace(B),q.push(()=>W.replace(K));continue}if(s)console[z$](`pass(): property '${z}' on ${M} is not Slot-backed — use setProperty() for non-Le Truc elements`)}if(q.length)return()=>{for(let z of q)z()}});var M6=($,Z=$)=>E(Z,{op:"p",name:$,read:(J)=>($ in J)?J[$]??null:null,update:(J,X)=>{J[$]=X}}),V6=($)=>E($,{op:"p",name:"hidden",read:(Z)=>!Z.hidden,update:(Z,J)=>{Z.hidden=!J}});var G6=($,Z=$)=>E(Z,{op:"s",name:$,read:(J)=>J.style.getPropertyValue($),update:(J,X)=>{J.style.setProperty($,X)},delete:(J)=>{J.style.removeProperty($)}});var K6=($)=>E($,{op:"t",read:(Z)=>Z.textContent,update:(Z,J)=>{Array.from(Z.childNodes).filter((X)=>X.nodeType!==Node.COMMENT_NODE).forEach((X)=>X.remove()),Z.append(document.createTextNode(J))}});var C6=($,Z,J)=>(X)=>{let{host:j}=X,Q=f(X,$),M=B$(X[Z])?X[Z]:null,q=M?null:X[Z],z=new Map,U=(B)=>{if(q)return q.contains(B)?q:void 0;for(let W of M.get())if(W.contains(B))return W};return l$((B)=>{for(let[W,K]of Object.entries(J)){let G={passive:QZ.has(W)},H=(V)=>{let C=V.target;if(!C)return;let D=U(C);if(!D)return;V.stopPropagation();let N=()=>{try{let I=K({event:V,ui:X,target:D,prev:Q});if(I==null||I instanceof Promise)return;if(!Object.is(I,Q))Q=I,B(I)}catch(I){throw V.stopImmediatePropagation(),I}};if(G.passive)N$(j,N);else N()};z.set(W,H),j.addEventListener(W,H,G)}return()=>{if(z.size){for(let[W,K]of z)j.removeEventListener(W,K);z.clear()}}},{value:Q})};var Y6=()=>i(($,Z)=>Z!=null&&Z!=="false");var D6=($)=>i((Z,J)=>{if((J??$)==null)throw TypeError("asJSON: Value and fallback are both null or undefined");if(J==null)return f(Z,$);if(J==="")throw TypeError("Empty string is not valid JSON");let X;try{X=JSON.parse(J)}catch(j){throw SyntaxError(`Failed to parse JSON: ${String(j)}`,{cause:j})}return X??f(Z,$)});var YZ=($,Z)=>{if(Z==null)return;let J=$(Z);return Number.isFinite(J)?J:void 0},F6=($=0)=>i((Z,J)=>{if(J==null)return f(Z,$);let X=J.trim();if(X.toLowerCase().startsWith("0x"))return YZ((Q)=>parseInt(Q,16),X)??f(Z,$);let j=YZ(parseFloat,J);return j!=null?Math.trunc(j):f(Z,$)}),N6=($=0)=>i((Z,J)=>YZ(parseFloat,J)??f(Z,$));var P6=($="")=>i((Z,J)=>J??f(Z,$)),x6=($)=>i((Z,J)=>{if(J==null)return $[0];let X=J.toLowerCase();return $.find((Q)=>Q.toLowerCase()===X)?J:$[0]});export{a as valueString,E as updateElement,u as untrack,u$ as unown,W6 as toggleClass,Q6 as toggleAttribute,V6 as show,K6 as setText,G6 as setStyle,M6 as setProperty,j6 as setAttribute,N$ as schedule,Z6 as requestContext,nZ as read,$6 as provideContexts,U6 as pass,z6 as on,xZ as match,i$ as isTask,f$ as isStore,O$ as isState,R$ as isSlot,d as isSignal,IZ as isSensor,L as isRecord,_$ as isParser,S as isObjectOfType,D$ as isMutableSignal,GZ as isMethodProducer,B$ as isMemo,m$ as isList,P as isFunction,H$ as isEqual,r$ as isComputed,PZ as isCollection,t as isAsyncFunction,eZ as defineComponent,q6 as dangerouslySetInnerHTML,Y$ as createTask,A$ as createStore,m as createState,n$ as createSlot,OZ as createSignal,l$ as createSensor,n as createScope,AZ as createMutableSignal,o as createMemo,C$ as createList,C6 as createEventsSensor,bZ as createElementsMemo,E$ as createEffect,w$ as createComputed,NZ as createCollection,r as batch,P6 as asString,i as asParser,N6 as asNumber,rZ as asMethod,D6 as asJSON,F6 as asInteger,x6 as asEnum,Y6 as asBoolean,e as UnsetSignalValueError,d$ as SKIP_EQUALITY,T$ as RequiredOwnerError,S$ as ReadonlySignalError,g$ as NullishSignalValueError,h$ as MissingElementError,RZ as InvalidUIKeyError,M$ as InvalidSignalValueError,ZZ as InvalidReactivesError,a$ as InvalidPropertyNameError,e$ as InvalidEffectsError,JZ as InvalidCustomElementError,t$ as InvalidComponentNameError,p$ as InvalidCallbackError,$Z as DependencyTimeoutError,KZ as ContextRequestEvent,U$ as CircularDependencyError,XZ as CONTEXT_REQUEST};

//# debugId=30C51343EC4301B664756E2164756E21
