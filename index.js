function P($){return typeof $==="function"}function Q$($){return P($)&&$.constructor.name==="AsyncFunction"}function D$($){return P($)&&$.constructor.name!=="AsyncFunction"}function S($,Z){return Object.prototype.toString.call($)===`[object ${Z}]`}function _($){return S($,"Object")}function FZ($,Z=(J)=>J!=null){return Array.isArray($)&&$.every(Z)}function n($){return typeof $==="string"?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($)}class U$ extends Error{constructor($){super(`[${$}] Circular dependency detected`);this.name="CircularDependencyError"}}class k$ extends TypeError{constructor($){super(`[${$}] Signal value cannot be null or undefined`);this.name="NullishSignalValueError"}}class W$ extends Error{constructor($){super(`[${$}] Signal value is unset`);this.name="UnsetSignalValueError"}}class F$ extends TypeError{constructor($,Z){super(`[${$}] Signal value ${n(Z)} is invalid`);this.name="InvalidSignalValueError"}}class h$ extends TypeError{constructor($,Z){super(`[${$}] Callback ${n(Z)} is invalid`);this.name="InvalidCallbackError"}}class g$ extends Error{constructor($){super(`[${$}] Signal is read-only`);this.name="ReadonlySignalError"}}class p$ extends Error{constructor($){super(`[${$}] Active owner is required`);this.name="RequiredOwnerError"}}class M$ extends Error{constructor($,Z,J){super(`[${$}] Could not add key "${Z}"${J?` with value ${JSON.stringify(J)}`:""} because it already exists`);this.name="DuplicateKeyError"}}function x($,Z,J){if(Z==null)throw new k$($);if(J&&!J(Z))throw new F$($,Z)}function N$($,Z){if(Z==null)throw new W$($)}function h($,Z,J=P){if(!J(Z))throw new h$($,Z)}var t="State",a="Memo",e="Task",$$="Sensor",g="List",Z$="Collection",J$="Store",X$="Slot",p=0,V$=1,F=2,_$=4,y=8,Y=null,c=null,v$=[],A=0,WZ=!1,s=($,Z)=>$===Z,HZ=($,Z)=>!1;function mZ($,Z){let J=Z.sourcesTail;if(J){let X=Z.sources;while(X){if(X===$)return!0;if(X===J)break;X=X.nextSource}}return!1}function O($,Z){let J=Z.sourcesTail;if(J?.source===$)return;let X=null,j=Z.flags&_$;if(j){if(X=J?J.nextSource:Z.sources,X?.source===$){Z.sourcesTail=X;return}}let Q=$.sinksTail;if(Q?.sink===Z&&(!j||mZ(Q,Z)))return;let M={source:$,sink:Z,nextSource:X,prevSink:Q,nextSink:null};if(Z.sourcesTail=$.sinksTail=M,J)J.nextSource=M;else Z.sources=M;if(Q)Q.nextSink=M;else $.sinks=M}function EZ($){let{source:Z,nextSource:J,nextSink:X,prevSink:j}=$;if(X)X.prevSink=j;else Z.sinksTail=j;if(j)j.nextSink=X;else Z.sinks=X;if(!Z.sinks){if(Z.stop)Z.stop(),Z.stop=void 0;if("sources"in Z&&Z.sources){let Q=Z;Q.sourcesTail=null,P$(Q)}}return J}function P$($){let Z=$.sourcesTail,J=Z?Z.nextSource:$.sources;while(J)J=EZ(J);if(Z)Z.nextSource=null;else $.sources=null}function w($,Z=F){let J=$.flags;if("sinks"in $){if((J&(F|V$))>=Z)return;if($.flags=J|Z,"controller"in $&&$.controller)$.controller.abort(),$.controller=void 0;for(let X=$.sinks;X;X=X.nextSink)w(X.sink,V$)}else{if((J&(F|V$))>=Z)return;let X=J&(F|V$);if($.flags=Z,!X)v$.push($)}}function T$($,Z){if($.equals($.value,Z))return;$.value=Z;for(let J=$.sinks;J;J=J.nextSink)w(J.sink);if(A===0)L()}function G$($,Z){if(!$.cleanup)$.cleanup=Z;else if(Array.isArray($.cleanup))$.cleanup.push(Z);else $.cleanup=[$.cleanup,Z]}function d$($){if(!$.cleanup)return;if(Array.isArray($.cleanup))for(let Z=0;Z<$.cleanup.length;Z++)$.cleanup[Z]();else $.cleanup();$.cleanup=null}function fZ($){let Z=Y;Y=$,$.sourcesTail=null,$.flags=_$;let J=!1;try{let X=$.fn($.value);if($.error||!$.equals(X,$.value))$.value=X,$.error=void 0,J=!0}catch(X){J=!0,$.error=X instanceof Error?X:Error(String(X))}finally{Y=Z,P$($)}if(J){for(let X=$.sinks;X;X=X.nextSink)if(X.sink.flags&V$)X.sink.flags|=F}$.flags=p}function kZ($){$.controller?.abort();let Z=new AbortController;$.controller=Z,$.error=void 0;let J=Y;Y=$,$.sourcesTail=null,$.flags=_$;let X;try{X=$.fn($.value,Z.signal)}catch(j){$.controller=void 0,$.error=j instanceof Error?j:Error(String(j));return}finally{Y=J,P$($)}X.then((j)=>{if(Z.signal.aborted)return;if($.controller=void 0,$.error||!$.equals(j,$.value)){$.value=j,$.error=void 0;for(let Q=$.sinks;Q;Q=Q.nextSink)w(Q.sink);if(A===0)L()}},(j)=>{if(Z.signal.aborted)return;$.controller=void 0;let Q=j instanceof Error?j:Error(String(j));if(!$.error||Q.name!==$.error.name||Q.message!==$.error.message){$.error=Q;for(let M=$.sinks;M;M=M.nextSink)w(M.sink);if(A===0)L()}}),$.flags=p}function BZ($){d$($);let Z=Y,J=c;Y=c=$,$.sourcesTail=null,$.flags=_$;try{let X=$.fn();if(typeof X==="function")G$($,X)}finally{Y=Z,c=J,P$($)}$.flags=p}function T($){if($.flags&V$)for(let Z=$.sources;Z;Z=Z.nextSource){if("fn"in Z.source)T(Z.source);if($.flags&F)break}if($.flags&_$)throw new U$("controller"in $?e:("value"in $)?a:"Effect");if($.flags&F)if("controller"in $)kZ($);else if("value"in $)fZ($);else BZ($);else $.flags=p}function L(){if(WZ)return;WZ=!0;try{for(let $=0;$<v$.length;$++){let Z=v$[$];if(Z.flags&(F|V$))T(Z)}v$.length=0}finally{WZ=!1}}function i($){A++;try{$()}finally{if(A--,A===0)L()}}function l($){let Z=Y;Y=null;try{return $()}finally{Y=Z}}function H$($){let Z=c,J={cleanup:null};c=J;try{let X=$();if(typeof X==="function")G$(J,X);let j=()=>d$(J);if(Z)G$(Z,j);return j}finally{c=Z}}function f($,Z){x(t,$,Z?.guard);let J={value:$,sinks:null,sinksTail:null,equals:Z?.equals??s,guard:Z?.guard};return{[Symbol.toStringTag]:t,get(){if(Y)O(J,Y);return J.value},set(X){x(t,X,J.guard),T$(J,X)},update(X){h(t,X);let j=X(J.value);x(t,j,J.guard),T$(J,j)}}}function x$($){return S($,t)}function j$($,Z,J){if(Object.is($,Z))return!0;if(typeof $!==typeof Z)return!1;if($==null||typeof $!=="object"||Z==null||typeof Z!=="object")return!1;if(!J)J=new WeakSet;if(J.has($)||J.has(Z))throw new U$("isEqual");J.add($),J.add(Z);try{let X=Array.isArray($);if(X!==Array.isArray(Z))return!1;if(X){let j=$,Q=Z;if(j.length!==Q.length)return!1;for(let M=0;M<j.length;M++)if(!j$(j[M],Q[M],J))return!1;return!0}if(_($)&&_(Z)){let j=Object.keys($),Q=Object.keys(Z);if(j.length!==Q.length)return!1;for(let M of j){if(!(M in Z))return!1;if(!j$($[M],Z[M],J))return!1}return!0}return!1}finally{J.delete($),J.delete(Z)}}function c$($,Z){if($.length!==Z.length)return!1;for(let J=0;J<$.length;J++)if($[J]!==Z[J])return!1;return!0}function zZ($){let Z=0,J=typeof $==="function";return[typeof $==="string"?()=>`${$}${Z++}`:J?(X)=>$(X)||String(Z++):()=>String(Z++),J]}function hZ($,Z,J,X,j){let Q=new WeakSet,M={},q={},z={},U=[],B=!1,W=new Map;for(let V=0;V<$.length;V++){let H=J[V];if(H&&$[V])W.set(H,$[V])}let K=new Set;for(let V=0;V<Z.length;V++){let H=Z[V];if(H===void 0)continue;let G=j?X(H):J[V]??X(H);if(K.has(G))throw new M$(g,G,H);if(U.push(G),K.add(G),!W.has(G))M[G]=H,B=!0;else if(!j$(W.get(G),H,Q))q[G]=H,B=!0}for(let[V]of W)if(!K.has(V))z[V]=null,B=!0;if(!B&&!c$(J,U))B=!0;return{add:M,change:q,remove:z,newKeys:U,changed:B}}function I$($,Z){x(g,$,Array.isArray);let J=new Map,X=[],[j,Q]=zZ(Z?.keyConfig),M=()=>X.map((H)=>J.get(H)?.get()).filter((H)=>H!==void 0),q={fn:M,value:$,flags:F,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:j$,error:void 0},z=(H)=>{let G={};for(let C=0;C<H.length;C++){let D=H[C];if(D===void 0)continue;let N=X[C];if(!N)N=j(D),X[C]=N;G[N]=D}return G},U=(H)=>{let G=!1;for(let C in H.add){let D=H.add[C];x(`${g} item for key "${C}"`,D),J.set(C,f(D)),G=!0}if(Object.keys(H.change).length)i(()=>{for(let C in H.change){let D=H.change[C];x(`${g} item for key "${C}"`,D);let N=J.get(C);if(N)N.set(D)}});for(let C in H.remove){J.delete(C);let D=X.indexOf(C);if(D!==-1)X.splice(D,1);G=!0}if(G)q.flags|=y;return H.changed},B=Z?.watched,W=B?()=>{if(Y){if(!q.sinks)q.stop=B();O(q,Y)}}:()=>{if(Y)O(q,Y)},K=z($);for(let H in K){let G=K[H];x(`${g} item for key "${H}"`,G),J.set(H,f(G))}q.value=$,q.flags=0;let V={[Symbol.toStringTag]:g,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let H of X){let G=J.get(H);if(G)yield G}},get length(){return W(),X.length},get(){if(W(),q.sources){if(q.flags){let H=q.flags&y;if(q.value=l(M),H){if(q.flags=F,T(q),q.error)throw q.error}else q.flags=p}}else if(T(q),q.error)throw q.error;return q.value},set(H){let G=q.flags&F?M():q.value,C=hZ(G,H,X,j,Q);if(C.changed){X=C.newKeys,U(C),q.flags|=F;for(let D=q.sinks;D;D=D.nextSink)w(D.sink);if(A===0)L()}},update(H){V.set(H(V.get()))},at(H){return J.get(X[H])},keys(){return W(),X.values()},byKey(H){return J.get(H)},keyAt(H){return X[H]},indexOfKey(H){return X.indexOf(H)},add(H){let G=j(H);if(J.has(G))throw new M$(g,G,H);if(!X.includes(G))X.push(G);x(`${g} item for key "${G}"`,H),J.set(G,f(H)),q.flags|=F|y;for(let C=q.sinks;C;C=C.nextSink)w(C.sink);if(A===0)L();return G},remove(H){let G=typeof H==="number"?X[H]:H;if(J.delete(G)){let D=typeof H==="number"?H:X.indexOf(G);if(D>=0)X.splice(D,1);q.flags|=F|y;for(let N=q.sinks;N;N=N.nextSink)w(N.sink);if(A===0)L()}},sort(H){let C=X.map((D)=>[D,J.get(D)?.get()]).sort(P(H)?(D,N)=>H(D[1],N[1]):(D,N)=>String(D[1]).localeCompare(String(N[1]))).map(([D])=>D);if(!c$(X,C)){X=C,q.flags|=F;for(let D=q.sinks;D;D=D.nextSink)w(D.sink);if(A===0)L()}},splice(H,G,...C){let D=X.length,N=H<0?Math.max(0,D+H):Math.min(H,D),I=Math.max(0,Math.min(G??Math.max(0,D-Math.max(0,N)),D-N)),b={},k={};for(let v=0;v<I;v++){let q$=N+v,QZ=X[q$];if(QZ){let DZ=J.get(QZ);if(DZ)k[QZ]=DZ.get()}}let jZ=X.slice(0,N);for(let v of C){let q$=j(v);if(J.has(q$)&&!(q$ in k))throw new M$(g,q$,v);jZ.push(q$),b[q$]=v}jZ.push(...X.slice(N+I));let YZ=!!(Object.keys(b).length||Object.keys(k).length);if(YZ){U({add:b,change:{},remove:k,changed:YZ}),X=jZ,q.flags|=F;for(let v=q.sinks;v;v=v.nextSink)w(v.sink);if(A===0)L()}return Object.values(k)},deriveCollection(H){return u$(V,H)}};return V}function S$($){return S($,g)}function r($,Z){if(h(a,$,D$),Z?.value!==void 0)x(a,Z.value,Z?.guard);let J={fn:$,value:Z?.value,flags:F,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:Z?.equals??s,error:void 0,stop:void 0},X=Z?.watched,j=X?()=>{if(Y){if(!J.sinks)J.stop=X(()=>{if(w(J),A===0)L()});O(J,Y)}}:()=>{if(Y)O(J,Y)};return{[Symbol.toStringTag]:a,get(){if(j(),T(J),J.error)throw J.error;return N$(a,J.value),J.value}}}function B$($){return S($,a)}function O$($,Z){if(h(e,$,Q$),Z?.value!==void 0)x(e,Z.value,Z?.guard);let J={fn:$,value:Z?.value,sources:null,sourcesTail:null,sinks:null,sinksTail:null,flags:F,equals:Z?.equals??s,controller:void 0,error:void 0,stop:void 0},X=Z?.watched,j=X?()=>{if(Y){if(!J.sinks)J.stop=X(()=>{if(w(J),A===0)L()});O(J,Y)}}:()=>{if(Y)O(J,Y)};return{[Symbol.toStringTag]:e,get(){if(j(),T(J),J.error)throw J.error;return N$(e,J.value),J.value},isPending(){return!!J.controller},abort(){J.controller?.abort(),J.controller=void 0}}}function o$($){return S($,e)}function u$($,Z){h(Z$,Z);let J=Q$(Z),X=new Map,j=[],Q=(V)=>{let H=J?O$(async(G,C)=>{let D=$.byKey(V)?.get();if(D==null)return G;return Z(D,C)}):r(()=>{let G=$.byKey(V)?.get();if(G==null)return;return Z(G)});X.set(V,H)};function M(V){if(!c$(j,V)){let H=new Set(j),G=new Set(V);for(let C of j)if(!G.has(C))X.delete(C);for(let C of V)if(!H.has(C))Q(C);j=V,U.flags|=y}}function q(){M(Array.from($.keys()));let V=[];for(let H of j)try{let G=X.get(H)?.get();if(G!=null)V.push(G)}catch(G){if(!(G instanceof W$))throw G}return V}let U={fn:q,value:[],flags:F,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:(V,H)=>{if(V.length!==H.length)return!1;for(let G=0;G<V.length;G++)if(V[G]!==H[G])return!1;return!0},error:void 0};function B(){if(U.sources){if(U.flags)if(U.value=l(q),U.flags&y){if(U.flags=F,T(U),U.error)throw U.error}else U.flags=p}else if(U.sinks){if(T(U),U.error)throw U.error}else U.value=l(q)}let W=Array.from(l(()=>$.keys()));for(let V of W)Q(V);j=W;let K={[Symbol.toStringTag]:Z$,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let V of j){let H=X.get(V);if(H)yield H}},get length(){if(Y)O(U,Y);return B(),j.length},keys(){if(Y)O(U,Y);return B(),j.values()},get(){if(Y)O(U,Y);return B(),U.value},at(V){return X.get(j[V])},byKey(V){return X.get(V)},keyAt(V){return j[V]},indexOfKey(V){return j.indexOf(V)},deriveCollection(V){return u$(K,V)}};return K}function NZ($,Z){let J=Z?.value??[];if(J.length)x(Z$,J,Array.isArray);h(Z$,$,D$);let X=new Map,j=[],Q=new Map,[M,q]=zZ(Z?.keyConfig),z=(H)=>Q.get(H)??(q?M(H):void 0),U=Z?.createItem??f;function B(){let H=[];for(let G of j)try{let C=X.get(G)?.get();if(C!=null)H.push(C)}catch(C){if(!(C instanceof W$))throw C}return H}let W={fn:B,value:J,flags:F,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:HZ,error:void 0};for(let H of J){let G=M(H);X.set(G,U(H)),Q.set(H,G),j.push(G)}W.value=J,W.flags=F;function K(){if(Y){if(!W.sinks)W.stop=$((H)=>{let{add:G,change:C,remove:D}=H;if(!G?.length&&!C?.length&&!D?.length)return;let N=!1;i(()=>{if(G)for(let I of G){let b=M(I);if(X.set(b,U(I)),Q.set(I,b),!j.includes(b))j.push(b);N=!0}if(C)for(let I of C){let b=z(I);if(!b)continue;let k=X.get(b);if(k&&x$(k))Q.delete(k.get()),k.set(I),Q.set(I,b)}if(D)for(let I of D){let b=z(I);if(!b)continue;Q.delete(I),X.delete(b);let k=j.indexOf(b);if(k!==-1)j.splice(k,1);N=!0}W.flags=F|(N?y:0);for(let I=W.sinks;I;I=I.nextSink)w(I.sink)})});O(W,Y)}}let V={[Symbol.toStringTag]:Z$,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let H of j){let G=X.get(H);if(G)yield G}},get length(){return K(),j.length},keys(){return K(),j.values()},get(){if(K(),W.sources){if(W.flags){let H=W.flags&y;if(W.value=l(B),H){if(W.flags=F,T(W),W.error)throw W.error}else W.flags=p}}else if(T(W),W.error)throw W.error;return W.value},at(H){return X.get(j[H])},byKey(H){return X.get(H)},keyAt(H){return j[H]},indexOfKey(H){return j.indexOf(H)},deriveCollection(H){return u$(V,H)}};return V}function PZ($){return S($,Z$)}function b$($){h("Effect",$);let Z={fn:$,flags:F,sources:null,sourcesTail:null,cleanup:null},J=()=>{d$(Z),Z.fn=void 0,Z.flags=p,Z.sourcesTail=null,P$(Z)};if(c)G$(c,J);return BZ(Z),J}function xZ($,Z){if(!c)throw new p$("match");let{ok:J,err:X=console.error,nil:j}=Z,Q,M=!1,q=Array($.length);for(let U=0;U<$.length;U++)try{q[U]=$[U].get()}catch(B){if(B instanceof W$){M=!0;continue}if(!Q)Q=[];Q.push(B instanceof Error?B:Error(String(B)))}let z;try{if(M)z=j?.();else if(Q)z=X(Q);else z=J(q)}catch(U){X([U instanceof Error?U:Error(String(U))])}if(typeof z==="function")return z;if(z instanceof Promise){let U=c,B=new AbortController;G$(U,()=>B.abort()),z.then((W)=>{if(!B.signal.aborted&&typeof W==="function")G$(U,W)}).catch((W)=>{X([W instanceof Error?W:Error(String(W))])})}}function s$($,Z){if(h($$,$,D$),Z?.value!==void 0)x($$,Z.value,Z?.guard);let J={value:Z?.value,sinks:null,sinksTail:null,equals:Z?.equals??s,guard:Z?.guard,stop:void 0};return{[Symbol.toStringTag]:$$,get(){if(Y){if(!J.sinks)J.stop=$((X)=>{x($$,X,J.guard),T$(J,X)});O(J,Y)}return N$($$,J.value),J.value}}}function IZ($){return S($,$$)}function gZ($,Z){let J=_($)||Array.isArray($),X=_(Z)||Array.isArray(Z);if(!J||!X){let W=!Object.is($,Z);return{changed:W,add:W&&X?Z:{},change:{},remove:W&&J?$:{}}}let j=new WeakSet,Q={},M={},q={},z=!1,U=Object.keys($),B=Object.keys(Z);for(let W of B)if(W in $){if(!j$($[W],Z[W],j))M[W]=Z[W],z=!0}else Q[W]=Z[W],z=!0;for(let W of U)if(!(W in Z))q[W]=void 0,z=!0;return{add:Q,change:M,remove:q,changed:z}}function y$($,Z){x(J$,$,_);let J=new Map,X=(B,W)=>{if(x(`${J$} for key "${B}"`,W),Array.isArray(W))J.set(B,I$(W));else if(_(W))J.set(B,y$(W));else J.set(B,f(W))},j=()=>{let B={};return J.forEach((W,K)=>{B[K]=W.get()}),B},Q={fn:j,value:$,flags:F,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:j$,error:void 0},M=(B)=>{let W=!1;for(let K in B.add)X(K,B.add[K]),W=!0;if(Object.keys(B.change).length)i(()=>{for(let K in B.change){let V=B.change[K];x(`${J$} for key "${K}"`,V);let H=J.get(K);if(H)if(_(V)!==m$(H))X(K,V),W=!0;else H.set(V)}});for(let K in B.remove)J.delete(K),W=!0;if(W)Q.flags|=y;return B.changed},q=Z?.watched,z=q?()=>{if(Y){if(!Q.sinks)Q.stop=q();O(Q,Y)}}:()=>{if(Y)O(Q,Y)};for(let B of Object.keys($))X(B,$[B]);let U={[Symbol.toStringTag]:J$,[Symbol.isConcatSpreadable]:!1,*[Symbol.iterator](){for(let B of Array.from(J.keys())){let W=J.get(B);if(W)yield[B,W]}},keys(){return z(),J.keys()},byKey(B){return J.get(B)},get(){if(z(),Q.sources){if(Q.flags){let B=Q.flags&y;if(Q.value=l(j),B){if(Q.flags=F,T(Q),Q.error)throw Q.error}else Q.flags=p}}else if(T(Q),Q.error)throw Q.error;return Q.value},set(B){let W=Q.flags&F?j():Q.value,K=gZ(W,B);if(M(K)){Q.flags|=F;for(let V=Q.sinks;V;V=V.nextSink)w(V.sink);if(A===0)L()}},update(B){U.set(B(U.get()))},add(B,W){if(J.has(B))throw new M$(J$,B,W);X(B,W),Q.flags|=F|y;for(let K=Q.sinks;K;K=K.nextSink)w(K.sink);if(A===0)L();return B},remove(B){if(J.delete(B)){Q.flags|=F|y;for(let K=Q.sinks;K;K=K.nextSink)w(K.sink);if(A===0)L()}}};return new Proxy(U,{get(B,W){if(W in B)return Reflect.get(B,W);if(typeof W!=="symbol")return B.byKey(W)},has(B,W){if(W in B)return!0;return B.byKey(String(W))!==void 0},ownKeys(B){return Array.from(B.keys())},getOwnPropertyDescriptor(B,W){if(W in B)return Reflect.getOwnPropertyDescriptor(B,W);if(typeof W==="symbol")return;let K=B.byKey(String(W));return K?{enumerable:!0,configurable:!0,writable:!0,value:K}:void 0}})}function m$($){return S($,J$)}function A$($,Z){return Q$($)?O$($,Z):r($,Z)}function OZ($){if(K$($))return $;if($==null||P($)||d($))throw new F$("createMutableSignal",$);if(FZ($))return I$($);if(_($))return y$($);return f($)}function i$($){return B$($)||o$($)}function d($){let Z=[t,a,e,$$,X$,g,Z$,J$],J=Object.prototype.toString.call($).slice(8,-1);return Z.includes(J)}function K$($){return x$($)||m$($)||S$($)}function l$($,Z){x(X$,$,d);let J=$,X=Z?.guard,j={fn:()=>J.get(),value:void 0,flags:F,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:Z?.equals??s,error:void 0},Q=()=>{if(Y)O(j,Y);if(T(j),j.error)throw j.error;return j.value},M=(z)=>{if(!K$(J))throw new g$(X$);x(X$,z,X),J.set(z)},q=(z)=>{x(X$,z,d),J=z,j.flags|=F;for(let U=j.sinks;U;U=U.nextSink)w(U.sink);if(A===0)L()};return{[Symbol.toStringTag]:X$,configurable:!0,enumerable:!0,get:Q,set:M,replace:q,current:()=>J}}function w$($){return S($,X$)}var u=!1,pZ="debug";var z$="warn",R$="error",vZ=new Set(["constructor","prototype"]),dZ=new Set(["id","class","className","title","role","style","dataset","lang","dir","hidden","children","innerHTML","outerHTML","textContent","innerText"]),cZ=($)=>$?`#${$}`:"",uZ=($)=>$?.length?`.${Array.from($).join(".")}`:"";var qZ=($)=>$.localName.includes("-"),UZ=($)=>qZ($)&&$.matches(":not(:defined)"),R=($)=>$?`<${$.localName}${cZ($.id)}${uZ($.classList)}>`:"<unknown>";var C$=($,Z,J=pZ)=>{if(u||[R$,z$].includes(J))console[J](Z,$);return $},AZ=($)=>{if(vZ.has($))return`Property name "${$}" is a reserved word`;if(dZ.has($))return`Property name "${$}" conflicts with inherited HTMLElement property`;return null};class r$ extends TypeError{constructor($){super(`Invalid component name "${$}". Custom element names must contain a hyphen, start with a lowercase letter, and contain only lowercase letters, numbers, and hyphens.`);this.name="InvalidComponentNameError"}}class n$ extends TypeError{constructor($,Z,J){super(`Invalid property name "${Z}" for component <${$}>. ${J}`);this.name="InvalidPropertyNameError"}}class t$ extends TypeError{constructor($,Z){super(`Invalid effects in component ${R($)}. Effects must be a record of effects for UI elements or the component, or a Promise that resolves to effects.`);if(this.name="InvalidEffectsError",Z)this.cause=Z}}class wZ extends TypeError{constructor($,Z,J){super(`Invalid UI key "${Z}" in ${J} of component ${R($)}`);this.name="InvalidUIKeyError"}}class E$ extends Error{constructor($,Z,J){super(`Missing required element <${Z}> in component ${R($)}. ${J}`);this.name="MissingElementError"}}class a$ extends Error{constructor($,Z){super(`Timeout waiting for: [${Z.join(", ")}] in component ${R($)}.`);this.name="DependencyTimeoutError"}}class e$ extends TypeError{constructor($,Z,J){super(`Expected reactives passed from ${R($)} to ${R(Z)} to be a record of signals, reactive property names or functions. Got ${n(J)}.`);this.name="InvalidReactivesError"}}class $Z extends TypeError{constructor($,Z){super(`Target ${R($)} is not a custom element in ${Z}.`);this.name="InvalidCustomElementError"}}var oZ=($,Z="")=>{return{a:"attribute ",c:"class ",d:"dataset ",h:"inner HTML",m:"method call ",p:"property ",s:"style property ",t:"text content"}[$]+Z},RZ=($,Z)=>{if(!_(Z))throw new t$($.host);return H$(()=>{for(let J of Object.keys(Z)){let X=J;if(!Z[X])continue;let j=Array.isArray(Z[X])?Z[X]:[Z[X]];if(B$($[X]))b$(()=>{for(let Q of $[X].get())for(let M of j)M($.host,Q)});else if($[X])for(let Q of j)Q($.host,$[X])}})},sZ=($,Z,J,X)=>{try{if(typeof $==="string"){if(u&&!($ in Z))C$($,`resolveReactive: property '${$}' does not exist on ${R(Z)}`,z$);return Z[$]}return d($)?$.get():P($)?$(J):void 0}catch(j){if(X)C$(j,`Failed to resolve value of ${n($)}${X?` for ${X}`:""} in ${R(J)}${Z!==J?` in ${R(Z)}`:""}`,R$);return}},m=($,Z)=>(J,X)=>{let{op:j,name:Q="",read:M,update:q}=Z,z=oZ(j,Q),U=(K)=>()=>{if(u&&J.debug)C$(X,`${K} ${z} of ${R(X)} in ${R(J)}`);Z.resolve?.(X)},B=(K)=>(V)=>{C$(V,`Failed to ${K} ${z} of ${R(X)} in ${R(J)}`,R$),Z.reject?.(V)},W=M(X);return b$(()=>{let K=sZ($,J,X,z),V=K===void 0?W:K===null?Z.delete?null:W:K;if(Z.delete&&V===null)try{Z.delete(X),U("delete")()}catch(H){B("delete")(H)}else if(V!=null){let H=M(X);if(Object.is(V,H))return;try{q(X,V),U("update")()}catch(G){B("update")(G)}}})};var LZ=new WeakMap,f$=($)=>{let Z=LZ.get($);if(!Z)Z={},LZ.set($,Z);return Z};var _Z=Symbol("parser"),TZ=Symbol("method"),L$=($)=>{if(!P($))return!1;if(_Z in $)return!0;if($.length>=2){if(u)console.warn("isParser: unbranded two-argument function detected. Wrap custom parsers with asParser() to avoid misclassification when using default parameters or destructuring.",$);return!0}return!1},MZ=($)=>P($)&&(TZ in $),iZ=($)=>P($),E=($,Z)=>iZ(Z)?Z($):Z,o=($)=>Object.assign($,{[_Z]:!0}),VZ=($)=>Object.assign($,{[TZ]:!0}),lZ=($,Z)=>(J)=>{let X=$(J);return typeof X==="string"&&L$(Z)?Z(J,X):X??E(J,Z)};var rZ=200,nZ=($)=>{let Z=new Set;if($.includes("."))Z.add("class");if($.includes("#"))Z.add("id");if($.includes("[")){let J=$.split("[");for(let X=1;X<J.length;X++){let j=J[X];if(!j.includes("]"))continue;let Q=j.split("=")[0].trim().replace(/[^a-zA-Z0-9_-]/g,"");if(Q)Z.add(Q)}}return[...Z]};function SZ($,Z){return r(()=>Array.from($.querySelectorAll(Z)),{value:[],equals:(J,X)=>J.length===X.length&&J.every((j,Q)=>j===X[Q]),watched:(J)=>{let X={childList:!0,subtree:!0},j=nZ(Z);if(j.length)X.attributes=!0,X.attributeFilter=j;let Q=(z)=>z instanceof Element&&(z.matches(Z)||z.querySelector(Z)),M=(z)=>{if(z.type==="attributes")return!0;if(z.type==="childList")return Array.from(z.addedNodes).some(Q)||Array.from(z.removedNodes).some(Q);return!1},q=new MutationObserver((z)=>{for(let U of z)if(M(U)){J();return}});return q.observe($,X),()=>q.disconnect()}})}var bZ=($)=>{let Z=$.shadowRoot??$,J=new Set;function X(M,q){let z=Z.querySelector(M);if(q!=null&&!z)throw new E$($,M,q);if(z&&UZ(z))J.add(z.localName);return z??void 0}function j(M,q){let z=SZ(Z,M),U=z.get();if(q!=null&&!U.length)throw new E$($,M,q);if(U.length){for(let B of U)if(UZ(B))J.add(B.localName)}return z}return[{first:X,all:j},(M)=>{if(J.size)queueMicrotask(()=>{let q=Array.from(J).filter((z)=>!customElements.get(z));if(!q.length){M();return}Promise.race([Promise.all(q.map((z)=>customElements.whenDefined(z))),new Promise((z,U)=>{setTimeout(()=>{U(new a$($,q.filter((B)=>!customElements.get(B))))},rZ)})]).then(M).catch((z)=>{if(u)console[z$](z);M()})});else M()}]};function tZ($,Z={},J=()=>({}),X=()=>({})){if(!$.includes("-")||!$.match(/^[a-z][a-z0-9-]*$/))throw new r$($);for(let Q of Object.keys(Z)){let M=AZ(Q);if(M)throw new n$($,Q,M)}class j extends HTMLElement{debug;#$;#J;static observedAttributes=Object.entries(Z)?.filter(([,Q])=>L$(Q)).map(([Q])=>Q)??[];connectedCallback(){let[Q,M]=bZ(this),q={...J(Q),host:this};this.#$=q,Object.freeze(this.#$);let z=[],U=(B,W)=>{if(L$(W)){let K=W(q,this.getAttribute(B));if(K!=null)this.#Z(B,K)}else if(MZ(W)){let K=W(q);if(P(K))z.push(K)}else if(P(W)){let K=W(q);if(K!=null)this.#Z(B,K)}else{let K=W;if(K!=null)this.#Z(B,K)}};for(let[B,W]of Object.entries(Z)){if(W==null||B in this)continue;U(B,W)}M(()=>{let B=RZ(q,X(q));this.#J=z.length?()=>{for(let W of z)W();B()}:B})}disconnectedCallback(){if(P(this.#J))this.#J()}attributeChangedCallback(Q,M,q){if(!this.#$||q===M||i$(f$(this)[Q]))return;let z=Z[Q];if(!L$(z))return;let U=z(this.#$,q,M);if(Q in this)this[Q]=U;else this.#Z(Q,U)}#Z(Q,M){let q=d(M)?M:P(M)?A$(M):f(M),z=f$(this),U=Q,B=z[U];if(w$(B))B.replace(q);else if(K$(q)){let W=l$(q);z[U]=W,Object.defineProperty(this,Q,W)}else z[U]=q,Object.defineProperty(this,Q,{get:q.get,enumerable:!0})}}return customElements.define($,j),customElements.get($)}var ZZ="context-request";class GZ extends Event{context;callback;subscribe;constructor($,Z,J=!1){super(ZZ,{bubbles:!0,composed:!0});this.context=$,this.callback=Z,this.subscribe=J}}var aZ=($)=>VZ((Z)=>{let J=(X)=>{let{context:j,callback:Q}=X;if(typeof j==="string"&&$.includes(j)&&P(Q))X.stopImmediatePropagation(),Q(()=>Z[j])};return Z.addEventListener(ZZ,J),()=>Z.removeEventListener(ZZ,J)}),eZ=($,Z)=>(J)=>{let X=()=>E(J,Z);return J.host.dispatchEvent(new GZ($,(j)=>{X=j})),r(X)};var $4=($)=>{if(/^(mailto|tel):/i.test($))return!0;if($.includes("://"))try{let Z=new URL($,window.location.origin);return["http:","https:","ftp:"].includes(Z.protocol)}catch{return!1}return!0},Z4=($,Z,J)=>{if(/^on/i.test(Z))throw Error(`setAttribute: blocked unsafe attribute name '${Z}' on ${$.localName} — event handler attributes are not allowed`);if(J=String(J).trim(),!$4(J))throw Error(`setAttribute: blocked unsafe value for '${Z}' on <${$.localName}>: '${J}'`);$.setAttribute(Z,J)},J4=($,Z=$)=>m(Z,{op:"a",name:$,read:(J)=>J.getAttribute($),update:(J,X)=>{Z4(J,$,X)},delete:(J)=>{J.removeAttribute($)}}),X4=($,Z=$)=>m(Z,{op:"a",name:$,read:(J)=>J.hasAttribute($),update:(J,X)=>{J.toggleAttribute($,X)}});var j4=($,Z=$)=>m(Z,{op:"c",name:$,read:(J)=>J.classList.contains($),update:(J,X)=>{J.classList.toggle($,X)}});var XZ=new Set(["scroll","resize","mousewheel","touchstart","touchmove","wheel"]),KZ=new Set,yZ=new WeakMap,JZ,Q4=()=>{JZ=void 0;let $=Array.from(KZ);KZ.clear();for(let Z of $)yZ.get(Z)?.()},W4=()=>{if(JZ)cancelAnimationFrame(JZ);JZ=requestAnimationFrame(Q4)},Y$=($,Z)=>{yZ.set($,Z),KZ.add($),W4()};var H4=($,Z,J={})=>(X,j)=>H$(()=>{if(!("passive"in J))J={...J,passive:XZ.has($)};let Q=(M)=>{let q=()=>{let z=Z(M);if(!_(z))return;i(()=>{for(let[U,B]of Object.entries(z))try{X[U]=B}catch(W){C$(W,`Reactive property "${U}" on ${R(X)} from event ${$} on ${R(j)} could not be set, because it is read-only.`,R$)}})};if(J.passive)Y$(j,q);else q()};return j.addEventListener($,Q,J),()=>j.removeEventListener($,Q)});var B4=($,Z={})=>m($,{op:"h",read:(J)=>(J.shadowRoot||!Z.shadowRootMode?J:null)?.innerHTML??"",update:(J,X)=>{let{shadowRootMode:j,allowScripts:Q}=Z;if(!X){if(J.shadowRoot)J.shadowRoot.innerHTML="<slot></slot>";return""}if(j&&!J.shadowRoot)J.attachShadow({mode:j});let M=J.shadowRoot||J;return Y$(J,()=>{if(M.innerHTML=X,Q){let q=["type","src","async","defer","nomodule","crossorigin","integrity","referrerpolicy","fetchpriority"];M.querySelectorAll("script").forEach((z)=>{let U=document.createElement("script");for(let B of q)if(z.hasAttribute(B))U.setAttribute(B,z.getAttribute(B));if(!z.hasAttribute("src"))U.appendChild(document.createTextNode(z.textContent??""));M.appendChild(U),z.remove()})}}),Q?" with scripts":""}});var z4=($)=>(Z,J)=>H$(()=>{if(!qZ(J))throw new $Z(J,`pass from ${R(Z)}`);let X=P($)?$(J):$;if(!_(X))throw new e$(Z,J,X);let j=(z)=>{if(d(z))return z;let U=typeof z==="string"&&z in Z?()=>Z[z]:P(z)?z:void 0;return U?A$(U):void 0},Q=f$(J),M=R(J),q=[];for(let[z,U]of Object.entries(X)){if(U==null)continue;if(!(z in J)){if(u)console[z$](`pass(): property '${z}' does not exist on ${M}`);continue}let B=P(U)&&U.length===1?U(J):U,W=Array.isArray(B)&&B.length===2,K=j(W?B[0]:B);if(!K)continue;let V=Q[z];if(w$(V)){let C=V.current();V.replace(K),q.push(()=>V.replace(C));continue}let H=Object.getOwnPropertyDescriptor(J,z)??Object.getOwnPropertyDescriptor(Object.getPrototypeOf(J),z);if(!H)continue;if(!H.configurable){if(u)console[z$](`pass(): property '${z}' on ${M} has a non-configurable descriptor — binding skipped`);continue}let G=W?B[1]:void 0;Object.defineProperty(J,z,{get:()=>K.get(),set:G,configurable:!0,enumerable:H.enumerable??!0}),q.push(()=>Object.defineProperty(J,z,H))}if(q.length)return()=>{for(let z of q)z()}});var q4=($,Z=$)=>m(Z,{op:"p",name:$,read:(J)=>($ in J)?J[$]??null:null,update:(J,X)=>{J[$]=X}}),U4=($)=>m($,{op:"p",name:"hidden",read:(Z)=>!Z.hidden,update:(Z,J)=>{Z.hidden=!J}});var M4=($,Z=$)=>m(Z,{op:"s",name:$,read:(J)=>J.style.getPropertyValue($),update:(J,X)=>{J.style.setProperty($,X)},delete:(J)=>{J.style.removeProperty($)}});var V4=($)=>m($,{op:"t",read:(Z)=>Z.textContent,update:(Z,J)=>{Array.from(Z.childNodes).filter((X)=>X.nodeType!==Node.COMMENT_NODE).forEach((X)=>X.remove()),Z.append(document.createTextNode(J))}});var G4=($,Z,J)=>(X)=>{let{host:j}=X,Q=E(X,$),M=B$(X[Z])?X[Z]:null,q=M?null:X[Z],z=new Map,U=(B)=>{if(q)return q.contains(B)?q:void 0;for(let W of M.get())if(W.contains(B))return W};return s$((B)=>{for(let[W,K]of Object.entries(J)){let V={passive:XZ.has(W)},H=(G)=>{let C=G.target;if(!C)return;let D=U(C);if(!D)return;G.stopPropagation();let N=()=>{try{let I=K({event:G,ui:X,target:D,prev:Q});if(I==null||I instanceof Promise)return;if(!Object.is(I,Q))Q=I,B(I)}catch(I){throw G.stopImmediatePropagation(),I}};if(V.passive)Y$(j,N);else N()};z.set(W,H),j.addEventListener(W,H,V)}return()=>{if(z.size){for(let[W,K]of z)j.removeEventListener(W,K);z.clear()}}},{value:Q})};var K4=()=>o(($,Z)=>Z!=null&&Z!=="false");var C4=($)=>o((Z,J)=>{if((J??$)==null)throw TypeError("asJSON: Value and fallback are both null or undefined");if(J==null)return E(Z,$);if(J==="")throw TypeError("Empty string is not valid JSON");let X;try{X=JSON.parse(J)}catch(j){throw SyntaxError(`Failed to parse JSON: ${String(j)}`,{cause:j})}return X??E(Z,$)});var CZ=($,Z)=>{if(Z==null)return;let J=$(Z);return Number.isFinite(J)?J:void 0},Y4=($=0)=>o((Z,J)=>{if(J==null)return E(Z,$);let X=J.trim();if(X.toLowerCase().startsWith("0x"))return CZ((Q)=>parseInt(Q,16),X)??E(Z,$);let j=CZ(parseFloat,J);return j!=null?Math.trunc(j):E(Z,$)}),D4=($=0)=>o((Z,J)=>CZ(parseFloat,J)??E(Z,$));var F4=($="")=>o((Z,J)=>J??E(Z,$)),N4=($)=>o((Z,J)=>{if(J==null)return $[0];let X=J.toLowerCase();return $.find((Q)=>Q.toLowerCase()===X)?J:$[0]});export{n as valueString,m as updateElement,j4 as toggleClass,X4 as toggleAttribute,U4 as show,V4 as setText,M4 as setStyle,q4 as setProperty,J4 as setAttribute,Y$ as schedule,eZ as requestContext,lZ as read,aZ as provideContexts,z4 as pass,H4 as on,xZ as match,o$ as isTask,m$ as isStore,x$ as isState,w$ as isSlot,d as isSignal,IZ as isSensor,_ as isRecord,L$ as isParser,K$ as isMutableSignal,MZ as isMethodProducer,B$ as isMemo,S$ as isList,P as isFunction,j$ as isEqual,i$ as isComputed,PZ as isCollection,Q$ as isAsyncFunction,tZ as defineComponent,B4 as dangerouslySetInnerHTML,O$ as createTask,y$ as createStore,f as createState,l$ as createSlot,s$ as createSensor,H$ as createScope,OZ as createMutableSignal,r as createMemo,I$ as createList,G4 as createEventsSensor,SZ as createElementsMemo,b$ as createEffect,A$ as createComputed,NZ as createCollection,i as batch,F4 as asString,o as asParser,D4 as asNumber,VZ as asMethod,C4 as asJSON,Y4 as asInteger,N4 as asEnum,K4 as asBoolean,k$ as NullishSignalValueError,E$ as MissingElementError,wZ as InvalidUIKeyError,F$ as InvalidSignalValueError,e$ as InvalidReactivesError,n$ as InvalidPropertyNameError,t$ as InvalidEffectsError,$Z as InvalidCustomElementError,r$ as InvalidComponentNameError,h$ as InvalidCallbackError,a$ as DependencyTimeoutError,GZ as ContextRequestEvent,U$ as CircularDependencyError,ZZ as CONTEXT_REQUEST};

//# debugId=A3FD9C1D20FBBE1C64756E2164756E21
