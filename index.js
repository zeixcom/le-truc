class y extends Error{constructor($){super(`Circular dependency detected in ${$}`);this.name="CircularDependencyError"}}class $$ extends TypeError{constructor($,B){super(`Invalid signal value ${B} in ${$}`);this.name="InvalidSignalValueError"}}class p extends TypeError{constructor($){super(`Nullish signal values are not allowed in ${$}`);this.name="NullishSignalValueError"}}class B$ extends Error{constructor($,B){super(`Could not add store key "${$}" with value ${B} because it already exists`);this.name="StoreKeyExistsError"}}class X$ extends RangeError{constructor($){super(`Could not remove store index ${String($)} because it is out of range`);this.name="StoreKeyRangeError"}}class Z$ extends Error{constructor($,B){super(`Could not set store key "${$}" to ${B} because it is readonly`);this.name="StoreKeyReadonlyError"}}var q=Symbol(),T=($)=>typeof $==="string",L$=($)=>typeof $==="number",s=($)=>typeof $==="symbol",I=($)=>typeof $==="function",i=($)=>I($)&&$.constructor.name==="AsyncFunction",s$=($)=>!!$&&typeof $==="object",v=($,B)=>Object.prototype.toString.call($)===`[object ${B}]`,P=($)=>v($,"Object"),J$=($)=>P($)||Array.isArray($),i$=($)=>{if(!$.length)return null;let B=$.map((X)=>T(X)?parseInt(X,10):L$(X)?X:NaN);return B.every((X)=>Number.isFinite(X)&&X>=0)?B.sort((X,Z)=>X-Z):null};var c=($)=>$ instanceof DOMException&&$.name==="AbortError",N=($)=>$ instanceof Error?$:Error(String($));var Y$=($)=>{let B=i$(Object.keys($));if(B===null)return $;let X=[];for(let Z of B)X.push($[String(Z)]);return X},H$=($)=>T($)?`"${$}"`:s$($)?JSON.stringify($):String($);var w=($,B,X)=>{if(Object.is($,B))return!0;if(typeof $!==typeof B)return!1;if(typeof $!=="object"||$===null||B===null)return!1;if(!X)X=new WeakSet;if(X.has($)||X.has(B))throw new y("isEqual");X.add($),X.add(B);try{if(Array.isArray($)&&Array.isArray(B)){if($.length!==B.length)return!1;for(let Z=0;Z<$.length;Z++)if(!w($[Z],B[Z],X))return!1;return!0}if(Array.isArray($)!==Array.isArray(B))return!1;if(P($)&&P(B)){let Z=Object.keys($),W=Object.keys(B);if(Z.length!==W.length)return!1;for(let J of Z){if(!(J in B))return!1;if(!w($[J],B[J],X))return!1}return!0}return!1}finally{X.delete($),X.delete(B)}},x$=($,B)=>{let X=J$($),Z=J$(B);if(!X||!Z){let G=!Object.is($,B);return{changed:G,add:G&&Z?B:{},change:{},remove:G&&X?$:{}}}let W=new WeakSet,J={},Q={},H={},x=Object.keys($),C=Object.keys(B),L=new Set([...x,...C]);for(let G of L){let F=G in $,R=G in B;if(!F&&R){J[G]=B[G];continue}else if(F&&!R){H[G]=q;continue}let Y=$[G],K=B[G];if(!w(Y,K,W))Q[G]=K}return{changed:Object.keys(J).length>0||Object.keys(Q).length>0||Object.keys(H).length>0,add:J,change:Q,remove:H}};var u,G$=new Set,D$=0,P$=new Map,C$,h$=()=>{C$=void 0;let $=Array.from(P$.values());P$.clear();for(let B of $)B()},l$=()=>{if(C$)cancelAnimationFrame(C$);C$=requestAnimationFrame(h$)};queueMicrotask(h$);var Q$=($)=>{let B=new Set,X=$;return X.off=(Z)=>{B.add(Z)},X.cleanup=()=>{for(let Z of B)Z();B.clear()},X},E=($)=>{if(u&&!$.has(u)){let B=u;$.add(B),u.off(()=>{$.delete(B)})}},V=($)=>{for(let B of $)if(D$)G$.add(B);else B()},U$=()=>{while(G$.size){let $=Array.from(G$);G$.clear();for(let B of $)B()}},l=($)=>{D$++;try{$()}finally{U$(),D$--}},K$=($,B)=>{let X=u;u=B;try{$()}finally{u=X}},m$=($,B)=>new Promise((X,Z)=>{P$.set(B||Symbol(),()=>{try{X($())}catch(W){Z(W)}}),l$()});var _$="Computed",h=($)=>{let B=new Set,X=q,Z,W,J=!0,Q=!1,H=!1,x=(Y)=>{if(!w(Y,X))X=Y,Q=!0;Z=void 0,J=!1},C=()=>{Q=q!==X,X=q,Z=void 0},L=(Y)=>{let K=N(Y);Q=!Z||K.name!==Z.name||K.message!==Z.message,X=q,Z=K},j=(Y)=>(K)=>{if(H=!1,W=void 0,Y(K),Q)V(B)},G=Q$(()=>{if(J=!0,W?.abort(),B.size)V(B);else G.cleanup()});G.off(()=>{W?.abort()});let F=()=>K$(()=>{if(H)throw new y("computed");if(Q=!1,i($)){if(W)return X;W=new AbortController,W.signal.addEventListener("abort",()=>{H=!1,W=void 0,F()},{once:!0})}let Y;H=!0;try{Y=W?$(W.signal):$()}catch(K){if(c(K))C();else L(K);H=!1;return}if(Y instanceof Promise)Y.then(j(x),j(L));else if(Y==null||q===Y)C();else x(Y);H=!1},G);return{[Symbol.toStringTag]:_$,get:()=>{if(E(B),U$(),J)F();if(Z)throw Z;return X}}},m=($)=>v($,_$),o=($)=>I($)&&$.length<2;var k=($)=>{let B=i($),X=!1,Z,W=Q$(()=>K$(()=>{if(X)throw new y("effect");X=!0,Z?.abort(),Z=void 0;let J;try{if(B){Z=new AbortController;let Q=Z;$(Z.signal).then((H)=>{if(I(H)&&Z===Q)W.off(H)}).catch((H)=>{if(!c(H))console.error("Async effect error:",H)})}else if(J=$(),I(J))W.off(J)}catch(Q){if(!c(Q))console.error("Effect callback error:",Q)}X=!1},W));return W(),()=>{Z?.abort(),W.cleanup()}};function f$($,B){try{if($.pending)B.nil?.();else if($.errors)B.err?.($.errors);else if($.ok)B.ok($.values)}catch(X){if(B.err&&(!$.errors||!$.errors.includes(N(X))))B.err($.errors?[...$.errors,N(X)]:[N(X)]);else throw X}}function g$($){let B=[],X=!1,Z={};for(let[W,J]of Object.entries($))try{let Q=J.get();if(Q===q)X=!0;else Z[W]=Q}catch(Q){B.push(N(Q))}if(X)return{ok:!1,pending:!0};if(B.length>0)return{ok:!1,errors:B};return{ok:!0,values:Z}}var R$="State",b=($)=>{let B=new Set,X=$,Z={[Symbol.toStringTag]:R$,get:()=>{return E(B),X},set:(W)=>{if(W==null)throw new p("state");if(w(X,W))return;if(X=W,V(B),q===X)B.clear()},update:(W)=>{Z.set(W(X))}};return Z},O=($)=>v($,R$);var A$="Store",V$="store-add",d$="store-change",p$="store-remove",r$="store-sort",r=($)=>{let B=new Set,X=new EventTarget,Z=new Map,W=new Map,J=Array.isArray($),Q=b(0),H=()=>{let Y={};for(let[K,A]of Z)Y[K]=A.get();return Y},x=(Y,K)=>X.dispatchEvent(new CustomEvent(Y,{detail:K})),C=()=>Array.from(Z.keys()).map((Y)=>Number(Y)).filter((Y)=>Number.isInteger(Y)).sort((Y,K)=>Y-K),L=(Y,K)=>{if(K==null)throw new p(`store for key "${Y}"`);if(K===q)return!0;if(s(K)||I(K)||m(K))throw new $$(`store for key "${Y}"`,H$(K));return!0},j=(Y,K,A=!1)=>{if(!L(Y,K))return!1;let U=O(K)||f(K)?K:P(K)?r(K):Array.isArray(K)?r(K):b(K);Z.set(Y,U);let z=k(()=>{let D=U.get();if(D!=null)x(d$,{[Y]:D})});if(W.set(Y,z),A)Q.set(Z.size),V(B),x(V$,{[Y]:K});return!0},G=(Y,K=!1)=>{let A=Z.delete(Y);if(A){let U=W.get(Y);if(U)U();W.delete(Y)}if(K)Q.set(Z.size),V(B),x(p$,{[Y]:q});return A},F=(Y,K,A)=>{let U=x$(Y,K);return l(()=>{if(Object.keys(U.add).length){for(let z in U.add){let D=U.add[z]??q;j(z,D)}if(A)setTimeout(()=>{x(V$,U.add)},0);else x(V$,U.add)}if(Object.keys(U.change).length){for(let z in U.change){let D=U.change[z];if(!L(z,D))continue;let W$=Z.get(z);if(t(W$))W$.set(D);else throw new Z$(z,H$(D))}x(d$,U.change)}if(Object.keys(U.remove).length){for(let z in U.remove)G(z);x(p$,U.remove)}Q.set(Z.size)}),U.changed};F({},$,!0);let R={add:J?(Y)=>{let K=Z.size,A=String(K);j(A,Y,!0)}:(Y,K)=>{if(!Z.has(Y))j(Y,K,!0);else throw new B$(Y,H$(K))},get:()=>{return E(B),Y$(H())},remove:J?(Y)=>{let K=Y$(H()),A=Z.size;if(!Array.isArray(K)||Y<=-A||Y>=A)throw new X$(Y);let U=[...K];if(U.splice(Y,1),F(K,U))V(B)}:(Y)=>{if(Z.has(Y))G(Y,!0)},set:(Y)=>{if(F(H(),Y)){if(V(B),q===Y)B.clear()}},update:(Y)=>{let K=H(),A=Y(Y$(K));if(F(K,A)){if(V(B),q===A)B.clear()}},sort:(Y)=>{let K=Array.from(Z.entries()).map(([z,D])=>[z,D.get()]).sort(Y?(z,D)=>Y(z[1],D[1]):(z,D)=>String(z[1]).localeCompare(String(D[1]))),A=K.map(([z])=>String(z)),U=new Map;K.forEach(([z],D)=>{let W$=String(z),n$=J?String(D):String(z),E$=Z.get(W$);if(E$)U.set(n$,E$)}),Z.clear(),U.forEach((z,D)=>Z.set(D,z)),V(B),x(r$,A)},addEventListener:X.addEventListener.bind(X),removeEventListener:X.removeEventListener.bind(X),dispatchEvent:X.dispatchEvent.bind(X),size:Q};return new Proxy({},{get(Y,K){if(K===Symbol.toStringTag)return A$;if(K===Symbol.isConcatSpreadable)return J;if(K===Symbol.iterator)return J?function*(){let A=C();for(let U of A){let z=Z.get(String(U));if(z)yield z}}:function*(){for(let[A,U]of Z)yield[A,U]};if(s(K))return;if(K in R)return R[K];if(K==="length"&&J)return E(B),Q.get();return Z.get(K)},has(Y,K){let A=String(K);return A&&Z.has(A)||Object.keys(R).includes(A)||K===Symbol.toStringTag||K===Symbol.iterator||K===Symbol.isConcatSpreadable||K==="length"&&J},ownKeys(){return J?C().map((Y)=>String(Y)).concat(["length"]):Array.from(Z.keys()).map((Y)=>String(Y))},getOwnPropertyDescriptor(Y,K){let A=(z)=>({enumerable:!1,configurable:!0,writable:!1,value:z});if(K==="length"&&J)return{enumerable:!0,configurable:!0,writable:!1,value:Q.get()};if(K===Symbol.isConcatSpreadable)return A(J);if(K===Symbol.toStringTag)return A(A$);if(s(K))return;if(Object.keys(R).includes(K))return A(R[K]);let U=Z.get(K);return U?{enumerable:!0,configurable:!0,writable:!0,value:U}:void 0}})},f=($)=>v($,A$);var S=($)=>O($)||m($)||f($),t=($)=>O($)||f($);function v$($){if(S($))return $;if(o($))return h($);if(Array.isArray($)||P($))return r($);return b($)}var q$=!1,t$="debug";var a$="warn",n="error",e$=new Set(["constructor","prototype"]),$B=new Set(["id","class","className","title","role","style","dataset","lang","dir","hidden","children","innerHTML","outerHTML","textContent","innerText"]),BB=($)=>$?`#${$}`:"",XB=($)=>$?.length?`.${Array.from($).join(".")}`:"";var z$=($)=>$.localName.includes("-"),M=($)=>$?`<${$.localName}${BB($.id)}${XB($.classList)}>`:"<unknown>",I$=($)=>T($)?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($);var g=($,B,X=t$)=>{if(q$||[n,a$].includes(X))console[X](B,$);return $},c$=($)=>{if(e$.has($))return`Property name "${$}" is a reserved word`;if($B.has($))return`Property name "${$}" conflicts with inherited HTMLElement property`;return null};class T$ extends TypeError{constructor($){super(`Invalid component name "${$}". Custom element names must contain a hyphen, start with a lowercase letter, and contain only lowercase letters, numbers, and hyphens.`);this.name="InvalidComponentNameError"}}class O$ extends TypeError{constructor($,B,X){super(`Invalid property name "${B}" for component <${$}>. ${X}`);this.name="InvalidPropertyNameError"}}class F$ extends TypeError{constructor($,B){super(`Invalid effects in component ${M($)}. Effects must be a record of effects for UI elements or the component, or a Promise that resolves to effects.`);if(this.name="InvalidEffectsError",B)this.cause=B}}class M$ extends Error{constructor($,B,X){super(`Missing required element <${B}> in component ${M($)}. ${X}`);this.name="MissingElementError"}}class N$ extends Error{constructor($,B){super(`Timeout waiting for: [${B.join(", ")}] in component ${M($)}.`);this.name="DependencyTimeoutError"}}class S$ extends TypeError{constructor($,B,X){super(`Expected reactives passed from ${M($)} to ${M(B)} to be a record of signals, reactive property names or functions. Got ${I$(X)}.`);this.name="InvalidReactivesError"}}class y$ extends TypeError{constructor($,B){super(`Target ${M($)} is not a custom element in ${B}.`);this.name="InvalidCustomElementError"}}var a=Symbol("RESET"),ZB=($,B="")=>{return{a:"attribute ",c:"class ",d:"dataset ",h:"inner HTML",m:"method call ",p:"property ",s:"style property ",t:"text content"}[$]+B},w$=($,B,X)=>{let Z=$[B],W=Array.isArray(Z)?Z:[Z];if(!W.length)return;try{if(X instanceof Promise)throw X;let J=[];for(let Q of X)W.forEach((H)=>{let x=Q($.component,H);if(x)J.push(x)});return()=>{J.forEach((Q)=>Q()),J.length=0}}catch(J){if(J instanceof Promise)J.then(()=>w$($,B,X));else throw new F$($.component,J instanceof Error?J:Error(String(J)))}},k$=($,B)=>{if(!P(B))throw new F$($.component);let X=[],Z=Object.keys(B);for(let W of Z){let J=W;if(!B[J])continue;let Q=w$($,J,Array.isArray(B[J])?B[J]:[B[J]]);if(Q)X.push(Q)}return()=>{X.forEach((W)=>W()),X.length=0}},j$=($,B,X,Z)=>{try{return T($)?B[$]:S($)?$.get():I($)?$(X):a}catch(W){if(Z)g(W,`Failed to resolve value of ${I$($)}${Z?` for ${Z}`:""} in ${M(X)}${B!==X?` in ${M(B)}`:""}`,n);return a}},_=($,B)=>(X,Z)=>{let{op:W,name:J="",read:Q,update:H}=B,x=ZB(W,J),C=(G)=>()=>{if(q$&&X.debug)g(Z,`${G} ${x} of ${M(Z)} in ${M(X)}`);B.resolve?.(Z)},L=(G)=>(F)=>{g(F,`Failed to ${G} ${x} of ${M(Z)} in ${M(X)}`,n),B.reject?.(F)},j=Q(Z);return k(()=>{let G=j$($,X,Z,x),F=G===a?j:G===q?B.delete?null:j:G;if(B.delete&&F===null)try{B.delete(Z),C("delete")()}catch(R){L("delete")(R)}else if(F!=null){let R=Q(Z);if(Object.is(F,R))return;try{H(Z,F),C("update")()}catch(Y){L("update")(Y)}}})},JB=($,B)=>(X,Z)=>{let W=(Q)=>()=>{if(q$&&X.debug)g(Z,`${Q} element in ${M(Z)} in ${M(X)}`);if(I(B?.resolve))B.resolve(Z);else{let H=S($)?$:void 0;if(O(H))H.set(0)}},J=(Q)=>(H)=>{g(H,`Failed to ${Q} element in ${M(Z)} in ${M(X)}`,n),B?.reject?.(H)};return k(()=>{let Q=j$($,X,Z,"insertion or deletion"),H=Q===a?0:Q;if(H>0){if(!B)throw TypeError("No inserter provided");try{for(let x=0;x<H;x++){let C=B.create(Z);if(!C)continue;Z.insertAdjacentElement(B.position??"beforeend",C)}W("insert")()}catch(x){J("insert")(x)}}else if(H<0)try{if(B&&(B.position==="afterbegin"||B.position==="beforeend"))for(let x=0;x>H;x--)if(B.position==="afterbegin")Z.firstElementChild?.remove();else Z.lastElementChild?.remove();else Z.remove();W("remove")()}catch(x){J("remove")(x)}})};var b$=($,B)=>{if(B==null)return;let X=$(B);return Number.isFinite(X)?X:void 0},e=($)=>I($)&&$.length>=2,d=($,B)=>I(B)?B($):B,QB=($,B)=>(X)=>{let Z=$(X);return T(Z)&&e(B)?B(X,Z):Z??d(X,B)},KB=()=>($,B)=>B!=null&&B!=="false",WB=($=0)=>(B,X)=>{if(X==null)return d(B,$);let Z=X.trim();if(Z.toLowerCase().startsWith("0x"))return b$((J)=>parseInt(J,16),Z)??d(B,$);let W=b$(parseFloat,X);return W!=null?Math.trunc(W):d(B,$)},YB=($=0)=>(B,X)=>b$(parseFloat,X)??d(B,$),HB=($="")=>(B,X)=>X??d(B,$),xB=($)=>(B,X)=>{if(X==null)return $[0];let Z=X.toLowerCase();return $.find((J)=>J.toLowerCase()===Z)?X:$[0]},GB=($)=>(B,X)=>{if((X??$)==null)throw TypeError("asJSON: Value and fallback are both null or undefined");if(X==null)return d(B,$);if(X==="")throw TypeError("Empty string is not valid JSON");let Z;try{Z=JSON.parse(X)}catch(W){throw SyntaxError(`Failed to parse JSON: ${String(W)}`,{cause:W})}return Z??d(B,$)};var u$=($)=>z$($)&&$.matches(":not(:defined)");var o$=($)=>{let B=$.shadowRoot??$,X=new Set;function Z(J,Q){let H=B.querySelector(J);if(Q!=null&&!H)throw new M$($,J,Q);if(H&&u$(H))X.add(H.localName);return H??void 0}function W(J,Q){let H=B.querySelectorAll(J);if(Q!=null&&!H.length)throw new M$($,J,Q);if(H.length)H.forEach((x)=>{if(u$(x))X.add(x.localName)});return Array.from(H)}return[{first:Z,all:W},()=>Array.from(X)]};var CB=50;function UB($,B={},X=()=>({}),Z=()=>({})){if(!$.includes("-")||!$.match(/^[a-z][a-z0-9-]*$/))throw new T$($);for(let J of Object.keys(B)){let Q=c$(J);if(Q)throw new O$($,J,Q)}class W extends HTMLElement{debug;#$={};#B={};#X;static observedAttributes=Object.entries(B)?.filter(([,J])=>e(J)).map(([J])=>J)??[];connectedCallback(){let[J,Q]=o$(this);this.#$={...X(J),component:this},Object.freeze(this.#$);let H=(j,G)=>{let F=I(G)?e(G)?G(this.#$,null):G(this.#$):G;if(F!=null)this.#Z(j,F)};for(let[j,G]of Object.entries(B)){if(G==null||j in this)continue;H(j,G)}let x=Z(this.#$),C=Q(),L=()=>{this.#X=k$(this.#$,x)};if(C.length)Promise.race([Promise.all(C.map((j)=>customElements.whenDefined(j))),new Promise((j,G)=>{setTimeout(()=>{G(new N$(this,C.filter((F)=>!customElements.get(F))))},CB)})]).then(L).catch(()=>{L()});else L()}disconnectedCallback(){if(I(this.#X))this.#X()}attributeChangedCallback(J,Q,H){if(H===Q||m(this.#B[J]))return;let x=B[J];if(!e(x))return;let C=x(this.#$,H,Q);if(J in this)this[J]=C;else this.#Z(J,C)}#Z(J,Q){let H=S(Q)?Q:o(Q)?h(Q):b(Q),x=this.#B[J],C=t(H);if(this.#B[J]=H,Object.defineProperty(this,J,{get:H.get,set:C?H.set:void 0,enumerable:!0,configurable:C}),x&&O(x)||f(x))x.set(q)}}return customElements.define($,W),customElements.get($)}var AB=($)=>{if(/^(mailto|tel):/i.test($))return!0;if($.includes("://"))try{let B=new URL($,window.location.origin);return["http:","https:","ftp:"].includes(B.protocol)}catch{return!1}return!0},qB=($,B,X)=>{if(/^on/i.test(B))throw Error(`Unsafe attribute: ${B}`);if(X=String(X).trim(),!AB(X))throw Error(`Unsafe URL for ${B}: ${X}`);$.setAttribute(B,X)},zB=($,B=$)=>_(B,{op:"a",name:$,read:(X)=>X.getAttribute($),update:(X,Z)=>{qB(X,$,Z)},delete:(X)=>{X.removeAttribute($)}}),IB=($,B=$)=>_(B,{op:"a",name:$,read:(X)=>X.hasAttribute($),update:(X,Z)=>{X.toggleAttribute($,Z)}});var FB=($,B=$)=>_(B,{op:"c",name:$,read:(X)=>X.classList.contains($),update:(X,Z)=>{X.classList.toggle($,Z)}});var MB=($,B,X=!1)=>(Z,W)=>{let J=(Q)=>{let H=B({host:Z,target:W,event:Q});if(!P(H))return;l(()=>{for(let[x,C]of Object.entries(H))try{Z[x]=C}catch(L){g(L,`Reactive property "${x}" on ${M(Z)} from event ${$} on ${M(W)} could not be set, because it is read-only.`,n)}})};return W.addEventListener($,J,X),()=>W.removeEventListener($,J)},jB=($,B)=>(X,Z)=>k(()=>{let W=j$(B,X,Z,`custom event "${$}" detail`);if(W===a||W===q)return;Z.dispatchEvent(new CustomEvent($,{detail:W,bubbles:!0}))});var LB=($,B={})=>_($,{op:"h",read:(X)=>(X.shadowRoot||!B.shadowRootMode?X:null)?.innerHTML??"",update:(X,Z)=>{let{shadowRootMode:W,allowScripts:J}=B;if(!Z){if(X.shadowRoot)X.shadowRoot.innerHTML="<slot></slot>";return""}if(W&&!X.shadowRoot)X.attachShadow({mode:W});let Q=X.shadowRoot||X;if(Q.innerHTML=Z,!J)return"";return Q.querySelectorAll("script").forEach((H)=>{let x=document.createElement("script");x.appendChild(document.createTextNode(H.textContent??"")),Q.appendChild(x),H.remove()})," with scripts"}});var DB=($)=>(B,X)=>{if(!z$(X))throw new y$(X,`pass from ${M(B)}`);let Z=I($)?$(X):$;if(!P(Z))throw new S$(B,X,Z);let W={},J=(Q)=>{if(S(Q))return Q.get;let H=T(Q)&&Q in B?()=>B[Q]:o(Q)?Q:void 0;return H?h(H).get:void 0};for(let[Q,H]of Object.entries(Z)){if(H==null)continue;let x=Object.getOwnPropertyDescriptor(X,Q);if(!(Q in X)||!x?.configurable)continue;let C=I(H)&&H.length===1?H(X):H,L=Array.isArray(C)&&C.length===2,j=J(L?C[0]:C),G=L&&I(C[1])?C[1]:void 0;if(!j)continue;W[Q]=x,Object.defineProperty(X,Q,{configurable:!0,enumerable:!0,get:j,set:G}),x.set?.call(X,q)}return()=>{Object.defineProperties(X,W)}};var PB=($,B=$)=>_(B,{op:"p",name:$,read:(X)=>($ in X)?X[$]:q,update:(X,Z)=>{X[$]=Z}}),_B=($)=>_($,{op:"p",name:"hidden",read:(B)=>!B.hidden,update:(B,X)=>{B.hidden=!X}});var RB=($,B=$)=>_(B,{op:"s",name:$,read:(X)=>X.style.getPropertyValue($),update:(X,Z)=>{X.style.setProperty($,Z)},delete:(X)=>{X.style.removeProperty($)}});var VB=($)=>_($,{op:"t",read:(B)=>B.textContent,update:(B,X)=>{Array.from(B.childNodes).filter((Z)=>Z.nodeType!==Node.COMMENT_NODE).forEach((Z)=>Z.remove()),B.append(document.createTextNode(X))}});export{_ as updateElement,FB as toggleClass,IB as toggleAttribute,v$ as toSignal,N as toError,r as store,b as state,_B as show,VB as setText,RB as setStyle,PB as setProperty,zB as setAttribute,w$ as runElementEffects,k$ as runEffects,g$ as resolve,QB as read,DB as pass,MB as on,f$ as match,s as isSymbol,T as isString,f as isStore,O as isState,S as isSignal,J$ as isRecordOrArray,P as isRecord,e as isParser,L$ as isNumber,t as isMutableSignal,I as isFunction,w as isEqual,m as isComputed,i as isAsyncFunction,c as isAbortError,JB as insertOrRemoveElement,m$ as enqueue,jB as emit,k as effect,x$ as diff,LB as dangerouslySetInnerHTML,h as computed,UB as component,l as batch,HB as asString,YB as asNumber,GB as asJSON,WB as asInteger,xB as asEnum,KB as asBoolean,q as UNSET,Z$ as StoreKeyReadonlyError,X$ as StoreKeyRangeError,B$ as StoreKeyExistsError,p as NullishSignalValueError,$$ as InvalidSignalValueError,y as CircularDependencyError};

//# debugId=381E1B7AD31BD4A264756E2164756E21
