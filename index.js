function I($){return typeof $==="function"}function W$($){return I($)&&$.constructor.name==="AsyncFunction"}function D$($){return I($)&&$.constructor.name!=="AsyncFunction"}function S($,Z){return Object.prototype.toString.call($)===`[object ${Z}]`}function _($){return S($,"Object")}function DZ($,Z=(J)=>J!=null){return Array.isArray($)&&$.every(Z)}function t($){return typeof $==="string"?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($)}class U$ extends Error{constructor($){super(`[${$}] Circular dependency detected`);this.name="CircularDependencyError"}}class k$ extends TypeError{constructor($){super(`[${$}] Signal value cannot be null or undefined`);this.name="NullishSignalValueError"}}class H$ extends Error{constructor($){super(`[${$}] Signal value is unset`);this.name="UnsetSignalValueError"}}class F$ extends TypeError{constructor($,Z){super(`[${$}] Signal value ${t(Z)} is invalid`);this.name="InvalidSignalValueError"}}class h$ extends TypeError{constructor($,Z){super(`[${$}] Callback ${t(Z)} is invalid`);this.name="InvalidCallbackError"}}class g$ extends Error{constructor($){super(`[${$}] Signal is read-only`);this.name="ReadonlySignalError"}}class p$ extends Error{constructor($){super(`[${$}] Active owner is required`);this.name="RequiredOwnerError"}}class M$ extends Error{constructor($,Z,J){super(`[${$}] Could not add key "${Z}"${J?` with value ${JSON.stringify(J)}`:""} because it already exists`);this.name="DuplicateKeyError"}}function P($,Z,J){if(Z==null)throw new k$($);if(J&&!J(Z))throw new F$($,Z)}function N$($,Z){if(Z==null)throw new H$($)}function h($,Z,J=I){if(!J(Z))throw new h$($,Z)}var a="State",e="Memo",$$="Task",Z$="Sensor",g="List",J$="Collection",X$="Store",j$="Slot",p=0,V$=1,F=2,_$=4,y=8,Y=null,c=null,v$=[],A=0,WZ=!1,i=($,Z)=>$===Z,HZ=($,Z)=>!1;function yZ($,Z){let J=Z.sourcesTail;if(J){let X=Z.sources;while(X){if(X===$)return!0;if(X===J)break;X=X.nextSource}}return!1}function O($,Z){let J=Z.sourcesTail;if(J?.source===$)return;let X=null,j=Z.flags&_$;if(j){if(X=J?J.nextSource:Z.sources,X?.source===$){Z.sourcesTail=X;return}}let Q=$.sinksTail;if(Q?.sink===Z&&(!j||yZ(Q,Z)))return;let M={source:$,sink:Z,nextSource:X,prevSink:Q,nextSink:null};if(Z.sourcesTail=$.sinksTail=M,J)J.nextSource=M;else Z.sources=M;if(Q)Q.nextSink=M;else $.sinks=M}function mZ($){let{source:Z,nextSource:J,nextSink:X,prevSink:j}=$;if(X)X.prevSink=j;else Z.sinksTail=j;if(j)j.nextSink=X;else Z.sinks=X;if(!Z.sinks){if(Z.stop)Z.stop(),Z.stop=void 0;if("sources"in Z&&Z.sources){let Q=Z;Q.sourcesTail=null,P$(Q)}}return J}function P$($){let Z=$.sourcesTail,J=Z?Z.nextSource:$.sources;while(J)J=mZ(J);if(Z)Z.nextSource=null;else $.sources=null}function w($,Z=F){let J=$.flags;if("sinks"in $){if((J&(F|V$))>=Z)return;if($.flags=J|Z,"controller"in $&&$.controller)$.controller.abort(),$.controller=void 0;for(let X=$.sinks;X;X=X.nextSink)w(X.sink,V$)}else{if((J&(F|V$))>=Z)return;let X=J&(F|V$);if($.flags=Z,!X)v$.push($)}}function T$($,Z){if($.equals($.value,Z))return;$.value=Z;for(let J=$.sinks;J;J=J.nextSink)w(J.sink);if(A===0)L()}function G$($,Z){if(!$.cleanup)$.cleanup=Z;else if(Array.isArray($.cleanup))$.cleanup.push(Z);else $.cleanup=[$.cleanup,Z]}function d$($){if(!$.cleanup)return;if(Array.isArray($.cleanup))for(let Z=0;Z<$.cleanup.length;Z++)$.cleanup[Z]();else $.cleanup();$.cleanup=null}function EZ($){let Z=Y;Y=$,$.sourcesTail=null,$.flags=_$;let J=!1;try{let X=$.fn($.value);if($.error||!$.equals(X,$.value))$.value=X,$.error=void 0,J=!0}catch(X){J=!0,$.error=X instanceof Error?X:Error(String(X))}finally{Y=Z,P$($)}if(J){for(let X=$.sinks;X;X=X.nextSink)if(X.sink.flags&V$)X.sink.flags|=F}$.flags=p}function fZ($){$.controller?.abort();let Z=new AbortController;$.controller=Z,$.error=void 0;let J=Y;Y=$,$.sourcesTail=null,$.flags=_$;let X;try{X=$.fn($.value,Z.signal)}catch(j){$.controller=void 0,$.error=j instanceof Error?j:Error(String(j));return}finally{Y=J,P$($)}X.then((j)=>{if(Z.signal.aborted)return;if($.controller=void 0,$.error||!$.equals(j,$.value)){$.value=j,$.error=void 0;for(let Q=$.sinks;Q;Q=Q.nextSink)w(Q.sink);if(A===0)L()}},(j)=>{if(Z.signal.aborted)return;$.controller=void 0;let Q=j instanceof Error?j:Error(String(j));if(!$.error||Q.name!==$.error.name||Q.message!==$.error.message){$.error=Q;for(let M=$.sinks;M;M=M.nextSink)w(M.sink);if(A===0)L()}}),$.flags=p}function BZ($){d$($);let Z=Y,J=c;Y=c=$,$.sourcesTail=null,$.flags=_$;try{let X=$.fn();if(typeof X==="function")G$($,X)}finally{Y=Z,c=J,P$($)}$.flags=p}function T($){if($.flags&V$)for(let Z=$.sources;Z;Z=Z.nextSource){if("fn"in Z.source)T(Z.source);if($.flags&F)break}if($.flags&_$)throw new U$("controller"in $?$$:("value"in $)?e:"Effect");if($.flags&F)if("controller"in $)fZ($);else if("value"in $)EZ($);else BZ($);else $.flags=p}function L(){if(WZ)return;WZ=!0;try{for(let $=0;$<v$.length;$++){let Z=v$[$];if(Z.flags&(F|V$))T(Z)}v$.length=0}finally{WZ=!1}}function s($){A++;try{$()}finally{if(A--,A===0)L()}}function l($){let Z=Y;Y=null;try{return $()}finally{Y=Z}}function r($){let Z=c,J={cleanup:null};c=J;try{let X=$();if(typeof X==="function")G$(J,X);let j=()=>d$(J);if(Z)G$(Z,j);return j}finally{c=Z}}function f($,Z){P(a,$,Z?.guard);let J={value:$,sinks:null,sinksTail:null,equals:Z?.equals??i,guard:Z?.guard};return{[Symbol.toStringTag]:a,get(){if(Y)O(J,Y);return J.value},set(X){P(a,X,J.guard),T$(J,X)},update(X){h(a,X);let j=X(J.value);P(a,j,J.guard),T$(J,j)}}}function x$($){return S($,a)}function Q$($,Z,J){if(Object.is($,Z))return!0;if(typeof $!==typeof Z)return!1;if($==null||typeof $!=="object"||Z==null||typeof Z!=="object")return!1;if(!J)J=new WeakSet;if(J.has($)||J.has(Z))throw new U$("isEqual");J.add($),J.add(Z);try{let X=Array.isArray($);if(X!==Array.isArray(Z))return!1;if(X){let j=$,Q=Z;if(j.length!==Q.length)return!1;for(let M=0;M<j.length;M++)if(!Q$(j[M],Q[M],J))return!1;return!0}if(_($)&&_(Z)){let j=Object.keys($),Q=Object.keys(Z);if(j.length!==Q.length)return!1;for(let M of j){if(!(M in Z))return!1;if(!Q$($[M],Z[M],J))return!1}return!0}return!1}finally{J.delete($),J.delete(Z)}}function c$($,Z){if($.length!==Z.length)return!1;for(let J=0;J<$.length;J++)if($[J]!==Z[J])return!1;return!0}function zZ($){let Z=0,J=typeof $==="function";return[typeof $==="string"?()=>`${$}${Z++}`:J?(X)=>$(X)||String(Z++):()=>String(Z++),J]}function kZ($,Z,J,X,j){let Q=new WeakSet,M={},q={},z={},U=[],B=!1,W=new Map;for(let G=0;G<$.length;G++){let H=J[G];if(H&&$[G])W.set(H,$[G])}let K=new Set;for(let G=0;G<Z.length;G++){let H=Z[G];if(H===void 0)continue;let V=j?X(H):J[G]??X(H);if(K.has(V))throw new M$(g,V,H);if(U.push(V),K.add(V),!W.has(V))M[V]=H,B=!0;else if(!Q$(W.get(V),H,Q))q[V]=H,B=!0}for(let[G]of W)if(!K.has(G))z[G]=null,B=!0;if(!B&&!c$(J,U))B=!0;return{add:M,change:q,remove:z,newKeys:U,changed:B}}function I$($,Z){P(g,$,Array.isArray);let J=new Map,X=[],[j,Q]=zZ(Z?.keyConfig),M=()=>X.map((H)=>J.get(H)?.get()).filter((H)=>H!==void 0),q={fn:M,value:$,flags:F,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:Q$,error:void 0},z=(H)=>{let V={};for(let C=0;C<H.length;C++){let D=H[C];if(D===void 0)continue;let N=X[C];if(!N)N=j(D),X[C]=N;V[N]=D}return V},U=(H)=>{let V=!1;for(let C in H.add){let D=H.add[C];P(`${g} item for key "${C}"`,D),J.set(C,f(D)),V=!0}if(Object.keys(H.change).length)s(()=>{for(let C in H.change){let D=H.change[C];P(`${g} item for key "${C}"`,D);let N=J.get(C);if(N)N.set(D)}});for(let C in H.remove){J.delete(C);let D=X.indexOf(C);if(D!==-1)X.splice(D,1);V=!0}if(V)q.flags|=y;return H.changed},B=Z?.watched,W=B?()=>{if(Y){if(!q.sinks)q.stop=B();O(q,Y)}}:()=>{if(Y)O(q,Y)},K=z($);for(let H in K){let V=K[H];P(`${g} item for key "${H}"`,V),J.set(H,f(V))}q.value=$,q.flags=0;let G={[Symbol.toStringTag]:g,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let H of X){let V=J.get(H);if(V)yield V}},get length(){return W(),X.length},get(){if(W(),q.sources){if(q.flags){let H=q.flags&y;if(q.value=l(M),H){if(q.flags=F,T(q),q.error)throw q.error}else q.flags=p}}else if(T(q),q.error)throw q.error;return q.value},set(H){let V=q.flags&F?M():q.value,C=kZ(V,H,X,j,Q);if(C.changed){X=C.newKeys,U(C),q.flags|=F;for(let D=q.sinks;D;D=D.nextSink)w(D.sink);if(A===0)L()}},update(H){G.set(H(G.get()))},at(H){return J.get(X[H])},keys(){return W(),X.values()},byKey(H){return J.get(H)},keyAt(H){return X[H]},indexOfKey(H){return X.indexOf(H)},add(H){let V=j(H);if(J.has(V))throw new M$(g,V,H);if(!X.includes(V))X.push(V);P(`${g} item for key "${V}"`,H),J.set(V,f(H)),q.flags|=F|y;for(let C=q.sinks;C;C=C.nextSink)w(C.sink);if(A===0)L();return V},remove(H){let V=typeof H==="number"?X[H]:H;if(J.delete(V)){let D=typeof H==="number"?H:X.indexOf(V);if(D>=0)X.splice(D,1);q.flags|=F|y;for(let N=q.sinks;N;N=N.nextSink)w(N.sink);if(A===0)L()}},sort(H){let C=X.map((D)=>[D,J.get(D)?.get()]).sort(I(H)?(D,N)=>H(D[1],N[1]):(D,N)=>String(D[1]).localeCompare(String(N[1]))).map(([D])=>D);if(!c$(X,C)){X=C,q.flags|=F;for(let D=q.sinks;D;D=D.nextSink)w(D.sink);if(A===0)L()}},splice(H,V,...C){let D=X.length,N=H<0?Math.max(0,D+H):Math.min(H,D),x=Math.max(0,Math.min(V??Math.max(0,D-Math.max(0,N)),D-N)),b={},k={};for(let v=0;v<x;v++){let q$=N+v,QZ=X[q$];if(QZ){let YZ=J.get(QZ);if(YZ)k[QZ]=YZ.get()}}let jZ=X.slice(0,N);for(let v of C){let q$=j(v);if(J.has(q$)&&!(q$ in k))throw new M$(g,q$,v);jZ.push(q$),b[q$]=v}jZ.push(...X.slice(N+x));let CZ=!!(Object.keys(b).length||Object.keys(k).length);if(CZ){U({add:b,change:{},remove:k,changed:CZ}),X=jZ,q.flags|=F;for(let v=q.sinks;v;v=v.nextSink)w(v.sink);if(A===0)L()}return Object.values(k)},deriveCollection(H){return u$(G,H)}};return G}function S$($){return S($,g)}function n($,Z){if(h(e,$,D$),Z?.value!==void 0)P(e,Z.value,Z?.guard);let J={fn:$,value:Z?.value,flags:F,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:Z?.equals??i,error:void 0,stop:void 0},X=Z?.watched,j=X?()=>{if(Y){if(!J.sinks)J.stop=X(()=>{if(w(J),A===0)L()});O(J,Y)}}:()=>{if(Y)O(J,Y)};return{[Symbol.toStringTag]:e,get(){if(j(),T(J),J.error)throw J.error;return N$(e,J.value),J.value}}}function B$($){return S($,e)}function O$($,Z){if(h($$,$,W$),Z?.value!==void 0)P($$,Z.value,Z?.guard);let J={fn:$,value:Z?.value,sources:null,sourcesTail:null,sinks:null,sinksTail:null,flags:F,equals:Z?.equals??i,controller:void 0,error:void 0,stop:void 0},X=Z?.watched,j=X?()=>{if(Y){if(!J.sinks)J.stop=X(()=>{if(w(J),A===0)L()});O(J,Y)}}:()=>{if(Y)O(J,Y)};return{[Symbol.toStringTag]:$$,get(){if(j(),T(J),J.error)throw J.error;return N$($$,J.value),J.value},isPending(){return!!J.controller},abort(){J.controller?.abort(),J.controller=void 0}}}function o$($){return S($,$$)}function u$($,Z){h(J$,Z);let J=W$(Z),X=new Map,j=[],Q=(G)=>{let H=J?O$(async(V,C)=>{let D=$.byKey(G)?.get();if(D==null)return V;return Z(D,C)}):n(()=>{let V=$.byKey(G)?.get();if(V==null)return;return Z(V)});X.set(G,H)};function M(G){if(!c$(j,G)){let H=new Set(j),V=new Set(G);for(let C of j)if(!V.has(C))X.delete(C);for(let C of G)if(!H.has(C))Q(C);j=G,U.flags|=y}}function q(){M(Array.from($.keys()));let G=[];for(let H of j)try{let V=X.get(H)?.get();if(V!=null)G.push(V)}catch(V){if(!(V instanceof H$))throw V}return G}let U={fn:q,value:[],flags:F,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:(G,H)=>{if(G.length!==H.length)return!1;for(let V=0;V<G.length;V++)if(G[V]!==H[V])return!1;return!0},error:void 0};function B(){if(U.sources){if(U.flags)if(U.value=l(q),U.flags&y){if(U.flags=F,T(U),U.error)throw U.error}else U.flags=p}else if(U.sinks){if(T(U),U.error)throw U.error}else U.value=l(q)}let W=Array.from(l(()=>$.keys()));for(let G of W)Q(G);j=W;let K={[Symbol.toStringTag]:J$,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let G of j){let H=X.get(G);if(H)yield H}},get length(){if(Y)O(U,Y);return B(),j.length},keys(){if(Y)O(U,Y);return B(),j.values()},get(){if(Y)O(U,Y);return B(),U.value},at(G){return X.get(j[G])},byKey(G){return X.get(G)},keyAt(G){return j[G]},indexOfKey(G){return j.indexOf(G)},deriveCollection(G){return u$(K,G)}};return K}function FZ($,Z){let J=Z?.value??[];if(J.length)P(J$,J,Array.isArray);h(J$,$,D$);let X=new Map,j=[],Q=new Map,[M,q]=zZ(Z?.keyConfig),z=(H)=>Q.get(H)??(q?M(H):void 0),U=Z?.createItem??f;function B(){let H=[];for(let V of j)try{let C=X.get(V)?.get();if(C!=null)H.push(C)}catch(C){if(!(C instanceof H$))throw C}return H}let W={fn:B,value:J,flags:F,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:HZ,error:void 0};for(let H of J){let V=M(H);X.set(V,U(H)),Q.set(H,V),j.push(V)}W.value=J,W.flags=F;function K(){if(Y){if(!W.sinks)W.stop=$((H)=>{let{add:V,change:C,remove:D}=H;if(!V?.length&&!C?.length&&!D?.length)return;let N=!1;s(()=>{if(V)for(let x of V){let b=M(x);if(X.set(b,U(x)),Q.set(x,b),!j.includes(b))j.push(b);N=!0}if(C)for(let x of C){let b=z(x);if(!b)continue;let k=X.get(b);if(k&&x$(k))Q.delete(k.get()),k.set(x),Q.set(x,b)}if(D)for(let x of D){let b=z(x);if(!b)continue;Q.delete(x),X.delete(b);let k=j.indexOf(b);if(k!==-1)j.splice(k,1);N=!0}W.flags=F|(N?y:0);for(let x=W.sinks;x;x=x.nextSink)w(x.sink)})});O(W,Y)}}let G={[Symbol.toStringTag]:J$,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let H of j){let V=X.get(H);if(V)yield V}},get length(){return K(),j.length},keys(){return K(),j.values()},get(){if(K(),W.sources){if(W.flags){let H=W.flags&y;if(W.value=l(B),H){if(W.flags=F,T(W),W.error)throw W.error}else W.flags=p}}else if(T(W),W.error)throw W.error;return W.value},at(H){return X.get(j[H])},byKey(H){return X.get(H)},keyAt(H){return j[H]},indexOfKey(H){return j.indexOf(H)},deriveCollection(H){return u$(G,H)}};return G}function NZ($){return S($,J$)}function b$($){h("Effect",$);let Z={fn:$,flags:F,sources:null,sourcesTail:null,cleanup:null},J=()=>{d$(Z),Z.fn=void 0,Z.flags=p,Z.sourcesTail=null,P$(Z)};if(c)G$(c,J);return BZ(Z),J}function PZ($,Z){if(!c)throw new p$("match");let{ok:J,err:X=console.error,nil:j}=Z,Q,M=!1,q=Array($.length);for(let U=0;U<$.length;U++)try{q[U]=$[U].get()}catch(B){if(B instanceof H$){M=!0;continue}if(!Q)Q=[];Q.push(B instanceof Error?B:Error(String(B)))}let z;try{if(M)z=j?.();else if(Q)z=X(Q);else z=J(q)}catch(U){X([U instanceof Error?U:Error(String(U))])}if(typeof z==="function")return z;if(z instanceof Promise){let U=c,B=new AbortController;G$(U,()=>B.abort()),z.then((W)=>{if(!B.signal.aborted&&typeof W==="function")G$(U,W)}).catch((W)=>{X([W instanceof Error?W:Error(String(W))])})}}function i$($,Z){if(h(Z$,$,D$),Z?.value!==void 0)P(Z$,Z.value,Z?.guard);let J={value:Z?.value,sinks:null,sinksTail:null,equals:Z?.equals??i,guard:Z?.guard,stop:void 0};return{[Symbol.toStringTag]:Z$,get(){if(Y){if(!J.sinks)J.stop=$((X)=>{P(Z$,X,J.guard),T$(J,X)});O(J,Y)}return N$(Z$,J.value),J.value}}}function xZ($){return S($,Z$)}function hZ($,Z){let J=_($)||Array.isArray($),X=_(Z)||Array.isArray(Z);if(!J||!X){let W=!Object.is($,Z);return{changed:W,add:W&&X?Z:{},change:{},remove:W&&J?$:{}}}let j=new WeakSet,Q={},M={},q={},z=!1,U=Object.keys($),B=Object.keys(Z);for(let W of B)if(W in $){if(!Q$($[W],Z[W],j))M[W]=Z[W],z=!0}else Q[W]=Z[W],z=!0;for(let W of U)if(!(W in Z))q[W]=void 0,z=!0;return{add:Q,change:M,remove:q,changed:z}}function y$($,Z){P(X$,$,_);let J=new Map,X=(B,W)=>{if(P(`${X$} for key "${B}"`,W),Array.isArray(W))J.set(B,I$(W));else if(_(W))J.set(B,y$(W));else J.set(B,f(W))},j=()=>{let B={};return J.forEach((W,K)=>{B[K]=W.get()}),B},Q={fn:j,value:$,flags:F,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:Q$,error:void 0},M=(B)=>{let W=!1;for(let K in B.add)X(K,B.add[K]),W=!0;if(Object.keys(B.change).length)s(()=>{for(let K in B.change){let G=B.change[K];P(`${X$} for key "${K}"`,G);let H=J.get(K);if(H)if(_(G)!==m$(H))X(K,G),W=!0;else H.set(G)}});for(let K in B.remove)J.delete(K),W=!0;if(W)Q.flags|=y;return B.changed},q=Z?.watched,z=q?()=>{if(Y){if(!Q.sinks)Q.stop=q();O(Q,Y)}}:()=>{if(Y)O(Q,Y)};for(let B of Object.keys($))X(B,$[B]);let U={[Symbol.toStringTag]:X$,[Symbol.isConcatSpreadable]:!1,*[Symbol.iterator](){for(let B of Array.from(J.keys())){let W=J.get(B);if(W)yield[B,W]}},keys(){return z(),J.keys()},byKey(B){return J.get(B)},get(){if(z(),Q.sources){if(Q.flags){let B=Q.flags&y;if(Q.value=l(j),B){if(Q.flags=F,T(Q),Q.error)throw Q.error}else Q.flags=p}}else if(T(Q),Q.error)throw Q.error;return Q.value},set(B){let W=Q.flags&F?j():Q.value,K=hZ(W,B);if(M(K)){Q.flags|=F;for(let G=Q.sinks;G;G=G.nextSink)w(G.sink);if(A===0)L()}},update(B){U.set(B(U.get()))},add(B,W){if(J.has(B))throw new M$(X$,B,W);X(B,W),Q.flags|=F|y;for(let K=Q.sinks;K;K=K.nextSink)w(K.sink);if(A===0)L();return B},remove(B){if(J.delete(B)){Q.flags|=F|y;for(let K=Q.sinks;K;K=K.nextSink)w(K.sink);if(A===0)L()}}};return new Proxy(U,{get(B,W){if(W in B)return Reflect.get(B,W);if(typeof W!=="symbol")return B.byKey(W)},has(B,W){if(W in B)return!0;return B.byKey(String(W))!==void 0},ownKeys(B){return Array.from(B.keys())},getOwnPropertyDescriptor(B,W){if(W in B)return Reflect.getOwnPropertyDescriptor(B,W);if(typeof W==="symbol")return;let K=B.byKey(String(W));return K?{enumerable:!0,configurable:!0,writable:!0,value:K}:void 0}})}function m$($){return S($,X$)}function A$($,Z){return W$($)?O$($,Z):n($,Z)}function IZ($){if(K$($))return $;if($==null||I($)||d($))throw new F$("createMutableSignal",$);if(DZ($))return I$($);if(_($))return y$($);return f($)}function s$($){return B$($)||o$($)}function d($){let Z=[a,e,$$,Z$,j$,g,J$,X$],J=Object.prototype.toString.call($).slice(8,-1);return Z.includes(J)}function K$($){return x$($)||m$($)||S$($)}function l$($,Z){P(j$,$,d);let J=$,X=Z?.guard,j={fn:()=>J.get(),value:void 0,flags:F,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:Z?.equals??i,error:void 0},Q=()=>{if(Y)O(j,Y);if(T(j),j.error)throw j.error;return j.value},M=(z)=>{if(!K$(J))throw new g$(j$);P(j$,z,X),J.set(z)},q=(z)=>{P(j$,z,d),J=z,j.flags|=F;for(let U=j.sinks;U;U=U.nextSink)w(U.sink);if(A===0)L()};return{[Symbol.toStringTag]:j$,configurable:!0,enumerable:!0,get:Q,set:M,replace:q,current:()=>J}}function w$($){return S($,j$)}var u=!1,gZ="debug";var z$="warn",R$="error",pZ=new Set(["constructor","prototype"]),vZ=new Set(["id","class","className","title","role","style","dataset","lang","dir","hidden","children","innerHTML","outerHTML","textContent","innerText"]),dZ=($)=>$?`#${$}`:"",cZ=($)=>$?.length?`.${Array.from($).join(".")}`:"";var qZ=($)=>$.localName.includes("-"),UZ=($)=>qZ($)&&$.matches(":not(:defined)"),R=($)=>$?`<${$.localName}${dZ($.id)}${cZ($.classList)}>`:"<unknown>";var C$=($,Z,J=gZ)=>{if(u||[R$,z$].includes(J))console[J](Z,$);return $},OZ=($)=>{if(pZ.has($))return`Property name "${$}" is a reserved word`;if(vZ.has($))return`Property name "${$}" conflicts with inherited HTMLElement property`;return null};class r$ extends TypeError{constructor($){super(`Invalid component name "${$}". Custom element names must contain a hyphen, start with a lowercase letter, and contain only lowercase letters, numbers, and hyphens.`);this.name="InvalidComponentNameError"}}class n$ extends TypeError{constructor($,Z,J){super(`Invalid property name "${Z}" for component <${$}>. ${J}`);this.name="InvalidPropertyNameError"}}class t$ extends TypeError{constructor($,Z){super(`Invalid effects in component ${R($)}. Effects must be a record of effects for UI elements or the component, or a Promise that resolves to effects.`);if(this.name="InvalidEffectsError",Z)this.cause=Z}}class AZ extends TypeError{constructor($,Z,J){super(`Invalid UI key "${Z}" in ${J} of component ${R($)}`);this.name="InvalidUIKeyError"}}class E$ extends Error{constructor($,Z,J){super(`Missing required element <${Z}> in component ${R($)}. ${J}`);this.name="MissingElementError"}}class a$ extends Error{constructor($,Z){super(`Timeout waiting for: [${Z.join(", ")}] in component ${R($)}.`);this.name="DependencyTimeoutError"}}class e$ extends TypeError{constructor($,Z,J){super(`Expected reactives passed from ${R($)} to ${R(Z)} to be a record of signals, reactive property names or functions. Got ${t(J)}.`);this.name="InvalidReactivesError"}}class $Z extends TypeError{constructor($,Z){super(`Target ${R($)} is not a custom element in ${Z}.`);this.name="InvalidCustomElementError"}}var uZ=($,Z="")=>{return{a:"attribute ",c:"class ",d:"dataset ",h:"inner HTML",m:"method call ",p:"property ",s:"style property ",t:"text content"}[$]+Z},wZ=($,Z)=>{if(!_(Z))throw new t$($.host);return r(()=>{for(let J of Object.keys(Z)){let X=J;if(!Z[X])continue;let j=Array.isArray(Z[X])?Z[X]:[Z[X]];if(B$($[X]))b$(()=>{for(let Q of $[X].get())for(let M of j)M($.host,Q)});else if($[X])for(let Q of j)Q($.host,$[X])}})},oZ=($,Z,J,X)=>{try{if(typeof $==="string"){if(u&&!($ in Z))C$($,`resolveReactive: property '${$}' does not exist on ${R(Z)}`,z$);return Z[$]}return d($)?$.get():I($)?$(J):void 0}catch(j){if(X)C$(j,`Failed to resolve value of ${t($)}${X?` for ${X}`:""} in ${R(J)}${Z!==J?` in ${R(Z)}`:""}`,R$);return}},m=($,Z)=>(J,X)=>{let{op:j,name:Q="",read:M,update:q}=Z,z=uZ(j,Q),U=(K)=>()=>{if(u&&J.debug)C$(X,`${K} ${z} of ${R(X)} in ${R(J)}`);Z.resolve?.(X)},B=(K)=>(G)=>{C$(G,`Failed to ${K} ${z} of ${R(X)} in ${R(J)}`,R$),Z.reject?.(G)},W=M(X);return b$(()=>{let K=oZ($,J,X,z),G=K===void 0?W:K===null?Z.delete?null:W:K;if(Z.delete&&G===null)try{Z.delete(X),U("delete")()}catch(H){B("delete")(H)}else if(G!=null){let H=M(X);if(Object.is(G,H))return;try{q(X,G),U("update")()}catch(V){B("update")(V)}}})};var RZ=new WeakMap,f$=($)=>{let Z=RZ.get($);if(!Z)Z={},RZ.set($,Z);return Z};var LZ=Symbol("parser"),_Z=Symbol("method"),L$=($)=>{if(!I($))return!1;if(LZ in $)return!0;if($.length>=2){if(u)console.warn("isParser: unbranded two-argument function detected. Wrap custom parsers with asParser() to avoid misclassification when using default parameters or destructuring.",$);return!0}return!1},MZ=($)=>I($)&&(_Z in $),iZ=($)=>I($),E=($,Z)=>iZ(Z)?Z($):Z,o=($)=>Object.assign($,{[LZ]:!0}),sZ=($)=>Object.assign($,{[_Z]:!0}),lZ=($,Z)=>(J)=>{let X=$(J);return typeof X==="string"&&L$(Z)?Z(J,X):X??E(J,Z)};var rZ=200,nZ=($)=>{let Z=new Set;if($.includes("."))Z.add("class");if($.includes("#"))Z.add("id");if($.includes("[")){let J=$.split("[");for(let X=1;X<J.length;X++){let j=J[X];if(!j.includes("]"))continue;let Q=j.split("=")[0].trim().replace(/[^a-zA-Z0-9_-]/g,"");if(Q)Z.add(Q)}}return[...Z]};function TZ($,Z){return n(()=>Array.from($.querySelectorAll(Z)),{value:[],equals:(J,X)=>J.length===X.length&&J.every((j,Q)=>j===X[Q]),watched:(J)=>{let X={childList:!0,subtree:!0},j=nZ(Z);if(j.length)X.attributes=!0,X.attributeFilter=j;let Q=(z)=>z instanceof Element&&(z.matches(Z)||z.querySelector(Z)),M=(z)=>{if(z.type==="attributes")return!0;if(z.type==="childList")return Array.from(z.addedNodes).some(Q)||Array.from(z.removedNodes).some(Q);return!1},q=new MutationObserver((z)=>{for(let U of z)if(M(U)){J();return}});return q.observe($,X),()=>q.disconnect()}})}var SZ=($)=>{let Z=$.shadowRoot??$,J=new Set;function X(M,q){let z=Z.querySelector(M);if(q!=null&&!z)throw new E$($,M,q);if(z&&UZ(z))J.add(z.localName);return z??void 0}function j(M,q){let z=TZ(Z,M),U=z.get();if(q!=null&&!U.length)throw new E$($,M,q);if(U.length){for(let B of U)if(UZ(B))J.add(B.localName)}return z}return[{first:X,all:j},(M)=>{if(J.size)queueMicrotask(()=>{let q=Array.from(J).filter((z)=>!customElements.get(z));if(!q.length){M();return}Promise.race([Promise.all(q.map((z)=>customElements.whenDefined(z))),new Promise((z,U)=>{setTimeout(()=>{U(new a$($,q.filter((B)=>!customElements.get(B))))},rZ)})]).then(M).catch((z)=>{if(u)console[z$](z);M()})});else M()}]};function tZ($,Z={},J=()=>({}),X=()=>({})){if(!$.includes("-")||!$.match(/^[a-z][a-z0-9-]*$/))throw new r$($);for(let Q of Object.keys(Z)){let M=OZ(Q);if(M)throw new n$($,Q,M)}class j extends HTMLElement{debug;#$;#J;static observedAttributes=Object.entries(Z)?.filter(([,Q])=>L$(Q)).map(([Q])=>Q)??[];connectedCallback(){let[Q,M]=SZ(this),q={...J(Q),host:this};this.#$=q,Object.freeze(this.#$);let z=(U,B)=>{if(L$(B)){let W=B(q,this.getAttribute(U));if(W!=null)this.#Z(U,W)}else if(MZ(B))B(q);else if(I(B)){let W=B(q);if(W!=null)this.#Z(U,W)}else{let W=B;if(W!=null)this.#Z(U,W)}};for(let[U,B]of Object.entries(Z)){if(B==null||U in this)continue;z(U,B)}M(()=>{this.#J=wZ(q,X(q))})}disconnectedCallback(){if(I(this.#J))this.#J()}attributeChangedCallback(Q,M,q){if(!this.#$||q===M||s$(f$(this)[Q]))return;let z=Z[Q];if(!L$(z))return;let U=z(this.#$,q,M);if(Q in this)this[Q]=U;else this.#Z(Q,U)}#Z(Q,M){let q=d(M)?M:I(M)?A$(M):f(M),z=f$(this),U=Q,B=z[U];if(w$(B))B.replace(q);else if(K$(q)){let W=l$(q);z[U]=W,Object.defineProperty(this,Q,W)}else z[U]=q,Object.defineProperty(this,Q,{get:q.get,enumerable:!0})}}return customElements.define($,j),customElements.get($)}var ZZ="context-request";class VZ extends Event{context;callback;subscribe;constructor($,Z,J=!1){super(ZZ,{bubbles:!0,composed:!0});this.context=$,this.callback=Z,this.subscribe=J}}var aZ=($)=>(Z)=>r(()=>{let J=(X)=>{let{context:j,callback:Q}=X;if(typeof j==="string"&&$.includes(j)&&I(Q))X.stopImmediatePropagation(),Q(()=>Z[j])};return Z.addEventListener(ZZ,J),()=>Z.removeEventListener(ZZ,J)}),eZ=($,Z)=>(J)=>{let X=()=>E(J,Z);return J.host.dispatchEvent(new VZ($,(j)=>{X=j})),n(X)};var $4=($)=>{if(/^(mailto|tel):/i.test($))return!0;if($.includes("://"))try{let Z=new URL($,window.location.origin);return["http:","https:","ftp:"].includes(Z.protocol)}catch{return!1}return!0},Z4=($,Z,J)=>{if(/^on/i.test(Z))throw Error(`setAttribute: blocked unsafe attribute name '${Z}' on ${$.localName} — event handler attributes are not allowed`);if(J=String(J).trim(),!$4(J))throw Error(`setAttribute: blocked unsafe value for '${Z}' on <${$.localName}>: '${J}'`);$.setAttribute(Z,J)},J4=($,Z=$)=>m(Z,{op:"a",name:$,read:(J)=>J.getAttribute($),update:(J,X)=>{Z4(J,$,X)},delete:(J)=>{J.removeAttribute($)}}),X4=($,Z=$)=>m(Z,{op:"a",name:$,read:(J)=>J.hasAttribute($),update:(J,X)=>{J.toggleAttribute($,X)}});var j4=($,Z=$)=>m(Z,{op:"c",name:$,read:(J)=>J.classList.contains($),update:(J,X)=>{J.classList.toggle($,X)}});var XZ=new Set(["scroll","resize","mousewheel","touchstart","touchmove","wheel"]),GZ=new Set,bZ=new WeakMap,JZ,Q4=()=>{JZ=void 0;let $=Array.from(GZ);GZ.clear();for(let Z of $)bZ.get(Z)?.()},W4=()=>{if(JZ)cancelAnimationFrame(JZ);JZ=requestAnimationFrame(Q4)},Y$=($,Z)=>{bZ.set($,Z),GZ.add($),W4()};var H4=($,Z,J={})=>(X,j)=>r(()=>{if(!("passive"in J))J={...J,passive:XZ.has($)};let Q=(M)=>{let q=()=>{let z=Z(M);if(!_(z))return;s(()=>{for(let[U,B]of Object.entries(z))try{X[U]=B}catch(W){C$(W,`Reactive property "${U}" on ${R(X)} from event ${$} on ${R(j)} could not be set, because it is read-only.`,R$)}})};if(J.passive)Y$(j,q);else q()};return j.addEventListener($,Q,J),()=>j.removeEventListener($,Q)});var B4=($,Z={})=>m($,{op:"h",read:(J)=>(J.shadowRoot||!Z.shadowRootMode?J:null)?.innerHTML??"",update:(J,X)=>{let{shadowRootMode:j,allowScripts:Q}=Z;if(!X){if(J.shadowRoot)J.shadowRoot.innerHTML="<slot></slot>";return""}if(j&&!J.shadowRoot)J.attachShadow({mode:j});let M=J.shadowRoot||J;return Y$(J,()=>{if(M.innerHTML=X,Q){let q=["type","src","async","defer","nomodule","crossorigin","integrity","referrerpolicy","fetchpriority"];M.querySelectorAll("script").forEach((z)=>{let U=document.createElement("script");for(let B of q)if(z.hasAttribute(B))U.setAttribute(B,z.getAttribute(B));if(!z.hasAttribute("src"))U.appendChild(document.createTextNode(z.textContent??""));M.appendChild(U),z.remove()})}}),Q?" with scripts":""}});var z4=($)=>(Z,J)=>r(()=>{if(!qZ(J))throw new $Z(J,`pass from ${R(Z)}`);let X=I($)?$(J):$;if(!_(X))throw new e$(Z,J,X);let j=(z)=>{if(d(z))return z;let U=typeof z==="string"&&z in Z?()=>Z[z]:I(z)?z:void 0;return U?A$(U):void 0},Q=f$(J),M=R(J),q=[];for(let[z,U]of Object.entries(X)){if(U==null)continue;if(!(z in J)){if(u)console[z$](`pass(): property '${z}' does not exist on ${M}`);continue}let B=j(U);if(!B)continue;let W=Q[z];if(w$(W)){let K=W.current();W.replace(B),q.push(()=>W.replace(K));continue}if(u)console[z$](`pass(): property '${z}' on ${M} is not Slot-backed — use setProperty() for non-Le Truc elements`)}if(q.length)return()=>{for(let z of q)z()}});var q4=($,Z=$)=>m(Z,{op:"p",name:$,read:(J)=>($ in J)?J[$]??null:null,update:(J,X)=>{J[$]=X}}),U4=($)=>m($,{op:"p",name:"hidden",read:(Z)=>!Z.hidden,update:(Z,J)=>{Z.hidden=!J}});var M4=($,Z=$)=>m(Z,{op:"s",name:$,read:(J)=>J.style.getPropertyValue($),update:(J,X)=>{J.style.setProperty($,X)},delete:(J)=>{J.style.removeProperty($)}});var V4=($)=>m($,{op:"t",read:(Z)=>Z.textContent,update:(Z,J)=>{Array.from(Z.childNodes).filter((X)=>X.nodeType!==Node.COMMENT_NODE).forEach((X)=>X.remove()),Z.append(document.createTextNode(J))}});var G4=($,Z,J)=>(X)=>{let{host:j}=X,Q=E(X,$),M=B$(X[Z])?X[Z]:null,q=M?null:X[Z],z=new Map,U=(B)=>{if(q)return q.contains(B)?q:void 0;for(let W of M.get())if(W.contains(B))return W};return i$((B)=>{for(let[W,K]of Object.entries(J)){let G={passive:XZ.has(W)},H=(V)=>{let C=V.target;if(!C)return;let D=U(C);if(!D)return;V.stopPropagation();let N=()=>{try{let x=K({event:V,ui:X,target:D,prev:Q});if(x==null||x instanceof Promise)return;if(!Object.is(x,Q))Q=x,B(x)}catch(x){throw V.stopImmediatePropagation(),x}};if(G.passive)Y$(j,N);else N()};z.set(W,H),j.addEventListener(W,H,G)}return()=>{if(z.size){for(let[W,K]of z)j.removeEventListener(W,K);z.clear()}}},{value:Q})};var K4=()=>o(($,Z)=>Z!=null&&Z!=="false");var C4=($)=>o((Z,J)=>{if((J??$)==null)throw TypeError("asJSON: Value and fallback are both null or undefined");if(J==null)return E(Z,$);if(J==="")throw TypeError("Empty string is not valid JSON");let X;try{X=JSON.parse(J)}catch(j){throw SyntaxError(`Failed to parse JSON: ${String(j)}`,{cause:j})}return X??E(Z,$)});var KZ=($,Z)=>{if(Z==null)return;let J=$(Z);return Number.isFinite(J)?J:void 0},Y4=($=0)=>o((Z,J)=>{if(J==null)return E(Z,$);let X=J.trim();if(X.toLowerCase().startsWith("0x"))return KZ((Q)=>parseInt(Q,16),X)??E(Z,$);let j=KZ(parseFloat,J);return j!=null?Math.trunc(j):E(Z,$)}),D4=($=0)=>o((Z,J)=>KZ(parseFloat,J)??E(Z,$));var F4=($="")=>o((Z,J)=>J??E(Z,$)),N4=($)=>o((Z,J)=>{if(J==null)return $[0];let X=J.toLowerCase();return $.find((Q)=>Q.toLowerCase()===X)?J:$[0]});export{t as valueString,m as updateElement,j4 as toggleClass,X4 as toggleAttribute,U4 as show,V4 as setText,M4 as setStyle,q4 as setProperty,J4 as setAttribute,Y$ as schedule,eZ as requestContext,lZ as read,aZ as provideContexts,z4 as pass,H4 as on,PZ as match,o$ as isTask,m$ as isStore,x$ as isState,w$ as isSlot,d as isSignal,xZ as isSensor,_ as isRecord,L$ as isParser,K$ as isMutableSignal,MZ as isMethodProducer,B$ as isMemo,S$ as isList,I as isFunction,Q$ as isEqual,s$ as isComputed,NZ as isCollection,W$ as isAsyncFunction,tZ as defineComponent,B4 as dangerouslySetInnerHTML,O$ as createTask,y$ as createStore,f as createState,l$ as createSlot,i$ as createSensor,r as createScope,IZ as createMutableSignal,n as createMemo,I$ as createList,G4 as createEventsSensor,TZ as createElementsMemo,b$ as createEffect,A$ as createComputed,FZ as createCollection,s as batch,F4 as asString,o as asParser,D4 as asNumber,sZ as asMethod,C4 as asJSON,Y4 as asInteger,N4 as asEnum,K4 as asBoolean,k$ as NullishSignalValueError,E$ as MissingElementError,AZ as InvalidUIKeyError,F$ as InvalidSignalValueError,e$ as InvalidReactivesError,n$ as InvalidPropertyNameError,t$ as InvalidEffectsError,$Z as InvalidCustomElementError,r$ as InvalidComponentNameError,h$ as InvalidCallbackError,a$ as DependencyTimeoutError,VZ as ContextRequestEvent,U$ as CircularDependencyError,ZZ as CONTEXT_REQUEST};

//# debugId=D00D6526E38035EE64756E2164756E21
