function x($){return typeof $==="function"}function X$($){return x($)&&$.constructor.name==="AsyncFunction"}function G$($){return x($)&&$.constructor.name!=="AsyncFunction"}function S($,Z){return Object.prototype.toString.call($)===`[object ${Z}]`}function _($){return S($,"Object")}function CZ($,Z=(J)=>J!=null){return Array.isArray($)&&$.every(Z)}function l($){return typeof $==="string"?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($)}class Q$ extends Error{constructor($){super(`[${$}] Circular dependency detected`);this.name="CircularDependencyError"}}class f$ extends TypeError{constructor($){super(`[${$}] Signal value cannot be null or undefined`);this.name="NullishSignalValueError"}}class H$ extends Error{constructor($){super(`[${$}] Signal value is unset`);this.name="UnsetSignalValueError"}}class K$ extends TypeError{constructor($,Z){super(`[${$}] Signal value ${l(Z)} is invalid`);this.name="InvalidSignalValueError"}}class E$ extends TypeError{constructor($,Z){super(`[${$}] Callback ${l(Z)} is invalid`);this.name="InvalidCallbackError"}}class h$ extends Error{constructor($){super(`[${$}] Signal is read-only`);this.name="ReadonlySignalError"}}class k$ extends Error{constructor($){super(`[${$}] Active owner is required`);this.name="RequiredOwnerError"}}class z$ extends Error{constructor($,Z,J){super(`[${$}] Could not add key "${Z}"${J?` with value ${JSON.stringify(J)}`:""} because it already exists`);this.name="DuplicateKeyError"}}function N($,Z,J){if(Z==null)throw new f$($);if(J&&!J(Z))throw new K$($,Z)}function D$($,Z){if(Z==null)throw new H$($)}function k($,Z,J=x){if(!J(Z))throw new E$($,Z)}var r="State",n="Memo",t="Task",a="Sensor",p="List",e="Collection",$$="Store",Z$="Slot",g=0,q$=1,O=2,R$=4,y=8,C=null,c=null,p$=[],A=0,WZ=!1,u=($,Z)=>$===Z,jZ=($,Z)=>!1;function TZ($,Z){let J=Z.sourcesTail;if(J){let X=Z.sources;while(X){if(X===$)return!0;if(X===J)break;X=X.nextSource}}return!1}function I($,Z){let J=Z.sourcesTail;if(J?.source===$)return;let X=null,H=Z.flags&R$;if(H){if(X=J?J.nextSource:Z.sources,X?.source===$){Z.sourcesTail=X;return}}let W=$.sinksTail;if(W?.sink===Z&&(!H||TZ(W,Z)))return;let M={source:$,sink:Z,nextSource:X,prevSink:W,nextSink:null};if(Z.sourcesTail=$.sinksTail=M,J)J.nextSource=M;else Z.sources=M;if(W)W.nextSink=M;else $.sinks=M}function SZ($){let{source:Z,nextSource:J,nextSink:X,prevSink:H}=$;if(X)X.prevSink=H;else Z.sinksTail=H;if(H)H.nextSink=X;else Z.sinks=X;if(!Z.sinks){if(Z.stop)Z.stop(),Z.stop=void 0;if("sources"in Z&&Z.sources){let W=Z;W.sourcesTail=null,C$(W)}}return J}function C$($){let Z=$.sourcesTail,J=Z?Z.nextSource:$.sources;while(J)J=SZ(J);if(Z)Z.nextSource=null;else $.sources=null}function w($,Z=O){let J=$.flags;if("sinks"in $){if((J&(O|q$))>=Z)return;if($.flags=J|Z,"controller"in $&&$.controller)$.controller.abort(),$.controller=void 0;for(let X=$.sinks;X;X=X.nextSink)w(X.sink,q$)}else{if((J&(O|q$))>=Z)return;let X=J&(O|q$);if($.flags=Z,!X)p$.push($)}}function L$($,Z){if($.equals($.value,Z))return;$.value=Z;for(let J=$.sinks;J;J=J.nextSink)w(J.sink);if(A===0)L()}function M$($,Z){if(!$.cleanup)$.cleanup=Z;else if(Array.isArray($.cleanup))$.cleanup.push(Z);else $.cleanup=[$.cleanup,Z]}function g$($){if(!$.cleanup)return;if(Array.isArray($.cleanup))for(let Z=0;Z<$.cleanup.length;Z++)$.cleanup[Z]();else $.cleanup();$.cleanup=null}function bZ($){let Z=C;C=$,$.sourcesTail=null,$.flags=R$;let J=!1;try{let X=$.fn($.value);if($.error||!$.equals(X,$.value))$.value=X,$.error=void 0,J=!0}catch(X){J=!0,$.error=X instanceof Error?X:Error(String(X))}finally{C=Z,C$($)}if(J){for(let X=$.sinks;X;X=X.nextSink)if(X.sink.flags&q$)X.sink.flags|=O}$.flags=g}function yZ($){$.controller?.abort();let Z=new AbortController;$.controller=Z,$.error=void 0;let J=C;C=$,$.sourcesTail=null,$.flags=R$;let X;try{X=$.fn($.value,Z.signal)}catch(H){$.controller=void 0,$.error=H instanceof Error?H:Error(String(H));return}finally{C=J,C$($)}X.then((H)=>{if(Z.signal.aborted)return;if($.controller=void 0,$.error||!$.equals(H,$.value)){$.value=H,$.error=void 0;for(let W=$.sinks;W;W=W.nextSink)w(W.sink);if(A===0)L()}},(H)=>{if(Z.signal.aborted)return;$.controller=void 0;let W=H instanceof Error?H:Error(String(H));if(!$.error||W.name!==$.error.name||W.message!==$.error.message){$.error=W;for(let M=$.sinks;M;M=M.nextSink)w(M.sink);if(A===0)L()}}),$.flags=g}function BZ($){g$($);let Z=C,J=c;C=c=$,$.sourcesTail=null,$.flags=R$;try{let X=$.fn();if(typeof X==="function")M$($,X)}finally{C=Z,c=J,C$($)}$.flags=g}function T($){if($.flags&q$)for(let Z=$.sources;Z;Z=Z.nextSource){if("fn"in Z.source)T(Z.source);if($.flags&O)break}if($.flags&R$)throw new Q$("controller"in $?t:("value"in $)?n:"Effect");if($.flags&O)if("controller"in $)yZ($);else if("value"in $)bZ($);else BZ($);else $.flags=g}function L(){if(WZ)return;WZ=!0;try{for(let $=0;$<p$.length;$++){let Z=p$[$];if(Z.flags&(O|q$))T(Z)}p$.length=0}finally{WZ=!1}}function o($){A++;try{$()}finally{if(A--,A===0)L()}}function s($){let Z=C;C=null;try{return $()}finally{C=Z}}function v$($){let Z=c,J={cleanup:null};c=J;try{let X=$();if(typeof X==="function")M$(J,X);let H=()=>g$(J);if(Z)M$(Z,H);return H}finally{c=Z}}function E($,Z){N(r,$,Z?.guard);let J={value:$,sinks:null,sinksTail:null,equals:Z?.equals??u,guard:Z?.guard};return{[Symbol.toStringTag]:r,get(){if(C)I(J,C);return J.value},set(X){N(r,X,J.guard),L$(J,X)},update(X){k(r,X);let H=X(J.value);N(r,H,J.guard),L$(J,H)}}}function P$($){return S($,r)}function J$($,Z,J){if(Object.is($,Z))return!0;if(typeof $!==typeof Z)return!1;if($==null||typeof $!=="object"||Z==null||typeof Z!=="object")return!1;if(!J)J=new WeakSet;if(J.has($)||J.has(Z))throw new Q$("isEqual");J.add($),J.add(Z);try{let X=Array.isArray($);if(X!==Array.isArray(Z))return!1;if(X){let H=$,W=Z;if(H.length!==W.length)return!1;for(let M=0;M<H.length;M++)if(!J$(H[M],W[M],J))return!1;return!0}if(_($)&&_(Z)){let H=Object.keys($),W=Object.keys(Z);if(H.length!==W.length)return!1;for(let M of H){if(!(M in Z))return!1;if(!J$($[M],Z[M],J))return!1}return!0}return!1}finally{J.delete($),J.delete(Z)}}function d$($,Z){if($.length!==Z.length)return!1;for(let J=0;J<$.length;J++)if($[J]!==Z[J])return!1;return!0}function QZ($){let Z=0,J=typeof $==="function";return[typeof $==="string"?()=>`${$}${Z++}`:J?(X)=>$(X)||String(Z++):()=>String(Z++),J]}function mZ($,Z,J,X,H){let W=new WeakSet,M={},z={},q={},U=[],Q=!1,j=new Map;for(let G=0;G<$.length;G++){let B=J[G];if(B&&$[G])j.set(B,$[G])}let K=new Set;for(let G=0;G<Z.length;G++){let B=Z[G];if(B===void 0)continue;let V=H?X(B):J[G]??X(B);if(K.has(V))throw new z$(p,V,B);if(U.push(V),K.add(V),!j.has(V))M[V]=B,Q=!0;else if(!J$(j.get(V),B,W))z[V]=B,Q=!0}for(let[G]of j)if(!K.has(G))q[G]=null,Q=!0;if(!Q&&!d$(J,U))Q=!0;return{add:M,change:z,remove:q,newKeys:U,changed:Q}}function O$($,Z){N(p,$,Array.isArray);let J=new Map,X=[],[H,W]=QZ(Z?.keyConfig),M=()=>X.map((B)=>J.get(B)?.get()).filter((B)=>B!==void 0),z={fn:M,value:$,flags:O,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:J$,error:void 0},q=(B)=>{let V={};for(let D=0;D<B.length;D++){let P=B[D];if(P===void 0)continue;let Y=X[D];if(!Y)Y=H(P),X[D]=Y;V[Y]=P}return V},U=(B)=>{let V=!1;for(let D in B.add){let P=B.add[D];N(`${p} item for key "${D}"`,P),J.set(D,E(P)),V=!0}if(Object.keys(B.change).length)o(()=>{for(let D in B.change){let P=B.change[D];N(`${p} item for key "${D}"`,P);let Y=J.get(D);if(Y)Y.set(P)}});for(let D in B.remove){J.delete(D);let P=X.indexOf(D);if(P!==-1)X.splice(P,1);V=!0}if(V)z.flags|=y;return B.changed},Q=Z?.watched,j=Q?()=>{if(C){if(!z.sinks)z.stop=Q();I(z,C)}}:()=>{if(C)I(z,C)},K=q($);for(let B in K){let V=K[B];N(`${p} item for key "${B}"`,V),J.set(B,E(V))}z.value=$,z.flags=0;let G={[Symbol.toStringTag]:p,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let B of X){let V=J.get(B);if(V)yield V}},get length(){return j(),X.length},get(){if(j(),z.sources){if(z.flags){let B=z.flags&y;if(z.value=s(M),B){if(z.flags=O,T(z),z.error)throw z.error}else z.flags=g}}else if(T(z),z.error)throw z.error;return z.value},set(B){let V=z.flags&O?M():z.value,D=mZ(V,B,X,H,W);if(D.changed){X=D.newKeys,U(D),z.flags|=O;for(let P=z.sinks;P;P=P.nextSink)w(P.sink);if(A===0)L()}},update(B){G.set(B(G.get()))},at(B){return J.get(X[B])},keys(){return j(),X.values()},byKey(B){return J.get(B)},keyAt(B){return X[B]},indexOfKey(B){return X.indexOf(B)},add(B){let V=H(B);if(J.has(V))throw new z$(p,V,B);if(!X.includes(V))X.push(V);N(`${p} item for key "${V}"`,B),J.set(V,E(B)),z.flags|=O|y;for(let D=z.sinks;D;D=D.nextSink)w(D.sink);if(A===0)L();return V},remove(B){let V=typeof B==="number"?X[B]:B;if(J.delete(V)){let P=typeof B==="number"?B:X.indexOf(V);if(P>=0)X.splice(P,1);z.flags|=O|y;for(let Y=z.sinks;Y;Y=Y.nextSink)w(Y.sink);if(A===0)L()}},sort(B){let D=X.map((P)=>[P,J.get(P)?.get()]).sort(x(B)?(P,Y)=>B(P[1],Y[1]):(P,Y)=>String(P[1]).localeCompare(String(Y[1]))).map(([P])=>P);if(!d$(X,D)){X=D,z.flags|=O;for(let P=z.sinks;P;P=P.nextSink)w(P.sink);if(A===0)L()}},splice(B,V,...D){let P=X.length,Y=B<0?Math.max(0,P+B):Math.min(B,P),F=Math.max(0,Math.min(V??Math.max(0,P-Math.max(0,Y)),P-Y)),b={},h={};for(let v=0;v<F;v++){let B$=Y+v,HZ=X[B$];if(HZ){let DZ=J.get(HZ);if(DZ)h[HZ]=DZ.get()}}let XZ=X.slice(0,Y);for(let v of D){let B$=H(v);if(J.has(B$)&&!(B$ in h))throw new z$(p,B$,v);XZ.push(B$),b[B$]=v}XZ.push(...X.slice(Y+F));let KZ=!!(Object.keys(b).length||Object.keys(h).length);if(KZ){U({add:b,change:{},remove:h,changed:KZ}),X=XZ,z.flags|=O;for(let v=z.sinks;v;v=v.nextSink)w(v.sink);if(A===0)L()}return Object.values(h)},deriveCollection(B){return c$(G,B)}};return G}function _$($){return S($,p)}function i($,Z){if(k(n,$,G$),Z?.value!==void 0)N(n,Z.value,Z?.guard);let J={fn:$,value:Z?.value,flags:O,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:Z?.equals??u,error:void 0,stop:void 0},X=Z?.watched,H=X?()=>{if(C){if(!J.sinks)J.stop=X(()=>{if(w(J),A===0)L()});I(J,C)}}:()=>{if(C)I(J,C)};return{[Symbol.toStringTag]:n,get(){if(H(),T(J),J.error)throw J.error;return D$(n,J.value),J.value}}}function W$($){return S($,n)}function Y$($,Z){if(k(t,$,X$),Z?.value!==void 0)N(t,Z.value,Z?.guard);let J={fn:$,value:Z?.value,sources:null,sourcesTail:null,sinks:null,sinksTail:null,flags:O,equals:Z?.equals??u,controller:void 0,error:void 0,stop:void 0},X=Z?.watched,H=X?()=>{if(C){if(!J.sinks)J.stop=X(()=>{if(w(J),A===0)L()});I(J,C)}}:()=>{if(C)I(J,C)};return{[Symbol.toStringTag]:t,get(){if(H(),T(J),J.error)throw J.error;return D$(t,J.value),J.value},isPending(){return!!J.controller},abort(){J.controller?.abort(),J.controller=void 0}}}function u$($){return S($,t)}function c$($,Z){k(e,Z);let J=X$(Z),X=new Map,H=[],W=(G)=>{let B=J?Y$(async(V,D)=>{let P=$.byKey(G)?.get();if(P==null)return V;return Z(P,D)}):i(()=>{let V=$.byKey(G)?.get();if(V==null)return;return Z(V)});X.set(G,B)};function M(G){if(!d$(H,G)){let B=new Set(H),V=new Set(G);for(let D of H)if(!V.has(D))X.delete(D);for(let D of G)if(!B.has(D))W(D);H=G,U.flags|=y}}function z(){M(Array.from($.keys()));let G=[];for(let B of H)try{let V=X.get(B)?.get();if(V!=null)G.push(V)}catch(V){if(!(V instanceof H$))throw V}return G}let U={fn:z,value:[],flags:O,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:(G,B)=>{if(G.length!==B.length)return!1;for(let V=0;V<G.length;V++)if(G[V]!==B[V])return!1;return!0},error:void 0};function Q(){if(U.sources){if(U.flags)if(U.value=s(z),U.flags&y){if(U.flags=O,T(U),U.error)throw U.error}else U.flags=g}else if(U.sinks){if(T(U),U.error)throw U.error}else U.value=s(z)}let j=Array.from(s(()=>$.keys()));for(let G of j)W(G);H=j;let K={[Symbol.toStringTag]:e,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let G of H){let B=X.get(G);if(B)yield B}},get length(){if(C)I(U,C);return Q(),H.length},keys(){if(C)I(U,C);return Q(),H.values()},get(){if(C)I(U,C);return Q(),U.value},at(G){return X.get(H[G])},byKey(G){return X.get(G)},keyAt(G){return H[G]},indexOfKey(G){return H.indexOf(G)},deriveCollection(G){return c$(K,G)}};return K}function PZ($,Z){let J=Z?.value??[];if(J.length)N(e,J,Array.isArray);k(e,$,G$);let X=new Map,H=[],W=new Map,[M,z]=QZ(Z?.keyConfig),q=(B)=>W.get(B)??(z?M(B):void 0),U=Z?.createItem??E;function Q(){let B=[];for(let V of H)try{let D=X.get(V)?.get();if(D!=null)B.push(D)}catch(D){if(!(D instanceof H$))throw D}return B}let j={fn:Q,value:J,flags:O,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:jZ,error:void 0};for(let B of J){let V=M(B);X.set(V,U(B)),W.set(B,V),H.push(V)}j.value=J,j.flags=O;function K(){if(C){if(!j.sinks)j.stop=$((B)=>{let{add:V,change:D,remove:P}=B;if(!V?.length&&!D?.length&&!P?.length)return;let Y=!1;o(()=>{if(V)for(let F of V){let b=M(F);if(X.set(b,U(F)),W.set(F,b),!H.includes(b))H.push(b);Y=!0}if(D)for(let F of D){let b=q(F);if(!b)continue;let h=X.get(b);if(h&&P$(h))W.delete(h.get()),h.set(F),W.set(F,b)}if(P)for(let F of P){let b=q(F);if(!b)continue;W.delete(F),X.delete(b);let h=H.indexOf(b);if(h!==-1)H.splice(h,1);Y=!0}j.flags=O|(Y?y:0);for(let F=j.sinks;F;F=F.nextSink)w(F.sink)})});I(j,C)}}let G={[Symbol.toStringTag]:e,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let B of H){let V=X.get(B);if(V)yield V}},get length(){return K(),H.length},keys(){return K(),H.values()},get(){if(K(),j.sources){if(j.flags){let B=j.flags&y;if(j.value=s(Q),B){if(j.flags=O,T(j),j.error)throw j.error}else j.flags=g}}else if(T(j),j.error)throw j.error;return j.value},at(B){return X.get(H[B])},byKey(B){return X.get(B)},keyAt(B){return H[B]},indexOfKey(B){return H.indexOf(B)},deriveCollection(B){return c$(G,B)}};return G}function OZ($){return S($,e)}function T$($){k("Effect",$);let Z={fn:$,flags:O,sources:null,sourcesTail:null,cleanup:null},J=()=>{g$(Z),Z.fn=void 0,Z.flags=g,Z.sourcesTail=null,C$(Z)};if(c)M$(c,J);return BZ(Z),J}function YZ($,Z){if(!c)throw new k$("match");let{ok:J,err:X=console.error,nil:H}=Z,W,M=!1,z=Array($.length);for(let U=0;U<$.length;U++)try{z[U]=$[U].get()}catch(Q){if(Q instanceof H$){M=!0;continue}if(!W)W=[];W.push(Q instanceof Error?Q:Error(String(Q)))}let q;try{if(M)q=H?.();else if(W)q=X(W);else q=J(z)}catch(U){X([U instanceof Error?U:Error(String(U))])}if(typeof q==="function")return q;if(q instanceof Promise){let U=c,Q=new AbortController;M$(U,()=>Q.abort()),q.then((j)=>{if(!Q.signal.aborted&&typeof j==="function")M$(U,j)}).catch((j)=>{X([j instanceof Error?j:Error(String(j))])})}}function o$($,Z){if(k(a,$,G$),Z?.value!==void 0)N(a,Z.value,Z?.guard);let J={value:Z?.value,sinks:null,sinksTail:null,equals:Z?.equals??u,guard:Z?.guard,stop:void 0};return{[Symbol.toStringTag]:a,get(){if(C){if(!J.sinks)J.stop=$((X)=>{N(a,X,J.guard),L$(J,X)});I(J,C)}return D$(a,J.value),J.value}}}function NZ($){return S($,a)}function fZ($,Z){let J=_($)||Array.isArray($),X=_(Z)||Array.isArray(Z);if(!J||!X){let j=!Object.is($,Z);return{changed:j,add:j&&X?Z:{},change:{},remove:j&&J?$:{}}}let H=new WeakSet,W={},M={},z={},q=!1,U=Object.keys($),Q=Object.keys(Z);for(let j of Q)if(j in $){if(!J$($[j],Z[j],H))M[j]=Z[j],q=!0}else W[j]=Z[j],q=!0;for(let j of U)if(!(j in Z))z[j]=void 0,q=!0;return{add:W,change:M,remove:z,changed:q}}function S$($,Z){N($$,$,_);let J=new Map,X=(Q,j)=>{if(N(`${$$} for key "${Q}"`,j),Array.isArray(j))J.set(Q,O$(j));else if(_(j))J.set(Q,S$(j));else J.set(Q,E(j))},H=()=>{let Q={};return J.forEach((j,K)=>{Q[K]=j.get()}),Q},W={fn:H,value:$,flags:O,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:J$,error:void 0},M=(Q)=>{let j=!1;for(let K in Q.add)X(K,Q.add[K]),j=!0;if(Object.keys(Q.change).length)o(()=>{for(let K in Q.change){let G=Q.change[K];N(`${$$} for key "${K}"`,G);let B=J.get(K);if(B)if(_(G)!==b$(B))X(K,G),j=!0;else B.set(G)}});for(let K in Q.remove)J.delete(K),j=!0;if(j)W.flags|=y;return Q.changed},z=Z?.watched,q=z?()=>{if(C){if(!W.sinks)W.stop=z();I(W,C)}}:()=>{if(C)I(W,C)};for(let Q of Object.keys($))X(Q,$[Q]);let U={[Symbol.toStringTag]:$$,[Symbol.isConcatSpreadable]:!1,*[Symbol.iterator](){for(let Q of Array.from(J.keys())){let j=J.get(Q);if(j)yield[Q,j]}},keys(){return q(),J.keys()},byKey(Q){return J.get(Q)},get(){if(q(),W.sources){if(W.flags){let Q=W.flags&y;if(W.value=s(H),Q){if(W.flags=O,T(W),W.error)throw W.error}else W.flags=g}}else if(T(W),W.error)throw W.error;return W.value},set(Q){let j=W.flags&O?H():W.value,K=fZ(j,Q);if(M(K)){W.flags|=O;for(let G=W.sinks;G;G=G.nextSink)w(G.sink);if(A===0)L()}},update(Q){U.set(Q(U.get()))},add(Q,j){if(J.has(Q))throw new z$($$,Q,j);X(Q,j),W.flags|=O|y;for(let K=W.sinks;K;K=K.nextSink)w(K.sink);if(A===0)L();return Q},remove(Q){if(J.delete(Q)){W.flags|=O|y;for(let K=W.sinks;K;K=K.nextSink)w(K.sink);if(A===0)L()}}};return new Proxy(U,{get(Q,j){if(j in Q)return Reflect.get(Q,j);if(typeof j!=="symbol")return Q.byKey(j)},has(Q,j){if(j in Q)return!0;return Q.byKey(String(j))!==void 0},ownKeys(Q){return Array.from(Q.keys())},getOwnPropertyDescriptor(Q,j){if(j in Q)return Reflect.getOwnPropertyDescriptor(Q,j);if(typeof j==="symbol")return;let K=Q.byKey(String(j));return K?{enumerable:!0,configurable:!0,writable:!0,value:K}:void 0}})}function b$($){return S($,$$)}function N$($,Z){return X$($)?Y$($,Z):i($,Z)}function FZ($){if(U$($))return $;if($==null||x($)||d($))throw new K$("createMutableSignal",$);if(CZ($))return O$($);if(_($))return S$($);return E($)}function s$($){return W$($)||u$($)}function d($){let Z=[r,n,t,a,Z$,p,e,$$],J=Object.prototype.toString.call($).slice(8,-1);return Z.includes(J)}function U$($){return P$($)||b$($)||_$($)}function i$($,Z){N(Z$,$,d);let J=$,X=Z?.guard,H={fn:()=>J.get(),value:void 0,flags:O,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:Z?.equals??u,error:void 0},W=()=>{if(C)I(H,C);if(T(H),H.error)throw H.error;return H.value},M=(q)=>{if(!U$(J))throw new h$(Z$);N(Z$,q,X),J.set(q)},z=(q)=>{N(Z$,q,d),J=q,H.flags|=O;for(let U=H.sinks;U;U=U.nextSink)w(U.sink);if(A===0)L()};return{[Symbol.toStringTag]:Z$,configurable:!0,enumerable:!0,get:W,set:M,replace:z,current:()=>J}}function F$($){return S($,Z$)}var j$=!1,EZ="debug";var x$="warn",I$="error",hZ=new Set(["constructor","prototype"]),kZ=new Set(["id","class","className","title","role","style","dataset","lang","dir","hidden","children","innerHTML","outerHTML","textContent","innerText"]),pZ=($)=>$?`#${$}`:"",gZ=($)=>$?.length?`.${Array.from($).join(".")}`:"";var zZ=($)=>$.localName.includes("-"),qZ=($)=>zZ($)&&$.matches(":not(:defined)"),R=($)=>$?`<${$.localName}${pZ($.id)}${gZ($.classList)}>`:"<unknown>";var A$=($,Z,J=EZ)=>{if(j$||[I$,x$].includes(J))console[J](Z,$);return $},xZ=($)=>{if(hZ.has($))return`Property name "${$}" is a reserved word`;if(kZ.has($))return`Property name "${$}" conflicts with inherited HTMLElement property`;return null};class l$ extends TypeError{constructor($){super(`Invalid component name "${$}". Custom element names must contain a hyphen, start with a lowercase letter, and contain only lowercase letters, numbers, and hyphens.`);this.name="InvalidComponentNameError"}}class r$ extends TypeError{constructor($,Z,J){super(`Invalid property name "${Z}" for component <${$}>. ${J}`);this.name="InvalidPropertyNameError"}}class n$ extends TypeError{constructor($,Z){super(`Invalid effects in component ${R($)}. Effects must be a record of effects for UI elements or the component, or a Promise that resolves to effects.`);if(this.name="InvalidEffectsError",Z)this.cause=Z}}class IZ extends TypeError{constructor($,Z,J){super(`Invalid UI key "${Z}" in ${J} of component ${R($)}`);this.name="InvalidUIKeyError"}}class y$ extends Error{constructor($,Z,J){super(`Missing required element <${Z}> in component ${R($)}. ${J}`);this.name="MissingElementError"}}class t$ extends Error{constructor($,Z){super(`Timeout waiting for: [${Z.join(", ")}] in component ${R($)}.`);this.name="DependencyTimeoutError"}}class a$ extends TypeError{constructor($,Z,J){super(`Expected reactives passed from ${R($)} to ${R(Z)} to be a record of signals, reactive property names or functions. Got ${l(J)}.`);this.name="InvalidReactivesError"}}class e$ extends TypeError{constructor($,Z){super(`Target ${R($)} is not a custom element in ${Z}.`);this.name="InvalidCustomElementError"}}var MZ=Symbol("RESET"),vZ=($,Z="")=>{return{a:"attribute ",c:"class ",d:"dataset ",h:"inner HTML",m:"method call ",p:"property ",s:"style property ",t:"text content"}[$]+Z},AZ=($,Z)=>{if(!_(Z))throw new n$($.host);return v$(()=>{for(let J of Object.keys(Z)){let X=J;if(!Z[X])continue;let H=Array.isArray(Z[X])?Z[X]:[Z[X]];if(W$($[X]))T$(()=>{for(let W of $[X].get())for(let M of H)M($.host,W)});else if($[X])for(let W of H)W($.host,$[X])}})},dZ=($,Z,J,X)=>{try{return typeof $==="string"?Z[$]:d($)?$.get():x($)?$(J):MZ}catch(H){if(X)A$(H,`Failed to resolve value of ${l($)}${X?` for ${X}`:""} in ${R(J)}${Z!==J?` in ${R(Z)}`:""}`,I$);return MZ}},m=($,Z)=>(J,X)=>{let{op:H,name:W="",read:M,update:z}=Z,q=vZ(H,W),U=(K)=>()=>{if(j$&&J.debug)A$(X,`${K} ${q} of ${R(X)} in ${R(J)}`);Z.resolve?.(X)},Q=(K)=>(G)=>{A$(G,`Failed to ${K} ${q} of ${R(X)} in ${R(J)}`,I$),Z.reject?.(G)},j=M(X);return T$(()=>{let K=dZ($,J,X,q),G=K===MZ?j:K===null?Z.delete?null:j:K;if(Z.delete&&G===null)try{Z.delete(X),U("delete")()}catch(B){Q("delete")(B)}else if(G!=null){let B=M(X);if(Object.is(G,B))return;try{z(X,G),U("update")()}catch(V){Q("update")(V)}}})};var wZ=new WeakMap,m$=($)=>{let Z=wZ.get($);if(!Z)Z={},wZ.set($,Z);return Z};var w$=($)=>x($)&&$.length>=2,cZ=($)=>x($),f=($,Z)=>cZ(Z)?Z($):Z,uZ=($,Z)=>(J)=>{let X=$(J);return typeof X==="string"&&w$(Z)?Z(J,X):X??f(J,Z)};var oZ=200,sZ=($)=>{let Z=new Set;if($.includes("."))Z.add("class");if($.includes("#"))Z.add("id");if($.includes("[")){let J=$.split("[");for(let X=1;X<J.length;X++){let H=J[X];if(!H.includes("]"))continue;let W=H.split("=")[0].trim().replace(/[^a-zA-Z0-9_-]/g,"");if(W)Z.add(W)}}return[...Z]};function RZ($,Z){return i(()=>Array.from($.querySelectorAll(Z)),{value:[],equals:(J,X)=>J.length===X.length&&J.every((H,W)=>H===X[W]),watched:(J)=>{let X={childList:!0,subtree:!0},H=sZ(Z);if(H.length)X.attributes=!0,X.attributeFilter=H;let W=(q)=>q instanceof Element&&(q.matches(Z)||q.querySelector(Z)),M=(q)=>{if(q.type==="attributes")return!0;if(q.type==="childList")return Array.from(q.addedNodes).some(W)||Array.from(q.removedNodes).some(W);return!1},z=new MutationObserver((q)=>{for(let U of q)if(M(U)){J();return}});return z.observe($,X),()=>z.disconnect()}})}var LZ=($)=>{let Z=$.shadowRoot??$,J=new Set;function X(M,z){let q=Z.querySelector(M);if(z!=null&&!q)throw new y$($,M,z);if(q&&qZ(q))J.add(q.localName);return q??void 0}function H(M,z){let q=RZ(Z,M),U=q.get();if(z!=null&&!U.length)throw new y$($,M,z);if(U.length){for(let Q of U)if(qZ(Q))J.add(Q.localName)}return q}return[{first:X,all:H},(M)=>{if(J.size)queueMicrotask(()=>{let z=Array.from(J).filter((q)=>!customElements.get(q));if(!z.length){M();return}Promise.race([Promise.all(z.map((q)=>customElements.whenDefined(q))),new Promise((q,U)=>{setTimeout(()=>{U(new t$($,z.filter((Q)=>!customElements.get(Q))))},oZ)})]).then(M).catch((q)=>{if(j$)console[x$](q);M()})});else M()}]};function iZ($,Z={},J=()=>({}),X=()=>({})){if(!$.includes("-")||!$.match(/^[a-z][a-z0-9-]*$/))throw new l$($);for(let W of Object.keys(Z)){let M=xZ(W);if(M)throw new r$($,W,M)}class H extends HTMLElement{debug;#$;#Z;static observedAttributes=Object.entries(Z)?.filter(([,W])=>w$(W)).map(([W])=>W)??[];connectedCallback(){let[W,M]=LZ(this),z={...J(W),host:this};this.#$=z,Object.freeze(this.#$);let q=(Q)=>{return x(Q)},U=(Q,j)=>{let K=w$(j)?j(z,this.getAttribute(Q)):q(j)?j(z):j;if(K!=null)this.#J(Q,K)};for(let[Q,j]of Object.entries(Z)){if(j==null||Q in this)continue;U(Q,j)}M(()=>{this.#Z=AZ(z,X(z))})}disconnectedCallback(){if(x(this.#Z))this.#Z()}attributeChangedCallback(W,M,z){if(!this.#$||z===M||s$(m$(this)[W]))return;let q=Z[W];if(!w$(q))return;let U=q(this.#$,z,M);if(W in this)this[W]=U;else this.#J(W,U)}#J(W,M){let z=d(M)?M:x(M)?N$(M):E(M),q=m$(this),U=W,Q=q[U];if(F$(Q))Q.replace(z);else if(U$(z)){let j=i$(z);q[U]=j,Object.defineProperty(this,W,j)}else q[U]=z,Object.defineProperty(this,W,{get:z.get,enumerable:!0})}}return customElements.define($,H),customElements.get($)}var $Z="context-request";class UZ extends Event{context;callback;subscribe;constructor($,Z,J=!1){super($Z,{bubbles:!0,composed:!0});this.context=$,this.callback=Z,this.subscribe=J}}var lZ=($)=>(Z)=>{let J=(X)=>{let{context:H,callback:W}=X;if(typeof H==="string"&&$.includes(H)&&x(W))X.stopImmediatePropagation(),W(()=>Z[H])};return Z.addEventListener($Z,J),()=>Z.removeEventListener($Z,J)},rZ=($,Z)=>(J)=>{let X=()=>f(J,Z);return J.host.dispatchEvent(new UZ($,(H)=>{X=H})),i(X)};var nZ=($)=>{if(/^(mailto|tel):/i.test($))return!0;if($.includes("://"))try{let Z=new URL($,window.location.origin);return["http:","https:","ftp:"].includes(Z.protocol)}catch{return!1}return!0},tZ=($,Z,J)=>{if(/^on/i.test(Z))throw Error(`Unsafe attribute: ${Z}`);if(J=String(J).trim(),!nZ(J))throw Error(`Unsafe URL for ${Z}: ${J}`);$.setAttribute(Z,J)},aZ=($,Z=$)=>m(Z,{op:"a",name:$,read:(J)=>J.getAttribute($),update:(J,X)=>{tZ(J,$,X)},delete:(J)=>{J.removeAttribute($)}}),eZ=($,Z=$)=>m(Z,{op:"a",name:$,read:(J)=>J.hasAttribute($),update:(J,X)=>{J.toggleAttribute($,X)}});var $4=($,Z=$)=>m(Z,{op:"c",name:$,read:(J)=>J.classList.contains($),update:(J,X)=>{J.classList.toggle($,X)}});var JZ=new Set(["scroll","resize","mousewheel","touchstart","touchmove","wheel"]),VZ=new Set,_Z=new WeakMap,ZZ,Z4=()=>{ZZ=void 0;let $=Array.from(VZ);VZ.clear();for(let Z of $)_Z.get(Z)?.()},J4=()=>{if(ZZ)cancelAnimationFrame(ZZ);ZZ=requestAnimationFrame(Z4)},V$=($,Z)=>{_Z.set($,Z),VZ.add($),J4()};var X4=($,Z,J={})=>(X,H)=>{if(!("passive"in J))J={...J,passive:JZ.has($)};let W=(M)=>{let z=()=>{let q=Z(M);if(!_(q))return;o(()=>{for(let[U,Q]of Object.entries(q))try{X[U]=Q}catch(j){A$(j,`Reactive property "${U}" on ${R(X)} from event ${$} on ${R(H)} could not be set, because it is read-only.`,I$)}})};if(J.passive)V$(H,z);else z()};return H.addEventListener($,W,J),()=>H.removeEventListener($,W)};var H4=($,Z={})=>m($,{op:"h",read:(J)=>(J.shadowRoot||!Z.shadowRootMode?J:null)?.innerHTML??"",update:(J,X)=>{let{shadowRootMode:H,allowScripts:W}=Z;if(!X){if(J.shadowRoot)J.shadowRoot.innerHTML="<slot></slot>";return""}if(H&&!J.shadowRoot)J.attachShadow({mode:H});let M=J.shadowRoot||J;return V$(J,()=>{if(M.innerHTML=X,W){let z=["type","src","async","defer","nomodule","crossorigin","integrity","referrerpolicy","fetchpriority"];M.querySelectorAll("script").forEach((q)=>{let U=document.createElement("script");for(let Q of z)if(q.hasAttribute(Q))U.setAttribute(Q,q.getAttribute(Q));if(!q.hasAttribute("src"))U.appendChild(document.createTextNode(q.textContent??""));M.appendChild(U),q.remove()})}}),W?" with scripts":""}});var W4=($)=>(Z,J)=>{if(!zZ(J))throw new e$(J,`pass from ${R(Z)}`);let X=x($)?$(J):$;if(!_(X))throw new a$(Z,J,X);let H=(z)=>{if(d(z))return z;let q=typeof z==="string"&&z in Z?()=>Z[z]:x(z)?z:void 0;return q?N$(q):void 0},W=m$(J),M=R(J);for(let[z,q]of Object.entries(X)){if(q==null)continue;if(!(z in J)){if(j$)console[x$](`pass(): property '${z}' does not exist on ${M}`);continue}let U=x(q)&&q.length===1?q(J):q,Q=Array.isArray(U)&&U.length===2,j=H(Q?U[0]:U);if(!j)continue;let K=W[z];if(F$(K))K.replace(j);else if(j$)console[x$](`pass(): property '${z}' on ${M} has no Slot â€” binding skipped`)}};var j4=($,Z=$)=>m(Z,{op:"p",name:$,read:(J)=>($ in J)?J[$]??null:null,update:(J,X)=>{J[$]=X}}),B4=($)=>m($,{op:"p",name:"hidden",read:(Z)=>!Z.hidden,update:(Z,J)=>{Z.hidden=!J}});var Q4=($,Z=$)=>m(Z,{op:"s",name:$,read:(J)=>J.style.getPropertyValue($),update:(J,X)=>{J.style.setProperty($,X)},delete:(J)=>{J.style.removeProperty($)}});var z4=($)=>m($,{op:"t",read:(Z)=>Z.textContent,update:(Z,J)=>{Array.from(Z.childNodes).filter((X)=>X.nodeType!==Node.COMMENT_NODE).forEach((X)=>X.remove()),Z.append(document.createTextNode(J))}});var q4=($,Z,J)=>(X)=>{let{host:H}=X,W=f(X,$),M=W$(X[Z])?X[Z]:null,z=M?null:X[Z],q=new Map,U=(Q)=>{if(z)return z.contains(Q)?z:void 0;for(let j of M.get())if(j.contains(Q))return j};return o$((Q)=>{for(let[j,K]of Object.entries(J)){let G={passive:JZ.has(j)},B=(V)=>{let D=V.target;if(!D)return;let P=U(D);if(!P)return;V.stopPropagation();let Y=()=>{try{let F=K({event:V,ui:X,target:P,prev:W});if(F==null||F instanceof Promise)return;if(!Object.is(F,W))W=F,Q(F)}catch(F){throw V.stopImmediatePropagation(),F}};if(G.passive)V$(H,Y);else Y()};q.set(j,B),H.addEventListener(j,B,G)}return()=>{if(q.size){for(let[j,K]of q)H.removeEventListener(j,K);q.clear()}}},{value:W})};var M4=()=>($,Z)=>Z!=null&&Z!=="false";var U4=($)=>(Z,J)=>{if((J??$)==null)throw TypeError("asJSON: Value and fallback are both null or undefined");if(J==null)return f(Z,$);if(J==="")throw TypeError("Empty string is not valid JSON");let X;try{X=JSON.parse(J)}catch(H){throw SyntaxError(`Failed to parse JSON: ${String(H)}`,{cause:H})}return X??f(Z,$)};var GZ=($,Z)=>{if(Z==null)return;let J=$(Z);return Number.isFinite(J)?J:void 0},V4=($=0)=>(Z,J)=>{if(J==null)return f(Z,$);let X=J.trim();if(X.toLowerCase().startsWith("0x"))return GZ((W)=>parseInt(W,16),X)??f(Z,$);let H=GZ(parseFloat,J);return H!=null?Math.trunc(H):f(Z,$)},G4=($=0)=>(Z,J)=>GZ(parseFloat,J)??f(Z,$);var K4=($="")=>(Z,J)=>J??f(Z,$),D4=($)=>(Z,J)=>{if(J==null)return $[0];let X=J.toLowerCase();return $.find((W)=>W.toLowerCase()===X)?J:$[0]};export{l as valueString,m as updateElement,$4 as toggleClass,eZ as toggleAttribute,B4 as show,z4 as setText,Q4 as setStyle,j4 as setProperty,aZ as setAttribute,V$ as schedule,rZ as requestContext,uZ as read,lZ as provideContexts,W4 as pass,X4 as on,YZ as match,u$ as isTask,b$ as isStore,P$ as isState,F$ as isSlot,d as isSignal,NZ as isSensor,_ as isRecord,w$ as isParser,U$ as isMutableSignal,W$ as isMemo,_$ as isList,x as isFunction,J$ as isEqual,s$ as isComputed,OZ as isCollection,X$ as isAsyncFunction,iZ as defineComponent,H4 as dangerouslySetInnerHTML,Y$ as createTask,S$ as createStore,E as createState,i$ as createSlot,o$ as createSensor,v$ as createScope,FZ as createMutableSignal,i as createMemo,O$ as createList,q4 as createEventsSensor,RZ as createElementsMemo,T$ as createEffect,N$ as createComputed,PZ as createCollection,o as batch,K4 as asString,G4 as asNumber,U4 as asJSON,V4 as asInteger,D4 as asEnum,M4 as asBoolean,f$ as NullishSignalValueError,y$ as MissingElementError,IZ as InvalidUIKeyError,K$ as InvalidSignalValueError,a$ as InvalidReactivesError,r$ as InvalidPropertyNameError,n$ as InvalidEffectsError,e$ as InvalidCustomElementError,l$ as InvalidComponentNameError,E$ as InvalidCallbackError,t$ as DependencyTimeoutError,UZ as ContextRequestEvent,Q$ as CircularDependencyError,$Z as CONTEXT_REQUEST};

//# debugId=D07B87BCE45252AF64756E2164756E21
