var R=($)=>typeof $==="string",W$=($)=>typeof $==="number",l=($)=>typeof $==="symbol",F=($)=>typeof $==="function",d=($)=>F($)&&$.constructor.name==="AsyncFunction",zZ=($)=>F($)&&$.constructor.name!=="AsyncFunction",c$=($)=>$!=null&&typeof $==="object",w=($,Z)=>Object.prototype.toString.call($)===`[object ${Z}]`,V=($)=>w($,"Object"),K$=($)=>V($)||Array.isArray($),s$=($,Z=(J)=>J!=null)=>Array.isArray($)&&$.every(Z);var t=($)=>$ instanceof DOMException&&$.name==="AbortError",E=($)=>R($)?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($);var B$,P$=new WeakMap,w$=new Set,r$=0,M=Symbol(),S="add",P="change",k="cleanup",_="remove",v="sort",I="watch",b=($)=>{let Z=new Set,J=$;return J.on=(B,X)=>{if(B===k)Z.add(X);else throw new W("watcher",B)},J.stop=()=>{try{for(let B of Z)B()}finally{Z.clear()}},J},U=($,Z)=>{if(!$.size&&Z?.size){let J=A(Z);if(J){let B=P$.get($)??new Set;if(B.add(J),!P$.has($))P$.set($,B)}}if(B$&&!$.has(B$)){let J=B$;J.on(k,()=>{if($.delete(J),!$.size){let B=P$.get($);if(B)try{for(let X of B)X()}finally{B.clear(),P$.delete($)}}}),$.add(J)}},L=($)=>{if(!$.size)return!1;for(let Z of $)if(r$)w$.add(Z);else Z();return!0},V$=()=>{while(w$.size){let $=Array.from(w$);w$.clear();for(let Z of $)Z()}},n=($)=>{r$++;try{$()}finally{V$(),r$--}},g=($,Z)=>{let J=B$;B$=$||void 0;try{Z()}finally{B$=J}},A=($,Z)=>{if(!$)return;let J=[],B=[],X=(Q)=>{if(B.length){if(B.length===1)throw B[0];throw AggregateError(B,`Errors in hook ${Q?"cleanup":"callback"}:`)}};for(let Q of $)try{let G=Q(Z);if(F(G))J.push(G)}catch(G){B.push(f(G))}if(X(),!J.length)return;if(J.length===1)return J[0];return()=>{for(let Q of J)try{Q()}catch(G){B.push(f(G))}X(!0)}},y=($,Z)=>Z.includes($);var O=($,Z,J)=>{if(Object.is($,Z))return!0;if(typeof $!==typeof Z)return!1;if(!c$($)||!c$(Z))return!1;if(!J)J=new WeakSet;if(J.has($)||J.has(Z))throw new p("isEqual");J.add($),J.add(Z);try{if(Array.isArray($)&&Array.isArray(Z)){if($.length!==Z.length)return!1;for(let B=0;B<$.length;B++)if(!O($[B],Z[B],J))return!1;return!0}if(Array.isArray($)!==Array.isArray(Z))return!1;if(V($)&&V(Z)){let B=Object.keys($),X=Object.keys(Z);if(B.length!==X.length)return!1;for(let Q of B){if(!(Q in Z))return!1;if(!O($[Q],Z[Q],J))return!1}return!0}return!1}finally{J.delete($),J.delete(Z)}},X$=($,Z)=>{let J=K$($),B=K$(Z);if(!J||!B){let x=!Object.is($,Z);return{changed:x,add:x&&B?Z:{},change:{},remove:x&&J?$:{}}}let X=new WeakSet,Q={},G={},q={},z=Object.keys($),Y=Object.keys(Z),j=new Set([...z,...Y]);for(let x of j){let D=x in $,N=x in Z;if(!D&&N){Q[x]=Z[x];continue}else if(D&&!N){q[x]=M;continue}let A$=$[x],C$=Z[x];if(!O(A$,C$,X))G[x]=C$}return{add:Q,change:G,remove:q,changed:!!(Object.keys(Q).length||Object.keys(G).length||Object.keys(q).length)}};var Q$="Computed";class m{#J=new Set;#B;#Z;#$;#X=!0;#G=!1;#Q;#q;constructor($,Z=M){c(this.constructor.name,$,i),H(this.constructor.name,Z),this.#B=$,this.#Z=Z}#z(){if(!this.#Q)this.#Q=b(()=>{if(this.#X=!0,!L(this.#J))this.#Q?.stop()}),this.#Q.on(k,()=>{this.#Q=void 0});return this.#Q}get[Symbol.toStringTag](){return Q$}get(){if(U(this.#J,this.#q),V$(),this.#X){let $=this.#z();g($,()=>{if(this.#G)throw new p("memo");let Z;this.#G=!0;try{Z=this.#B(this.#Z)}catch(J){this.#Z=M,this.#$=f(J),this.#G=!1;return}if(Z==null||M===Z)this.#Z=M,this.#$=void 0;else this.#Z=Z,this.#$=void 0,this.#X=!1;this.#G=!1})}if(this.#$)throw this.#$;return this.#Z}on($,Z){if($===I)return this.#q||=new Set,this.#q.add(Z),()=>{this.#q?.delete(Z)};throw new W(this.constructor.name,$)}}class o{#J=new Set;#B;#Z;#$;#X=!0;#G=!1;#Q=!1;#q;#z;#Y;constructor($,Z=M){c(this.constructor.name,$,q$),H(this.constructor.name,Z),this.#B=$,this.#Z=Z}#j(){if(!this.#q)this.#q=b(()=>{if(this.#X=!0,this.#z?.abort(),!L(this.#J))this.#q?.stop()}),this.#q.on(k,()=>{this.#z?.abort(),this.#z=void 0,this.#q=void 0});return this.#q}get[Symbol.toStringTag](){return Q$}get(){U(this.#J,this.#Y),V$();let $=(Q)=>{if(!O(Q,this.#Z))this.#Z=Q,this.#Q=!0;this.#$=void 0,this.#X=!1},Z=()=>{this.#Q=M!==this.#Z,this.#Z=M,this.#$=void 0},J=(Q)=>{let G=f(Q);this.#Q=!this.#$||G.name!==this.#$.name||G.message!==this.#$.message,this.#Z=M,this.#$=G},B=(Q)=>(G)=>{if(this.#G=!1,this.#z=void 0,Q(G),this.#Q&&!L(this.#J))this.#q?.stop()},X=()=>g(this.#j(),()=>{if(this.#G)throw new p("task");if(this.#Q=!1,this.#z)return this.#Z;this.#z=new AbortController,this.#z.signal.addEventListener("abort",()=>{this.#G=!1,this.#z=void 0,X()},{once:!0});let Q;this.#G=!0;try{Q=this.#B(this.#Z,this.#z.signal)}catch(G){if(t(G))Z();else J(G);this.#G=!1;return}if(Q instanceof Promise)Q.then(B($),B(J));else if(Q==null||M===Q)Z();else $(Q);this.#G=!1});if(this.#X)X();if(this.#$)throw this.#$;return this.#Z}on($,Z){if($===I)return this.#Y||=new Set,this.#Y.add(Z),()=>{this.#Y?.delete(Z)};throw new W(this.constructor.name,$)}}var O$=($,Z=M)=>d($)?new o($,Z):new m($,Z),G$=($)=>w($,Q$),i=($)=>zZ($)&&$.length<2,q$=($)=>d($)&&$.length<3;class N${signals=new Map;#J;#B;#Z=new Map;#$={};#X=!1;constructor($,Z,J){this.#J=Z,this.#B=J,this.change({add:$,change:{},remove:{},changed:!0},!0)}#G($){let Z=b(()=>{g(Z,()=>{if(this.signals.get($)?.get(),!this.#X)A(this.#$.change,[$])})});this.#Z.set($,Z),Z()}add($,Z){if(!this.#J($,Z))return!1;if(this.signals.set($,this.#B(Z)),this.#$.change?.size)this.#G($);if(!this.#X)A(this.#$.add,[$]);return!0}remove($){if(!this.signals.delete($))return!1;let J=this.#Z.get($);if(J)J.stop(),this.#Z.delete($);if(!this.#X)A(this.#$.remove,[$]);return!0}change($,Z){if(this.#X=!0,Object.keys($.add).length){for(let B in $.add)this.add(B,$.add[B]);let J=()=>A(this.#$.add,Object.keys($.add));if(Z)setTimeout(J,0);else J()}if(Object.keys($.change).length)n(()=>{for(let J in $.change){let B=$.change[J];if(!this.#J(J,B))continue;let X=this.signals.get(J);if(l$(`list item "${J}"`,B,X))X.set(B)}}),A(this.#$.change,Object.keys($.change));if(Object.keys($.remove).length){for(let J in $.remove)this.remove(J);A(this.#$.remove,Object.keys($.remove))}return this.#X=!1,$.changed}clear(){let $=Array.from(this.signals.keys());return this.signals.clear(),this.#Z.clear(),A(this.#$.remove,$),!0}on($,Z){if(!y($,[S,P,_]))throw new W("Composite",$);if(this.#$[$]||=new Set,this.#$[$].add(Z),$===P&&!this.#Z.size){this.#X=!0;for(let J of this.signals.keys())this.#G(J);this.#X=!1}return()=>{if(this.#$[$]?.delete(Z),$===P&&!this.#$.change?.size){if(this.#Z.size){for(let J of this.#Z.values())J.stop();this.#Z.clear()}}}}}var z$="State";class h{#J=new Set;#B;#Z;constructor($){H(z$,$),this.#B=$}get[Symbol.toStringTag](){return z$}get(){return U(this.#J,this.#Z),this.#B}set($){if(H(z$,$),O(this.#B,$))return;if(this.#B=$,this.#J.size)L(this.#J);if(M===this.#B)this.#J.clear()}update($){c(`${z$} update`,$),this.set($(this.#B))}on($,Z){if($===I)return this.#Z||=new Set,this.#Z.add(Z),()=>{this.#Z?.delete(Z)};throw new W(this.constructor.name,$)}}var a=($)=>w($,z$);var Y$="List";class j${#J;#B=new Set;#Z={};#$=[];#X;constructor($,Z){H(Y$,$,Array.isArray);let J=0;this.#X=R(Z)?()=>`${Z}${J++}`:F(Z)?(B)=>Z(B):()=>String(J++),this.#J=new N$(this.#G($),(B,X)=>{return H(`${Y$} for key "${B}"`,X),!0},(B)=>new h(B))}#G($){let Z={};for(let J=0;J<$.length;J++){let B=$[J];if(B===void 0)continue;let X=this.#$[J];if(!X)X=this.#X(B),this.#$[J]=X;Z[X]=B}return Z}get#Q(){return this.#$.map(($)=>this.#J.signals.get($)?.get()).filter(($)=>$!==void 0)}get[Symbol.toStringTag](){return Y$}get[Symbol.isConcatSpreadable](){return!0}*[Symbol.iterator](){for(let $ of this.#$){let Z=this.#J.signals.get($);if(Z)yield Z}}get length(){return U(this.#B,this.#Z[I]),this.#$.length}get(){return U(this.#B,this.#Z[I]),this.#Q}set($){if(M===$){this.#J.clear(),L(this.#B),this.#B.clear();return}let Z=this.#Q,J=X$(this.#G(Z),this.#G($)),B=Object.keys(J.remove);if(this.#J.change(J)){for(let Q of B){let G=this.#$.indexOf(Q);if(G!==-1)this.#$.splice(G,1)}this.#$=this.#$.filter(()=>!0),L(this.#B)}}update($){this.set($(this.get()))}at($){return this.#J.signals.get(this.#$[$])}keys(){return this.#$.values()}byKey($){return this.#J.signals.get($)}keyAt($){return this.#$[$]}indexOfKey($){return this.#$.indexOf($)}add($){let Z=this.#X($);if(this.#J.signals.has(Z))throw new e("store",Z,$);if(!this.#$.includes(Z))this.#$.push(Z);if(this.#J.add(Z,$))L(this.#B);return Z}remove($){let Z=W$($)?this.#$[$]:$;if(this.#J.remove(Z)){let B=W$($)?$:this.#$.indexOf(Z);if(B>=0)this.#$.splice(B,1);this.#$=this.#$.filter(()=>!0),L(this.#B)}}sort($){let J=this.#$.map((B)=>[B,this.#J.signals.get(B)?.get()]).sort(F($)?(B,X)=>$(B[1],X[1]):(B,X)=>String(B[1]).localeCompare(String(X[1]))).map(([B])=>B);if(!O(this.#$,J))this.#$=J,L(this.#B),A(this.#Z.sort,this.#$)}splice($,Z,...J){let B=this.#$.length,X=$<0?Math.max(0,B+$):Math.min($,B),Q=Math.max(0,Math.min(Z??Math.max(0,B-Math.max(0,X)),B-X)),G={},q={};for(let j=0;j<Q;j++){let x=X+j,D=this.#$[x];if(D){let N=this.#J.signals.get(D);if(N)q[D]=N.get()}}let z=this.#$.slice(0,X);for(let j of J){let x=this.#X(j);z.push(x),G[x]=j}z.push(...this.#$.slice(X+Q));let Y=!!(Object.keys(G).length||Object.keys(q).length);if(Y)this.#J.change({add:G,change:{},remove:q,changed:Y}),this.#$=z.filter(()=>!0),L(this.#B);return Object.values(q)}on($,Z){if(y($,[v,I]))return this.#Z[$]||=new Set,this.#Z[$].add(Z),()=>{this.#Z[$]?.delete(Z)};else if(y($,[S,P,_]))return this.#J.on($,Z);throw new W(Y$,$)}deriveCollection($){return new s(this,$)}}var R$=($)=>w($,Y$);var $$="Store";class t${#J;#B=new Set;#Z;constructor($){H($$,$,V),this.#J=new N$($,(Z,J)=>{return H(`${$$} for key "${Z}"`,J),!0},(Z)=>YZ(Z))}get#$(){let $={};for(let[Z,J]of this.#J.signals.entries())$[Z]=J.get();return $}get[Symbol.toStringTag](){return $$}get[Symbol.isConcatSpreadable](){return!1}*[Symbol.iterator](){for(let[$,Z]of this.#J.signals.entries())yield[$,Z]}keys(){return this.#J.signals.keys()}byKey($){return this.#J.signals.get($)}get(){return U(this.#B,this.#Z),this.#$}set($){if(M===$){this.#J.clear(),L(this.#B),this.#B.clear();return}let Z=this.#$;if(this.#J.change(X$(Z,$)))L(this.#B)}update($){this.set($(this.get()))}add($,Z){if(this.#J.signals.has($))throw new e($$,$,Z);if(this.#J.add($,Z))L(this.#B);return $}remove($){if(this.#J.remove($))L(this.#B)}on($,Z){if($===I)return this.#Z||=new Set,this.#Z.add(Z),()=>{this.#Z?.delete(Z)};else if(y($,[S,P,_]))return this.#J.on($,Z);throw new W($$,$)}}var S$=($)=>{let Z=new t$($);return new Proxy(Z,{get(J,B){if(B in J){let X=Reflect.get(J,B);return F(X)?X.bind(J):X}if(!l(B))return J.byKey(B)},has(J,B){if(B in J)return!0;return J.byKey(String(B))!==void 0},ownKeys(J){return Array.from(J.keys())},getOwnPropertyDescriptor(J,B){if(B in J)return Reflect.getOwnPropertyDescriptor(J,B);if(l(B))return;let X=J.byKey(String(B));return X?{enumerable:!0,configurable:!0,writable:!0,value:X}:void 0}})},Z$=($)=>w($,$$);var r=($)=>a($)||G$($)||Z$($),x$=($)=>a($)||Z$($)||R$($);function jZ($){if(i($))return new m($);if(q$($))return new o($);if(s$($))return new j$($);if(V($))return S$($);return new h($)}function YZ($){if(s$($))return new j$($);if(V($))return S$($);return new h($)}class p extends Error{constructor($){super(`Circular dependency detected in ${$}`);this.name="CircularDependencyError"}}class e extends Error{constructor($,Z,J){super(`Could not add ${$} key "${Z}"${J?` with value ${E(J)}`:""} because it already exists`);this.name="DuplicateKeyError"}}class M$ extends TypeError{constructor($,Z){super(`Invalid ${$} callback ${E(Z)}`);this.name="InvalidCallbackError"}}class _$ extends TypeError{constructor($,Z){super(`Invalid ${$} source ${E(Z)}`);this.name="InvalidCollectionSourceError"}}class W extends TypeError{constructor($,Z){super(`Invalid hook "${Z}" in  ${$}`);this.name="InvalidHookError"}}class E$ extends TypeError{constructor($,Z){super(`Invalid signal value ${E(Z)} in ${$}`);this.name="InvalidSignalValueError"}}class f$ extends TypeError{constructor($){super(`Nullish signal values are not allowed in ${$}`);this.name="NullishSignalValueError"}}class y$ extends Error{constructor($,Z){super(`Could not set ${$} to ${E(Z)} because signal is read-only`);this.name="ReadonlySignalError"}}var f=($)=>$ instanceof Error?$:Error(String($)),c=($,Z,J=F)=>{if(!J(Z))throw new M$($,Z)},H=($,Z,J=()=>!(l(Z)&&Z!==M)||F(Z))=>{if(Z==null)throw new f$($);if(!J(Z))throw new E$($,Z)},l$=($,Z,J)=>{if(!x$(J))throw new y$($,Z);return!0};var u="Collection";class s{#J=new Set;#B;#Z;#$=new Map;#X=new Map;#G={};#Q=[];constructor($,Z){if(c(u,Z),F($))$=$();if(!KZ($))throw new _$(u,$);this.#B=$,this.#Z=Z;for(let J=0;J<this.#B.length;J++){let B=this.#B.keyAt(J);if(!B)continue;this.#q(B)}this.#B.on(S,(J)=>{if(!J)return;for(let B of J)if(!this.#$.has(B)){this.#q(B);let X=this.#$.get(B);if(X&&xZ(this.#Z))X.get()}L(this.#J),A(this.#G.add,J)}),this.#B.on(_,(J)=>{if(!J)return;for(let B of J){if(!this.#$.has(B))continue;this.#$.delete(B);let X=this.#Q.indexOf(B);if(X>=0)this.#Q.splice(X,1);let Q=this.#X.get(B);if(Q)Q.stop(),this.#X.delete(B)}this.#Q=this.#Q.filter(()=>!0),L(this.#J),A(this.#G.remove,J)}),this.#B.on(v,(J)=>{if(J)this.#Q=[...J];L(this.#J),A(this.#G.sort,J)})}#q($){let Z=xZ(this.#Z)?async(B,X)=>{let Q=this.#B.byKey($)?.get();if(Q===M)return M;return this.#Z(Q,X)}:()=>{let B=this.#B.byKey($)?.get();if(B===M)return M;return this.#Z(B)},J=O$(Z);if(this.#$.set($,J),!this.#Q.includes($))this.#Q.push($);if(this.#G.change?.size)this.#z($);return!0}#z($){let Z=b(()=>{g(Z,()=>{this.#$.get($)?.get()})});this.#X.set($,Z),Z()}get[Symbol.toStringTag](){return u}get[Symbol.isConcatSpreadable](){return!0}*[Symbol.iterator](){for(let $ of this.#Q){let Z=this.#$.get($);if(Z)yield Z}}keys(){return this.#Q.values()}get(){return U(this.#J,this.#G[I]),this.#Q.map(($)=>this.#$.get($)?.get()).filter(($)=>$!=null&&$!==M)}at($){return this.#$.get(this.#Q[$])}byKey($){return this.#$.get($)}keyAt($){return this.#Q[$]}indexOfKey($){return this.#Q.indexOf($)}on($,Z){if(y($,[S,P,_,v,I])){if(this.#G[$]||=new Set,this.#G[$].add(Z),$===P&&!this.#X.size)for(let J of this.#$.keys())this.#z(J);return()=>{if(this.#G[$]?.delete(Z),$===P&&!this.#G.change?.size){if(this.#X.size){for(let J of this.#X.values())J.stop();this.#X.clear()}}}}throw new W(u,$)}deriveCollection($){return new s(this,$)}get length(){return U(this.#J,this.#G[I]),this.#Q.length}}var F$=($)=>w($,u),KZ=($)=>R$($)||F$($),xZ=($)=>d($);var m$="Ref";class L${#J=new Set;#B;#Z;constructor($,Z){H(m$,$,Z),this.#B=$}get[Symbol.toStringTag](){return m$}get(){return U(this.#J,this.#Z),this.#B}notify(){L(this.#J)}on($,Z){if($===I)return this.#Z||=new Set,this.#Z.add(Z),()=>{this.#Z?.delete(Z)};throw new W(m$,$)}}var b$=($)=>{if(!F($)||$.length>1)throw new M$("effect",$);let Z=d($),J=!1,B,X=b(()=>g(X,()=>{if(J)throw new p("effect");J=!0,B?.abort(),B=void 0;let Q;try{if(Z){B=new AbortController;let G=B;$(B.signal).then((q)=>{if(F(q)&&B===G)X.on(k,q)}).catch((q)=>{if(!t(q))console.error("Error in async effect callback:",q)})}else if(Q=$(),F(Q))X.on(k,Q)}catch(G){if(!t(G))console.error("Error in effect callback:",G)}J=!1}));return X(),()=>{B?.abort();try{X.stop()}catch(Q){console.error("Error in effect cleanup:",Q)}}};function MZ($,Z){try{if($.pending)Z.nil?.();else if($.errors)Z.err?.($.errors);else if($.ok)Z.ok($.values)}catch(J){let B=f(J);if(Z.err&&(!$.errors||!$.errors.includes(B)))Z.err($.errors?[...$.errors,B]:[B]);else throw B}}function FZ($){let Z=[],J=!1,B={};for(let[X,Q]of Object.entries($))try{let G=Q.get();if(G===M)J=!0;else B[X]=G}catch(G){Z.push(f(G))}if(J)return{ok:!1,pending:!0};if(Z.length>0)return{ok:!1,errors:Z};return{ok:!0,values:B}}var a$=!1,PZ="debug";var VZ="warn",D$="error",NZ=new Set(["constructor","prototype"]),RZ=new Set(["id","class","className","title","role","style","dataset","lang","dir","hidden","children","innerHTML","outerHTML","textContent","innerText"]),SZ=($)=>$?`#${$}`:"",_Z=($)=>$?.length?`.${Array.from($).join(".")}`:"";var g$=($)=>$.nodeType===Node.ELEMENT_NODE,e$=($)=>$.localName.includes("-"),$Z=($)=>e$($)&&$.matches(":not(:defined)"),K=($)=>$?`<${$.localName}${SZ($.id)}${_Z($.classList)}>`:"<unknown>";var I$=($,Z,J=PZ)=>{if(a$||[D$,VZ].includes(J))console[J](Z,$);return $},LZ=($)=>{if(NZ.has($))return`Property name "${$}" is a reserved word`;if(RZ.has($))return`Property name "${$}" conflicts with inherited HTMLElement property`;return null};class DZ extends Error{constructor($,Z){super(`Circular dependency detected in selection signal for component ${K($)} with selector "${Z}"`);this.name="CircularMutationError"}}class p$ extends TypeError{constructor($){super(`Invalid component name "${$}". Custom element names must contain a hyphen, start with a lowercase letter, and contain only lowercase letters, numbers, and hyphens.`);this.name="InvalidComponentNameError"}}class h$ extends TypeError{constructor($,Z,J){super(`Invalid property name "${Z}" for component <${$}>. ${J}`);this.name="InvalidPropertyNameError"}}class d$ extends TypeError{constructor($,Z){super(`Invalid effects in component ${K($)}. Effects must be a record of effects for UI elements or the component, or a Promise that resolves to effects.`);if(this.name="InvalidEffectsError",Z)this.cause=Z}}class k$ extends TypeError{constructor($,Z,J){super(`Invalid UI key "${Z}" in ${J} of component ${K($)}`);this.name="InvalidUIKeyError"}}class H$ extends Error{constructor($,Z,J){super(`Missing required element <${Z}> in component ${K($)}. ${J}`);this.name="MissingElementError"}}class v$ extends Error{constructor($,Z){super(`Timeout waiting for: [${Z.join(", ")}] in component ${K($)}.`);this.name="DependencyTimeoutError"}}class u$ extends TypeError{constructor($,Z,J){super(`Expected reactives passed from ${K($)} to ${K(Z)} to be a record of signals, reactive property names or functions. Got ${E(J)}.`);this.name="InvalidReactivesError"}}class n$ extends TypeError{constructor($,Z){super(`Target ${K($)} is not a custom element in ${Z}.`);this.name="InvalidCustomElementError"}}var ZZ=Symbol("RESET"),HZ=($,Z="")=>{return{a:"attribute ",c:"class ",d:"dataset ",h:"inner HTML",m:"method call ",p:"property ",s:"style property ",t:"text content"}[$]+Z},JZ=($,Z,J)=>{let B=[],X=(Q)=>{let G=Q($,Z);if(G)B.push(G)};if(Array.isArray(J))for(let Q of J)X(Q);else X(J);return()=>{B.forEach((Q)=>Q()),B.length=0}},TZ=($,Z,J)=>{let B=new Map,X=(G)=>{if(!G)return;for(let q of G){let z=Z.byKey(q)?.get();if(!z)continue;let Y=JZ($,z,J);if(Y)B.set(z,Y)}},Q=(G)=>{if(!G)return;for(let q of G){let z=Z.byKey(q)?.get();if(!z)continue;B.get(z)?.(),B.delete(z)}};return Z.on(S,X),Z.on(_,Q),X(Array.from(Z.keys())),()=>{for(let G of B.values())G();B.clear()}},BZ=($,Z)=>{if(!V(Z))throw new d$($.host);let J=[],B=Object.keys(Z);for(let X of B){if(!Z[X])continue;let Q=Array.isArray(Z[X])?Z[X]:[Z[X]],G=$[X];if(F$(G))J.push(TZ($.host,G,Q));else if(G){let q=JZ($.host,G,Q);if(q)J.push(q)}}return()=>{for(let X of J)X();J.length=0}},CZ=($,Z,J,B)=>{try{return R($)?Z[$]:r($)?$.get():F($)?$(J):ZZ}catch(X){if(B)I$(X,`Failed to resolve value of ${E($)}${B?` for ${B}`:""} in ${K(J)}${Z!==J?` in ${K(Z)}`:""}`,D$);return ZZ}},T=($,Z)=>(J,B)=>{let{op:X,name:Q="",read:G,update:q}=Z,z=HZ(X,Q),Y=(D)=>()=>{if(a$&&J.debug)I$(B,`${D} ${z} of ${K(B)} in ${K(J)}`);Z.resolve?.(B)},j=(D)=>(N)=>{I$(N,`Failed to ${D} ${z} of ${K(B)} in ${K(J)}`,D$),Z.reject?.(N)},x=G(B);return b$(()=>{let D=CZ($,J,B,z),N=D===ZZ?x:D===M?Z.delete?null:x:D;if(Z.delete&&N===null)try{Z.delete(B),Y("delete")()}catch(A$){j("delete")(A$)}else if(N!=null){let A$=G(B);if(Object.is(N,A$))return;try{q(B,N),Y("update")()}catch(C$){j("update")(C$)}}})};var U$=($)=>F($)&&$.length>=2,wZ=($)=>F($),C=($,Z)=>wZ(Z)?Z($):Z,OZ=($,Z)=>(J)=>{let B=$(J);return R(B)&&U$(Z)?Z(J,B):B??C(J,Z)};var EZ=($)=>{let Z=new Set;if($.includes("."))Z.add("class");if($.includes("#"))Z.add("id");if($.includes("[")){let J=$.split("[");for(let B=1;B<J.length;B++){let X=J[B];if(!X.includes("]"))continue;let Q=X.split("=")[0].trim().replace(/[^a-zA-Z0-9_-]/g,"");if(Q)Z.add(Q)}}return[...Z]};class IZ{#J=new Set;#B=new Map;#Z={};#$;#X;#G;#Q=[];#q;constructor($,Z,J){this.#$=$,this.#X=Z;let B=0;this.#q=R(J)?()=>`${J}${B++}`:F(J)?(X)=>J(X):()=>String(B++)}#z($){for(let[Z,J]of this.#B)if(J.get()===$)return Z;return}#Y(){Array.from(this.#$.querySelectorAll(this.#X)).forEach((J)=>{let B=this.#q(J);this.#B.set(B,new L$(J))});let $=(J)=>{let B=Array.from(J).filter(g$),X=[];for(let Q of B){if(Q.matches(this.#X))X.push(Q);X.push(...Array.from(Q.querySelectorAll(this.#X)))}return X};this.#G=new MutationObserver((J)=>{let B=[],X=[],Q=[],G=new Set,q=[],z=!1;for(let Y of J)if(Y.type==="childList"){let j=Y.target;if(g$(j)){let x=this.#z(j);if(x)G.add(x)}if(Y.addedNodes.length)B.push(...$(Y.addedNodes));if(Y.removedNodes.length)X.push(...$(Y.removedNodes))}else if(Y.type==="attributes"){let j=Y.target;if(g$(j)){let x=this.#z(j),D=j.matches(this.#X);if(x&&!D)this.#B.delete(x),X.push(j),q.push(x);else if(x&&D)G.add(x);else if(!x&&D){let N=this.#q(j);this.#B.set(N,new L$(j)),B.push(j),Q.push(N)}}}n(()=>{if(Q.length||q.length){if(z=!0,Q.length)A(this.#Z[S],Q);if(q.length)A(this.#Z[_],q)}if(this.#Z[P]?.size){A(this.#Z[P],Array.from(G));for(let j of G)if(j)this.#B.get(j)?.notify()}let Y=Array.from(this.#$.querySelectorAll(this.#X)).map((j)=>this.#z(j)).filter((j)=>j!==void 0);if(!O(this.#Q,Y))this.#Q=Y,z=!0,A(this.#Z[v],Y);if(z)L(this.#J)})});let Z=this.#Z[P]?.size?{attributes:!0,childList:!0,subtree:!0}:{childList:!0,subtree:!0};if(!this.#Z[P]?.size){let J=EZ(this.#X);if(J.length)Z.attributes=!0,Z.attributeFilter=J}this.#G.observe(this.#$,Z)}get[Symbol.toStringTag](){return u}get[Symbol.isConcatSpreadable](){return!0}*[Symbol.iterator](){for(let $ of this.#Q){let Z=this.#B.get($);if(Z)yield Z}}keys(){return this.#Q.values()}get(){if(U(this.#J,this.#Z[I]),!this.#G)this.#Y();return this.#Q.map(($)=>this.#B.get($)?.get()).filter(($)=>$!==void 0)}at($){return this.#B.get(this.#Q[$])}byKey($){return this.#B.get($)}keyAt($){return this.#Q[$]}indexOfKey($){return this.#Q.indexOf($)}on($,Z){if(y($,[S,P,_,v,I])){if(this.#Z[$]||=new Set,this.#Z[$].add(Z),!this.#G)this.#Y();return()=>{this.#Z[$]?.delete(Z)}}throw new W(u,$)}deriveCollection($){return new s(this,$)}get length(){if(U(this.#J,this.#Z[I]),!this.#G)this.#Y();return this.#B.size}}function XZ($,Z,J){return new IZ($,Z,J)}var fZ=50,UZ=($)=>{let Z=$.shadowRoot??$,J=new Set;function B(G,q){let z=Z.querySelector(G);if(q!=null&&!z)throw new H$($,G,q);if(z&&$Z(z))J.add(z.localName);return z??void 0}function X(G,q){let z=XZ(Z,G),Y=z.get();if(q!=null&&!Y.length)throw new H$($,G,q);if(Y.length)Y.forEach((j)=>{if($Z(j))J.add(j.localName)});return z}return[{first:B,all:X},(G)=>{if(J.size){let q=Array.from(J);Promise.race([Promise.all(q.map((z)=>customElements.whenDefined(z))),new Promise((z,Y)=>{setTimeout(()=>{Y(new v$($,q.filter((j)=>!customElements.get(j))))},fZ)})]).then(G).catch(()=>{G()})}else G()}]};function yZ($,Z={},J=()=>({}),B=()=>({})){if(!$.includes("-")||!$.match(/^[a-z][a-z0-9-]*$/))throw new p$($);for(let Q of Object.keys(Z)){let G=LZ(Q);if(G)throw new h$($,Q,G)}class X extends HTMLElement{debug;#J;#B={};#Z;static observedAttributes=Object.entries(Z)?.filter(([,Q])=>U$(Q)).map(([Q])=>Q)??[];connectedCallback(){let[Q,G]=UZ(this),q={...J(Q),host:this};this.#J=q,Object.freeze(this.#J);let z=(j)=>{return F(j)},Y=(j,x)=>{let D=U$(x)?x(q,this.getAttribute(j)):z(x)?x(q):x;if(D!=null)this.#$(j,D)};for(let[j,x]of Object.entries(Z)){if(x==null||j in this)continue;Y(j,x)}G(()=>{this.#Z=BZ(q,B(q))})}disconnectedCallback(){if(F(this.#Z))this.#Z()}attributeChangedCallback(Q,G,q){if(!this.#J||q===G||G$(this.#B[Q]))return;let z=Z[Q];if(!U$(z))return;let Y=z(this.#J,q,G);if(Q in this)this[Q]=Y;else this.#$(Q,Y)}#$(Q,G){let q=r(G)?G:i(G)?new m(G):q$(G)?new o(G):new h(G),z=this.#B[Q],Y=x$(q);if(this.#B[Q]=q,Object.defineProperty(this,Q,{get:q.get,set:Y?q.set:void 0,enumerable:!0,configurable:Y}),z&&a(z)||Z$(z))z.set(M)}}return customElements.define($,X),customElements.get($)}var o$="context-request";class QZ extends Event{context;callback;subscribe;constructor($,Z,J=!1){super(o$,{bubbles:!0,composed:!0});this.context=$,this.callback=Z,this.subscribe=J}}var mZ=($)=>(Z)=>{let J=(B)=>{let{context:X,callback:Q}=B;if(R(X)&&$.includes(X)&&F(Q))B.stopImmediatePropagation(),Q(()=>Z[X])};return Z.addEventListener(o$,J),()=>Z.removeEventListener(o$,J)},bZ=($,Z)=>(J)=>{let B=()=>C(J,Z);return J.host.dispatchEvent(new QZ($,(X)=>{B=X})),new m(B)};var gZ=($)=>{if(/^(mailto|tel):/i.test($))return!0;if($.includes("://"))try{let Z=new URL($,window.location.origin);return["http:","https:","ftp:"].includes(Z.protocol)}catch{return!1}return!0},pZ=($,Z,J)=>{if(/^on/i.test(Z))throw Error(`Unsafe attribute: ${Z}`);if(J=String(J).trim(),!gZ(J))throw Error(`Unsafe URL for ${Z}: ${J}`);$.setAttribute(Z,J)},hZ=($,Z=$)=>T(Z,{op:"a",name:$,read:(J)=>J.getAttribute($),update:(J,B)=>{pZ(J,$,B)},delete:(J)=>{J.removeAttribute($)}}),dZ=($,Z=$)=>T(Z,{op:"a",name:$,read:(J)=>J.hasAttribute($),update:(J,B)=>{J.toggleAttribute($,B)}});var kZ=($,Z=$)=>T(Z,{op:"c",name:$,read:(J)=>J.classList.contains($),update:(J,B)=>{J.classList.toggle($,B)}});var T$=new Set(["scroll","resize","mousewheel","touchstart","touchmove","wheel"]),GZ=new Set,AZ=new WeakMap,i$,vZ=()=>{i$=void 0;let $=Array.from(GZ);GZ.clear();for(let Z of $)AZ.get(Z)?.()},uZ=()=>{if(i$)cancelAnimationFrame(i$);i$=requestAnimationFrame(vZ)},J$=($,Z)=>{AZ.set($,Z),GZ.add($),uZ()};var nZ=($,Z,J={})=>(B,X)=>{if(!("passive"in J))J={...J,passive:T$.has($)};let Q=(G)=>{let q=()=>{let z=Z(G);if(!V(z))return;n(()=>{for(let[Y,j]of Object.entries(z))try{B[Y]=j}catch(x){I$(x,`Reactive property "${Y}" on ${K(B)} from event ${$} on ${K(X)} could not be set, because it is read-only.`,D$)}})};if(J.passive)J$(X,q);else q()};return X.addEventListener($,Q,J),()=>X.removeEventListener($,Q)};var oZ=($,Z={})=>T($,{op:"h",read:(J)=>(J.shadowRoot||!Z.shadowRootMode?J:null)?.innerHTML??"",update:(J,B)=>{let{shadowRootMode:X,allowScripts:Q}=Z;if(!B){if(J.shadowRoot)J.shadowRoot.innerHTML="<slot></slot>";return""}if(X&&!J.shadowRoot)J.attachShadow({mode:X});let G=J.shadowRoot||J;return J$(J,()=>{if(G.innerHTML=B,Q)G.querySelectorAll("script").forEach((q)=>{let z=document.createElement("script");z.appendChild(document.createTextNode(q.textContent??""));let Y=q.getAttribute("type");if(Y)z.setAttribute("type",Y);G.appendChild(z),q.remove()})}),Q?" with scripts":""}});var iZ=($)=>(Z,J)=>{if(!e$(J))throw new n$(J,`pass from ${K(Z)}`);let B=F($)?$(J):$;if(!V(B))throw new u$(Z,J,B);let X={},Q=(G)=>{if(r(G))return G.get;let q=R(G)&&G in Z?()=>Z[G]:i(G)?G:void 0;return q?new m(q).get:void 0};for(let[G,q]of Object.entries(B)){if(q==null)continue;let z=Object.getOwnPropertyDescriptor(J,G);if(!(G in J)||!z?.configurable)continue;let Y=F(q)&&q.length===1?q(J):q,j=Array.isArray(Y)&&Y.length===2,x=Q(j?Y[0]:Y),D=j&&F(Y[1])?Y[1]:void 0;if(!x)continue;X[G]=z,Object.defineProperty(J,G,{configurable:!0,enumerable:!0,get:x,set:D}),z.set?.call(J,M)}return()=>{Object.defineProperties(J,X)}};var cZ=($,Z=$)=>T(Z,{op:"p",name:$,read:(J)=>($ in J)?J[$]:M,update:(J,B)=>{J[$]=B}}),sZ=($)=>T($,{op:"p",name:"hidden",read:(Z)=>!Z.hidden,update:(Z,J)=>{Z.hidden=!J}});var rZ=($,Z=$)=>T(Z,{op:"s",name:$,read:(J)=>J.style.getPropertyValue($),update:(J,B)=>{J.style.setProperty($,B)},delete:(J)=>{J.style.removeProperty($)}});var lZ=($)=>T($,{op:"t",read:(Z)=>Z.textContent,update:(Z,J)=>{Array.from(Z.childNodes).filter((B)=>B.nodeType!==Node.COMMENT_NODE).forEach((B)=>B.remove()),Z.append(document.createTextNode(J))}});var tZ=()=>($,Z)=>Z!=null&&Z!=="false";var aZ=($)=>(Z,J)=>{if((J??$)==null)throw TypeError("asJSON: Value and fallback are both null or undefined");if(J==null)return C(Z,$);if(J==="")throw TypeError("Empty string is not valid JSON");let B;try{B=JSON.parse(J)}catch(X){throw SyntaxError(`Failed to parse JSON: ${String(X)}`,{cause:X})}return B??C(Z,$)};var qZ=($,Z)=>{if(Z==null)return;let J=$(Z);return Number.isFinite(J)?J:void 0},eZ=($=0)=>(Z,J)=>{if(J==null)return C(Z,$);let B=J.trim();if(B.toLowerCase().startsWith("0x"))return qZ((Q)=>parseInt(Q,16),B)??C(Z,$);let X=qZ(parseFloat,J);return X!=null?Math.trunc(X):C(Z,$)},$2=($=0)=>(Z,J)=>qZ(parseFloat,J)??C(Z,$);var Z2=($="")=>(Z,J)=>J??C(Z,$),J2=($)=>(Z,J)=>{if(J==null)return $[0];let B=J.toLowerCase();return $.find((Q)=>Q.toLowerCase()===B)?J:$[0]};function B2($,Z){let J=F$($)?$.get():[$];for(let B of J)if(B.contains(Z))return B}class WZ{#J=new Set;#B;#Z;#$=new Map;#X;constructor($,Z,J,B){if(!$[Z])throw new k$($.host,Z,"sensor");this.#Z=$.host,this.#B=B;let X=$[Z];for(let[Q,G]of Object.entries(J))this.#$.set(Q,this.#G(Q,G,$,X))}#G($,Z,J,B){let X=T$.has($);return(Q)=>{let G=Q.target;if(!G)return;let q=B2(B,G);if(!q)return;Q.stopPropagation();let z=()=>{try{let Y=Z({event:Q,ui:J,target:q,prev:this.#B});if(Y==null||Y instanceof Promise)return;if(!Object.is(Y,this.#B)){if(this.#B=Y,this.#J.size)L(this.#J);else if(this.#X)this.#X()}}catch(Y){throw Q.stopImmediatePropagation(),Y}};if(X)J$(this.#Z,z);else z()}}get[Symbol.toStringTag](){return Q$}get(){if(U(this.#J),this.#J.size&&!this.#X){for(let[$,Z]of this.#$){let J={passive:T$.has($)};this.#Z.addEventListener($,Z,J)}this.#X=()=>{for(let[$,Z]of this.#$)this.#Z.removeEventListener($,Z);this.#X=void 0}}return this.#B}}var X2=($,Z,J)=>(B)=>{let X=C(B,$);return new WZ(B,Z,J,X)};export{E as valueString,T as updateElement,kZ as toggleClass,dZ as toggleAttribute,sZ as show,lZ as setText,rZ as setStyle,cZ as setProperty,hZ as setAttribute,J$ as schedule,JZ as runElementEffects,BZ as runEffects,FZ as resolve,bZ as requestContext,OZ as read,mZ as provideContexts,iZ as pass,nZ as on,MZ as match,l as isSymbol,R as isString,Z$ as isStore,a as isState,r as isSignal,K$ as isRecordOrArray,V as isRecord,U$ as isParser,W$ as isNumber,x$ as isMutableSignal,F as isFunction,O as isEqual,G$ as isComputed,d as isAsyncFunction,t as isAbortError,X$ as diff,yZ as defineComponent,oZ as dangerouslySetInnerHTML,S$ as createStore,jZ as createSignal,X2 as createSensor,f as createError,XZ as createElementCollection,b$ as createEffect,O$ as createComputed,n as batchSignalWrites,Z2 as asString,$2 as asNumber,aZ as asJSON,eZ as asInteger,J2 as asEnum,tZ as asBoolean,M as UNSET,o as Task,h as State,L$ as Ref,y$ as ReadonlySignalError,f$ as NullishSignalValueError,H$ as MissingElementError,m as Memo,j$ as List,k$ as InvalidUIKeyError,E$ as InvalidSignalValueError,u$ as InvalidReactivesError,h$ as InvalidPropertyNameError,d$ as InvalidEffectsError,n$ as InvalidCustomElementError,p$ as InvalidComponentNameError,_$ as InvalidCollectionSourceError,M$ as InvalidCallbackError,e as DuplicateKeyError,s as DerivedCollection,v$ as DependencyTimeoutError,QZ as ContextRequestEvent,DZ as CircularMutationError,p as CircularDependencyError,o$ as CONTEXT_REQUEST};

//# debugId=3749C45885FA1B6964756E2164756E21
