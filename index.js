class N extends Error{constructor($){super(`Circular dependency detected in ${$}`);this.name="CircularDependencyError"}}class i extends TypeError{constructor($,J){super(`Invalid signal value ${J} in ${$}`);this.name="InvalidSignalValueError"}}class k extends TypeError{constructor($){super(`Nullish signal values are not allowed in ${$}`);this.name="NullishSignalValueError"}}class s extends Error{constructor($,J){super(`Could not add store key "${$}" with value ${J} because it already exists`);this.name="StoreKeyExistsError"}}class t extends RangeError{constructor($){super(`Could not remove store index ${String($)} because it is out of range`);this.name="StoreKeyRangeError"}}class l extends Error{constructor($,J){super(`Could not set store key "${$}" to ${J} because it is readonly`);this.name="StoreKeyReadonlyError"}}var A=Symbol(),h=($)=>typeof $==="string",G$=($)=>typeof $==="number",d=($)=>typeof $==="symbol",M=($)=>typeof $==="function",p=($)=>M($)&&$.constructor.name==="AsyncFunction",d$=($)=>!!$&&typeof $==="object",b=($,J)=>Object.prototype.toString.call($)===`[object ${J}]`,D=($)=>b($,"Object"),r=($)=>D($)||Array.isArray($),p$=($)=>{if(!$.length)return null;let J=$.map((X)=>h(X)?parseInt(X,10):G$(X)?X:NaN);return J.every((X)=>Number.isFinite(X)&&X>=0)?J.sort((X,B)=>X-B):null};var E=($)=>$ instanceof DOMException&&$.name==="AbortError",S=($)=>$ instanceof Error?$:Error(String($));var X$=($)=>{let J=p$(Object.keys($));if(J===null)return $;let X=[];for(let B of J)X.push($[String(B)]);return X},Z$=($)=>h($)?`"${$}"`:d$($)?JSON.stringify($):String($);var T=($,J,X)=>{if(Object.is($,J))return!0;if(typeof $!==typeof J)return!1;if(typeof $!=="object"||$===null||J===null)return!1;if(!X)X=new WeakSet;if(X.has($)||X.has(J))throw new N("isEqual");X.add($),X.add(J);try{if(Array.isArray($)&&Array.isArray(J)){if($.length!==J.length)return!1;for(let B=0;B<$.length;B++)if(!T($[B],J[B],X))return!1;return!0}if(Array.isArray($)!==Array.isArray(J))return!1;if(D($)&&D(J)){let B=Object.keys($),x=Object.keys(J);if(B.length!==x.length)return!1;for(let C of B){if(!(C in J))return!1;if(!T($[C],J[C],X))return!1}return!0}return!1}finally{X.delete($),X.delete(J)}},W$=($,J)=>{let X=r($),B=r(J);if(!X||!B){let F=!Object.is($,J);return{changed:F,add:F&&B?J:{},change:{},remove:F&&X?$:{}}}let x=new WeakSet,C={},K={},W={},H=Object.keys($),R=Object.keys(J),U=new Set([...H,...R]);for(let F of U){let I=F in $,j=F in J;if(!I&&j){C[F]=J[F];continue}else if(I&&!j){W[F]=A;continue}let Z=$[F],Q=J[F];if(!T(Z,Q,x))K[F]=Q}return{changed:Object.keys(C).length>0||Object.keys(K).length>0||Object.keys(W).length>0,add:C,change:K,remove:W}};var f,x$=new Set,U$=0,z$=new Map,K$,y$=()=>{K$=void 0;let $=Array.from(z$.values());z$.clear();for(let J of $)J()},v$=()=>{if(K$)cancelAnimationFrame(K$);K$=requestAnimationFrame(y$)};queueMicrotask(y$);var a=($)=>{let J=new Set,X=$;return X.off=(B)=>{J.add(B)},X.cleanup=()=>{for(let B of J)B();J.clear()},X},V=($)=>{if(f&&!$.has(f)){let J=f;$.add(J),f.off(()=>{$.delete(J)})}},P=($)=>{for(let J of $)if(U$)x$.add(J);else J()},Y$=()=>{while(x$.size){let $=Array.from(x$);x$.clear();for(let J of $)J()}},C$=($)=>{U$++;try{$()}finally{Y$(),U$--}},e=($,J)=>{let X=f;f=J;try{$()}finally{f=X}},V$=($,J)=>new Promise((X,B)=>{z$.set(J||Symbol(),()=>{try{X($())}catch(x){B(x)}}),v$()});var A$="Computed",v=($)=>{let J=new Set,X=A,B,x,C=!0,K=!1,W=!1,H=(Z)=>{if(!T(Z,X))X=Z,K=!0;B=void 0,C=!1},R=()=>{K=A!==X,X=A,B=void 0},U=(Z)=>{let Q=S(Z);K=!B||Q.name!==B.name||Q.message!==B.message,X=A,B=Q},L=(Z)=>(Q)=>{if(W=!1,x=void 0,Z(Q),K)P(J)},F=a(()=>{if(C=!0,x?.abort(),J.size)P(J);else F.cleanup()});F.off(()=>{x?.abort()});let I=()=>e(()=>{if(W)throw new N("computed");if(K=!1,p($)){if(x)return X;x=new AbortController,x.signal.addEventListener("abort",()=>{W=!1,x=void 0,I()},{once:!0})}let Z;W=!0;try{Z=x?$(x.signal):$()}catch(Q){if(E(Q))R();else U(Q);W=!1;return}if(Z instanceof Promise)Z.then(L(H),L(U));else if(Z==null||A===Z)R();else H(Z);W=!1},F);return{[Symbol.toStringTag]:A$,get:()=>{if(V(J),Y$(),C)I();if(B)throw B;return X}}},O=($)=>b($,A$),$$=($)=>M($)&&$.length<2;var H$=($)=>{let J=p($),X=!1,B,x=a(()=>e(()=>{if(X)throw new N("effect");X=!0,B?.abort(),B=void 0;let C;try{if(J){B=new AbortController;let K=B;$(B.signal).then((W)=>{if(M(W)&&B===K)x.off(W)}).catch((W)=>{if(!E(W))console.error("Async effect error:",W)})}else if(C=$(),M(C))x.off(C)}catch(K){if(!E(K))console.error("Effect callback error:",K)}X=!1},x));return x(),()=>{B?.abort(),x.cleanup()}};function O$($,J){try{if($.pending)J.nil?.();else if($.errors)J.err?.($.errors);else if($.ok)J.ok($.values)}catch(X){if(J.err&&(!$.errors||!$.errors.includes(S(X))))J.err($.errors?[...$.errors,S(X)]:[S(X)]);else throw X}}function w$($){let J=[],X=!1,B={};for(let[x,C]of Object.entries($))try{let K=C.get();if(K===A)X=!0;else B[x]=K}catch(K){J.push(S(K))}if(X)return{ok:!1,pending:!0};if(J.length>0)return{ok:!1,errors:J};return{ok:!0,values:B}}var I$="State",_=($)=>{let J=new Set,X=$,B={[Symbol.toStringTag]:I$,get:()=>{return V(J),X},set:(x)=>{if(x==null)throw new k("state");if(T(X,x))return;if(X=x,P(J),A===X)J.clear()},update:(x)=>{B.set(x(X))}};return B},y=($)=>b($,I$);var R$="Store",M$="store-add",k$="store-change",b$="store-remove",c$="store-sort",c=($)=>{let J=new Set,X=new EventTarget,B=new Map,x=new Map,C=Array.isArray($),K=_(0),W=()=>{let Z={};for(let[Q,Y]of B)Z[Q]=Y.get();return Z},H=(Z,Q)=>X.dispatchEvent(new CustomEvent(Z,{detail:Q})),R=()=>Array.from(B.keys()).map((Z)=>Number(Z)).filter((Z)=>Number.isInteger(Z)).sort((Z,Q)=>Z-Q),U=(Z,Q)=>{if(Q==null)throw new k(`store for key "${Z}"`);if(Q===A)return!0;if(d(Q)||M(Q)||O(Q))throw new i(`store for key "${Z}"`,Z$(Q));return!0},L=(Z,Q,Y=!1)=>{if(!U(Z,Q))return!1;let G=y(Q)||w(Q)?Q:D(Q)?c(Q):Array.isArray(Q)?c(Q):_(Q);B.set(Z,G);let z=H$(()=>{let q=G.get();if(q!=null)H(k$,{[Z]:q})});if(x.set(Z,z),Y)K.set(B.size),P(J),H(M$,{[Z]:Q});return!0},F=(Z,Q=!1)=>{let Y=B.delete(Z);if(Y){let G=x.get(Z);if(G)G();x.delete(Z)}if(Q)K.set(B.size),P(J),H(b$,{[Z]:A});return Y},I=(Z,Q,Y)=>{let G=W$(Z,Q);return C$(()=>{if(Object.keys(G.add).length){for(let z in G.add){let q=G.add[z]??A;L(z,q)}if(Y)setTimeout(()=>{H(M$,G.add)},0);else H(M$,G.add)}if(Object.keys(G.change).length){for(let z in G.change){let q=G.change[z];if(!U(z,q))continue;let Q$=B.get(z);if(o(Q$))Q$.set(q);else throw new l(z,Z$(q))}H(k$,G.change)}if(Object.keys(G.remove).length){for(let z in G.remove)F(z);H(b$,G.remove)}K.set(B.size)}),G.changed};I({},$,!0);let j={add:C?(Z)=>{let Q=B.size,Y=String(Q);L(Y,Z,!0)}:(Z,Q)=>{if(!B.has(Z))L(Z,Q,!0);else throw new s(Z,Z$(Q))},get:()=>{return V(J),X$(W())},remove:C?(Z)=>{let Q=X$(W()),Y=B.size;if(!Array.isArray(Q)||Z<=-Y||Z>=Y)throw new t(Z);let G=[...Q];if(G.splice(Z,1),I(Q,G))P(J)}:(Z)=>{if(B.has(Z))F(Z,!0)},set:(Z)=>{if(I(W(),Z)){if(P(J),A===Z)J.clear()}},update:(Z)=>{let Q=W(),Y=Z(X$(Q));if(I(Q,Y)){if(P(J),A===Y)J.clear()}},sort:(Z)=>{let Q=Array.from(B.entries()).map(([z,q])=>[z,q.get()]).sort(Z?(z,q)=>Z(z[1],q[1]):(z,q)=>String(z[1]).localeCompare(String(q[1]))),Y=Q.map(([z])=>String(z)),G=new Map;Q.forEach(([z],q)=>{let Q$=String(z),h$=C?String(q):String(z),_$=B.get(Q$);if(_$)G.set(h$,_$)}),B.clear(),G.forEach((z,q)=>B.set(q,z)),P(J),H(c$,Y)},addEventListener:X.addEventListener.bind(X),removeEventListener:X.removeEventListener.bind(X),dispatchEvent:X.dispatchEvent.bind(X),size:K};return new Proxy({},{get(Z,Q){if(Q===Symbol.toStringTag)return R$;if(Q===Symbol.isConcatSpreadable)return C;if(Q===Symbol.iterator)return C?function*(){let Y=R();for(let G of Y){let z=B.get(String(G));if(z)yield z}}:function*(){for(let[Y,G]of B)yield[Y,G]};if(d(Q))return;if(Q in j)return j[Q];if(Q==="length"&&C)return V(J),K.get();return B.get(Q)},has(Z,Q){let Y=String(Q);return Y&&B.has(Y)||Object.keys(j).includes(Y)||Q===Symbol.toStringTag||Q===Symbol.iterator||Q===Symbol.isConcatSpreadable||Q==="length"&&C},ownKeys(){return C?R().map((Z)=>String(Z)).concat(["length"]):Array.from(B.keys()).map((Z)=>String(Z))},getOwnPropertyDescriptor(Z,Q){let Y=(z)=>({enumerable:!1,configurable:!0,writable:!1,value:z});if(Q==="length"&&C)return{enumerable:!0,configurable:!0,writable:!1,value:K.get()};if(Q===Symbol.isConcatSpreadable)return Y(C);if(Q===Symbol.toStringTag)return Y(R$);if(d(Q))return;if(Object.keys(j).includes(Q))return Y(j[Q]);let G=B.get(Q);return G?{enumerable:!0,configurable:!0,writable:!0,value:G}:void 0}})},w=($)=>b($,R$);var J$=($)=>y($)||O($)||w($),o=($)=>y($)||w($);function E$($){if(J$($))return $;if($$($))return v($);if(Array.isArray($)||D($))return c($);return _($)}var m=!1,o$="debug";var L$="warn",u$="error",n$=new Set(["constructor","prototype"]),i$=new Set(["id","class","className","title","role","style","dataset","lang","dir","hidden","children","innerHTML","outerHTML","textContent","innerText"]),s$=($)=>$?`#${$}`:"",t$=($)=>$?.length?`.${Array.from($).join(".")}`:"";var f$=($)=>$.nodeType===Node.ELEMENT_NODE,q$=($)=>$.localName.includes("-"),g=($)=>$?`<${$.localName}${s$($.id)}${t$($.classList)}>`:"<unknown>",B$=($)=>h($)?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($),j$=($)=>{if($===null)return"null";if(typeof $!=="object")return typeof $;if(Array.isArray($))return"Array";if(Symbol.toStringTag in Object($))return $[Symbol.toStringTag];return $.constructor?.name||"Object"},u=($,J,X=o$)=>{if(m||[u$,L$].includes(X))console[X](J,$);return $},m$=($)=>{if(n$.has($))return`Property name "${$}" is a reserved word`;if(i$.has($))return`Property name "${$}" conflicts with inherited HTMLElement property`;return null};class P$ extends TypeError{constructor($){super(`Invalid component name "${$}". Custom element names must contain a hyphen, start with a lowercase letter, and contain only lowercase letters, numbers, and hyphens.`);this.name="InvalidComponentNameError"}}class D$ extends TypeError{constructor($,J,X){super(`Invalid property name "${J}" for component <${$}>. ${X}`);this.name="InvalidPropertyNameError"}}class S$ extends TypeError{constructor($,J){super(`Invalid effects in component ${g($)}. Effects must be an array of effects, a single effect function, or a Promise that resolves to effects.`);if(this.name="InvalidEffectsError",J)this.cause=J}}class F$ extends Error{constructor($,J,X){super(`Missing required element <${J}> in component ${g($)}. ${X}`);this.name="MissingElementError"}}class N$ extends Error{constructor($,J){super(`Timeout waiting for: [${J.join(", ")}] in component ${g($)}.`);this.name="DependencyTimeoutError"}}var n=($,J,X=J)=>{try{if($ instanceof Promise)throw $;if(!Array.isArray($))return $(J,X);let B=$.filter(M).map((x)=>x(J,X));return()=>{B.filter(M).forEach((x)=>x()),B.length=0}}catch(B){if(B instanceof Promise)B.then(()=>n($,J,X));else throw new S$(J,B instanceof Error?B:Error(String(B)))}};var T$=($)=>M($)&&$.length>=2;var l$=($)=>{let J=new Set;if($.includes("."))J.add("class");if($.includes("#"))J.add("id");if($.includes("[")){let X=$.split("[");for(let B=1;B<X.length;B++){let x=X[B];if(!x.includes("]"))continue;let C=x.split("=")[0].trim().replace(/[^a-zA-Z0-9_-]/g,"");if(C)J.add(C)}}return[...J]},r$=($,J,X)=>{let B=new MutationObserver(X),x={childList:!0,subtree:!0},C=l$(J);if(C.length)x.attributes=!0,x.attributeFilter=C;return B.observe($,x),B},g$=($)=>{let J=$.shadowRoot??$,X=new Set;function B(W,H){let R=J.querySelector(W);if(H!=null&&!R)throw new F$($,W,H);if(R&&q$(R)&&R.matches(":not(:defined)"))X.add(R.localName);return R}function x(W,H){let R=J.querySelectorAll(W);if(H!=null&&!R.length)throw new F$($,W,H);if(R.length)R.forEach((U)=>{if(q$(U)&&U.matches(":not(:defined)"))X.add(U.localName)});return Array.from(R)}return[{useElement:B,useElements:x,first:(W,H,R)=>{let U=R!=null?B(W,R):B(W);return()=>{if(U)return n(H,$,U)}},all:(W,H,R)=>{let U=R!=null?x(W,R):x(W);return()=>{let L=new Map,F=(Q)=>{let Y=n(H,$,Q);if(Y&&!L.has(Q))L.set(Q,Y)},I=(Q)=>{let Y=L.get(Q);if(Y)Y();L.delete(Q)},j=(Q)=>(Y)=>{if(f$(Y)){if(Y.matches(W))Q(Y);Y.querySelectorAll(W).forEach(Q)}},Z=r$(J,W,(Q)=>{for(let Y of Q)Y.addedNodes.forEach(j(F)),Y.removedNodes.forEach(j(I))});if(U.length)U.forEach(F);return()=>{Z.disconnect(),L.forEach((Q)=>Q()),L.clear()}}}},()=>Array.from(X)]};var a$=50;function e$($){let{name:J,select:X=()=>({}),props:B={},setup:x=()=>[]}=$;if(!J.includes("-")||!J.match(/^[a-z][a-z0-9-]*$/))throw new P$(J);for(let K of Object.keys(B)){let W=m$(K);if(W)throw new D$(J,K,W)}class C extends HTMLElement{debug;#$={};#J={};#B;static observedAttributes=Object.entries(B)?.filter(([,K])=>T$(K)).map(([K])=>K)??[];connectedCallback(){if(m){if(this.debug=this.hasAttribute("debug"),this.debug)u(this,"Connected")}let[K,W]=g$(this);this.#$={...X(K),component:this};let H=(F,I)=>{let j=M(I)?I(this):I;if(j!=null)this.#Q(F,j)};for(let[F,I]of Object.entries(B)){if(I==null||F in this)continue;H(F,I)}let R=x(this.#$,K),U=W(),L=()=>{let F=n(R,this);if(F)this.#B=F};if(U.length)Promise.race([Promise.all(U.map((F)=>customElements.whenDefined(F))),new Promise((F,I)=>{setTimeout(()=>{I(new N$(this,U.filter((j)=>!customElements.get(j))))},a$)})]).then(L).catch((F)=>{if(m)u(F,`Error during setup of <${J}>. Trying to run effects anyway.`,L$);L()});else L()}disconnectedCallback(){if(M(this.#B))this.#B();if(m&&this.debug)u(this,"Disconnected")}attributeChangedCallback(K,W,H){if(H===W||O(this.#J[K]))return;let R=B[K];if(!T$(R))return;let U=R(this.#$,H,W);if(m&&this.debug)u(H,`Attribute "${String(K)}" of ${g(this)} changed from ${B$(W)} to ${B$(H)}, parsed as <${j$(U)}> ${B$(U)}`);if(K in this)this[K]=U;else this.#Q(K,U)}#Q(K,W){let H=J$(W)?W:$$(W)?v(W):_(W),R=this.#J[K],U=o(H);if(this.#J[K]=H,Object.defineProperty(this,K,{get:H.get,set:U?H.set:void 0,enumerable:!0,configurable:U}),R&&y(R)||w(R))R.set(A);if(m&&this.debug)u(H,`Set ${j$(H)} "${String(K)}" in ${g(this)}`)}}return customElements.define(J,C),customElements.get(J)}export{E$ as toSignal,S as toError,c as store,_ as state,w$ as resolve,O$ as match,d as isSymbol,h as isString,w as isStore,y as isState,J$ as isSignal,r as isRecordOrArray,D as isRecord,G$ as isNumber,o as isMutableSignal,M as isFunction,T as isEqual,O as isComputed,p as isAsyncFunction,E as isAbortError,V$ as enqueue,H$ as effect,W$ as diff,v as computed,e$ as component,C$ as batch,A as UNSET,l as StoreKeyReadonlyError,t as StoreKeyRangeError,s as StoreKeyExistsError,k as NullishSignalValueError,i as InvalidSignalValueError,N as CircularDependencyError};

//# debugId=15C4A36DFC961AEA64756E2164756E21
