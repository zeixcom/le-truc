function O($){return typeof $==="function"}function X$($){return O($)&&$.constructor.name==="AsyncFunction"}function G$($){return O($)&&$.constructor.name!=="AsyncFunction"}function S($,Z){return Object.prototype.toString.call($)===`[object ${Z}]`}function _($){return S($,"Object")}function DZ($,Z=(J)=>J!=null){return Array.isArray($)&&$.every(Z)}function l($){return typeof $==="string"?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($)}class H$ extends Error{constructor($){super(`[${$}] Circular dependency detected`);this.name="CircularDependencyError"}}class E$ extends TypeError{constructor($){super(`[${$}] Signal value cannot be null or undefined`);this.name="NullishSignalValueError"}}class B$ extends Error{constructor($){super(`[${$}] Signal value is unset`);this.name="UnsetSignalValueError"}}class K$ extends TypeError{constructor($,Z){super(`[${$}] Signal value ${l(Z)} is invalid`);this.name="InvalidSignalValueError"}}class f$ extends TypeError{constructor($,Z){super(`[${$}] Callback ${l(Z)} is invalid`);this.name="InvalidCallbackError"}}class h$ extends Error{constructor($){super(`[${$}] Signal is read-only`);this.name="ReadonlySignalError"}}class k$ extends Error{constructor($){super(`[${$}] Active owner is required`);this.name="RequiredOwnerError"}}class z$ extends Error{constructor($,Z,J){super(`[${$}] Could not add key "${Z}"${J?` with value ${JSON.stringify(J)}`:""} because it already exists`);this.name="DuplicateKeyError"}}function F($,Z,J){if(Z==null)throw new E$($);if(J&&!J(Z))throw new K$($,Z)}function C$($,Z){if(Z==null)throw new B$($)}function k($,Z,J=O){if(!J(Z))throw new f$($,Z)}var r="State",n="Memo",t="Task",a="Sensor",g="List",e="Collection",$$="Store",Z$="Slot",p=0,q$=1,N=2,R$=4,y=8,D=null,c=null,g$=[],I=0,WZ=!1,u=($,Z)=>$===Z,QZ=($,Z)=>!1;function TZ($,Z){let J=Z.sourcesTail;if(J){let X=Z.sources;while(X){if(X===$)return!0;if(X===J)break;X=X.nextSource}}return!1}function A($,Z){let J=Z.sourcesTail;if(J?.source===$)return;let X=null,B=Z.flags&R$;if(B){if(X=J?J.nextSource:Z.sources,X?.source===$){Z.sourcesTail=X;return}}let W=$.sinksTail;if(W?.sink===Z&&(!B||TZ(W,Z)))return;let U={source:$,sink:Z,nextSource:X,prevSink:W,nextSink:null};if(Z.sourcesTail=$.sinksTail=U,J)J.nextSource=U;else Z.sources=U;if(W)W.nextSink=U;else $.sinks=U}function SZ($){let{source:Z,nextSource:J,nextSink:X,prevSink:B}=$;if(X)X.prevSink=B;else Z.sinksTail=B;if(B)B.nextSink=X;else Z.sinks=X;if(!Z.sinks){if(Z.stop)Z.stop(),Z.stop=void 0;if("sources"in Z&&Z.sources){let W=Z;W.sourcesTail=null,D$(W)}}return J}function D$($){let Z=$.sourcesTail,J=Z?Z.nextSource:$.sources;while(J)J=SZ(J);if(Z)Z.nextSource=null;else $.sources=null}function w($,Z=N){let J=$.flags;if("sinks"in $){if((J&(N|q$))>=Z)return;if($.flags=J|Z,"controller"in $&&$.controller)$.controller.abort(),$.controller=void 0;for(let X=$.sinks;X;X=X.nextSink)w(X.sink,q$)}else{if((J&(N|q$))>=Z)return;let X=J&(N|q$);if($.flags=Z,!X)g$.push($)}}function L$($,Z){if($.equals($.value,Z))return;$.value=Z;for(let J=$.sinks;J;J=J.nextSink)w(J.sink);if(I===0)L()}function U$($,Z){if(!$.cleanup)$.cleanup=Z;else if(Array.isArray($.cleanup))$.cleanup.push(Z);else $.cleanup=[$.cleanup,Z]}function p$($){if(!$.cleanup)return;if(Array.isArray($.cleanup))for(let Z=0;Z<$.cleanup.length;Z++)$.cleanup[Z]();else $.cleanup();$.cleanup=null}function bZ($){let Z=D;D=$,$.sourcesTail=null,$.flags=R$;let J=!1;try{let X=$.fn($.value);if($.error||!$.equals(X,$.value))$.value=X,$.error=void 0,J=!0}catch(X){J=!0,$.error=X instanceof Error?X:Error(String(X))}finally{D=Z,D$($)}if(J){for(let X=$.sinks;X;X=X.nextSink)if(X.sink.flags&q$)X.sink.flags|=N}$.flags=p}function yZ($){$.controller?.abort();let Z=new AbortController;$.controller=Z,$.error=void 0;let J=D;D=$,$.sourcesTail=null,$.flags=R$;let X;try{X=$.fn($.value,Z.signal)}catch(B){$.controller=void 0,$.error=B instanceof Error?B:Error(String(B));return}finally{D=J,D$($)}X.then((B)=>{if(Z.signal.aborted)return;if($.controller=void 0,$.error||!$.equals(B,$.value)){$.value=B,$.error=void 0;for(let W=$.sinks;W;W=W.nextSink)w(W.sink);if(I===0)L()}},(B)=>{if(Z.signal.aborted)return;$.controller=void 0;let W=B instanceof Error?B:Error(String(B));if(!$.error||W.name!==$.error.name||W.message!==$.error.message){$.error=W;for(let U=$.sinks;U;U=U.nextSink)w(U.sink);if(I===0)L()}}),$.flags=p}function jZ($){p$($);let Z=D,J=c;D=c=$,$.sourcesTail=null,$.flags=R$;try{let X=$.fn();if(typeof X==="function")U$($,X)}finally{D=Z,c=J,D$($)}$.flags=p}function T($){if($.flags&q$)for(let Z=$.sources;Z;Z=Z.nextSource){if("fn"in Z.source)T(Z.source);if($.flags&N)break}if($.flags&R$)throw new H$("controller"in $?t:("value"in $)?n:"Effect");if($.flags&N)if("controller"in $)yZ($);else if("value"in $)bZ($);else jZ($);else $.flags=p}function L(){if(WZ)return;WZ=!0;try{for(let $=0;$<g$.length;$++){let Z=g$[$];if(Z.flags&(N|q$))T(Z)}g$.length=0}finally{WZ=!1}}function o($){I++;try{$()}finally{if(I--,I===0)L()}}function s($){let Z=D;D=null;try{return $()}finally{D=Z}}function v$($){let Z=c,J={cleanup:null};c=J;try{let X=$();if(typeof X==="function")U$(J,X);let B=()=>p$(J);if(Z)U$(Z,B);return B}finally{c=Z}}function f($,Z){F(r,$,Z?.guard);let J={value:$,sinks:null,sinksTail:null,equals:Z?.equals??u,guard:Z?.guard};return{[Symbol.toStringTag]:r,get(){if(D)A(J,D);return J.value},set(X){F(r,X,J.guard),L$(J,X)},update(X){k(r,X);let B=X(J.value);F(r,B,J.guard),L$(J,B)}}}function Y$($){return S($,r)}function J$($,Z,J){if(Object.is($,Z))return!0;if(typeof $!==typeof Z)return!1;if($==null||typeof $!=="object"||Z==null||typeof Z!=="object")return!1;if(!J)J=new WeakSet;if(J.has($)||J.has(Z))throw new H$("isEqual");J.add($),J.add(Z);try{let X=Array.isArray($);if(X!==Array.isArray(Z))return!1;if(X){let B=$,W=Z;if(B.length!==W.length)return!1;for(let U=0;U<B.length;U++)if(!J$(B[U],W[U],J))return!1;return!0}if(_($)&&_(Z)){let B=Object.keys($),W=Object.keys(Z);if(B.length!==W.length)return!1;for(let U of B){if(!(U in Z))return!1;if(!J$($[U],Z[U],J))return!1}return!0}return!1}finally{J.delete($),J.delete(Z)}}function d$($,Z){if($.length!==Z.length)return!1;for(let J=0;J<$.length;J++)if($[J]!==Z[J])return!1;return!0}function HZ($){let Z=0,J=typeof $==="function";return[typeof $==="string"?()=>`${$}${Z++}`:J?(X)=>$(X)||String(Z++):()=>String(Z++),J]}function mZ($,Z,J,X,B){let W=new WeakSet,U={},z={},q={},M=[],H=!1,Q=new Map;for(let G=0;G<$.length;G++){let j=J[G];if(j&&$[G])Q.set(j,$[G])}let K=new Set;for(let G=0;G<Z.length;G++){let j=Z[G];if(j===void 0)continue;let V=B?X(j):J[G]??X(j);if(K.has(V))throw new z$(g,V,j);if(M.push(V),K.add(V),!Q.has(V))U[V]=j,H=!0;else if(!J$(Q.get(V),j,W))z[V]=j,H=!0}for(let[G]of Q)if(!K.has(G))q[G]=null,H=!0;if(!H&&!d$(J,M))H=!0;return{add:U,change:z,remove:q,newKeys:M,changed:H}}function N$($,Z){F(g,$,Array.isArray);let J=new Map,X=[],[B,W]=HZ(Z?.keyConfig),U=()=>X.map((j)=>J.get(j)?.get()).filter((j)=>j!==void 0),z={fn:U,value:$,flags:N,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:J$,error:void 0},q=(j)=>{let V={};for(let C=0;C<j.length;C++){let Y=j[C];if(Y===void 0)continue;let P=X[C];if(!P)P=B(Y),X[C]=P;V[P]=Y}return V},M=(j)=>{let V=!1;for(let C in j.add){let Y=j.add[C];F(`${g} item for key "${C}"`,Y),J.set(C,f(Y)),V=!0}if(Object.keys(j.change).length)o(()=>{for(let C in j.change){let Y=j.change[C];F(`${g} item for key "${C}"`,Y);let P=J.get(C);if(P)P.set(Y)}});for(let C in j.remove){J.delete(C);let Y=X.indexOf(C);if(Y!==-1)X.splice(Y,1);V=!0}if(V)z.flags|=y;return j.changed},H=Z?.watched,Q=H?()=>{if(D){if(!z.sinks)z.stop=H();A(z,D)}}:()=>{if(D)A(z,D)},K=q($);for(let j in K){let V=K[j];F(`${g} item for key "${j}"`,V),J.set(j,f(V))}z.value=$,z.flags=0;let G={[Symbol.toStringTag]:g,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let j of X){let V=J.get(j);if(V)yield V}},get length(){return Q(),X.length},get(){if(Q(),z.sources){if(z.flags){let j=z.flags&y;if(z.value=s(U),j){if(z.flags=N,T(z),z.error)throw z.error}else z.flags=p}}else if(T(z),z.error)throw z.error;return z.value},set(j){let V=z.flags&N?U():z.value,C=mZ(V,j,X,B,W);if(C.changed){X=C.newKeys,M(C),z.flags|=N;for(let Y=z.sinks;Y;Y=Y.nextSink)w(Y.sink);if(I===0)L()}},update(j){G.set(j(G.get()))},at(j){return J.get(X[j])},keys(){return Q(),X.values()},byKey(j){return J.get(j)},keyAt(j){return X[j]},indexOfKey(j){return X.indexOf(j)},add(j){let V=B(j);if(J.has(V))throw new z$(g,V,j);if(!X.includes(V))X.push(V);F(`${g} item for key "${V}"`,j),J.set(V,f(j)),z.flags|=N|y;for(let C=z.sinks;C;C=C.nextSink)w(C.sink);if(I===0)L();return V},remove(j){let V=typeof j==="number"?X[j]:j;if(J.delete(V)){let Y=typeof j==="number"?j:X.indexOf(V);if(Y>=0)X.splice(Y,1);z.flags|=N|y;for(let P=z.sinks;P;P=P.nextSink)w(P.sink);if(I===0)L()}},sort(j){let C=X.map((Y)=>[Y,J.get(Y)?.get()]).sort(O(j)?(Y,P)=>j(Y[1],P[1]):(Y,P)=>String(Y[1]).localeCompare(String(P[1]))).map(([Y])=>Y);if(!d$(X,C)){X=C,z.flags|=N;for(let Y=z.sinks;Y;Y=Y.nextSink)w(Y.sink);if(I===0)L()}},splice(j,V,...C){let Y=X.length,P=j<0?Math.max(0,Y+j):Math.min(j,Y),x=Math.max(0,Math.min(V??Math.max(0,Y-Math.max(0,P)),Y-P)),b={},h={};for(let v=0;v<x;v++){let j$=P+v,BZ=X[j$];if(BZ){let CZ=J.get(BZ);if(CZ)h[BZ]=CZ.get()}}let XZ=X.slice(0,P);for(let v of C){let j$=B(v);if(J.has(j$)&&!(j$ in h))throw new z$(g,j$,v);XZ.push(j$),b[j$]=v}XZ.push(...X.slice(P+x));let KZ=!!(Object.keys(b).length||Object.keys(h).length);if(KZ){M({add:b,change:{},remove:h,changed:KZ}),X=XZ,z.flags|=N;for(let v=z.sinks;v;v=v.nextSink)w(v.sink);if(I===0)L()}return Object.values(h)},deriveCollection(j){return c$(G,j)}};return G}function _$($){return S($,g)}function i($,Z){if(k(n,$,G$),Z?.value!==void 0)F(n,Z.value,Z?.guard);let J={fn:$,value:Z?.value,flags:N,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:Z?.equals??u,error:void 0,stop:void 0},X=Z?.watched,B=X?()=>{if(D){if(!J.sinks)J.stop=X(()=>{if(w(J),I===0)L()});A(J,D)}}:()=>{if(D)A(J,D)};return{[Symbol.toStringTag]:n,get(){if(B(),T(J),J.error)throw J.error;return C$(n,J.value),J.value}}}function W$($){return S($,n)}function P$($,Z){if(k(t,$,X$),Z?.value!==void 0)F(t,Z.value,Z?.guard);let J={fn:$,value:Z?.value,sources:null,sourcesTail:null,sinks:null,sinksTail:null,flags:N,equals:Z?.equals??u,controller:void 0,error:void 0,stop:void 0},X=Z?.watched,B=X?()=>{if(D){if(!J.sinks)J.stop=X(()=>{if(w(J),I===0)L()});A(J,D)}}:()=>{if(D)A(J,D)};return{[Symbol.toStringTag]:t,get(){if(B(),T(J),J.error)throw J.error;return C$(t,J.value),J.value},isPending(){return!!J.controller},abort(){J.controller?.abort(),J.controller=void 0}}}function u$($){return S($,t)}function c$($,Z){k(e,Z);let J=X$(Z),X=new Map,B=[],W=(G)=>{let j=J?P$(async(V,C)=>{let Y=$.byKey(G)?.get();if(Y==null)return V;return Z(Y,C)}):i(()=>{let V=$.byKey(G)?.get();if(V==null)return;return Z(V)});X.set(G,j)};function U(G){if(!d$(B,G)){let j=new Set(B),V=new Set(G);for(let C of B)if(!V.has(C))X.delete(C);for(let C of G)if(!j.has(C))W(C);B=G,M.flags|=y}}function z(){U(Array.from($.keys()));let G=[];for(let j of B)try{let V=X.get(j)?.get();if(V!=null)G.push(V)}catch(V){if(!(V instanceof B$))throw V}return G}let M={fn:z,value:[],flags:N,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:(G,j)=>{if(G.length!==j.length)return!1;for(let V=0;V<G.length;V++)if(G[V]!==j[V])return!1;return!0},error:void 0};function H(){if(M.sources){if(M.flags)if(M.value=s(z),M.flags&y){if(M.flags=N,T(M),M.error)throw M.error}else M.flags=p}else if(M.sinks){if(T(M),M.error)throw M.error}else M.value=s(z)}let Q=Array.from(s(()=>$.keys()));for(let G of Q)W(G);B=Q;let K={[Symbol.toStringTag]:e,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let G of B){let j=X.get(G);if(j)yield j}},get length(){if(D)A(M,D);return H(),B.length},keys(){if(D)A(M,D);return H(),B.values()},get(){if(D)A(M,D);return H(),M.value},at(G){return X.get(B[G])},byKey(G){return X.get(G)},keyAt(G){return B[G]},indexOfKey(G){return B.indexOf(G)},deriveCollection(G){return c$(K,G)}};return K}function YZ($,Z){let J=Z?.value??[];if(J.length)F(e,J,Array.isArray);k(e,$,G$);let X=new Map,B=[],W=new Map,[U,z]=HZ(Z?.keyConfig),q=(j)=>W.get(j)??(z?U(j):void 0),M=Z?.createItem??f;function H(){let j=[];for(let V of B)try{let C=X.get(V)?.get();if(C!=null)j.push(C)}catch(C){if(!(C instanceof B$))throw C}return j}let Q={fn:H,value:J,flags:N,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:QZ,error:void 0};for(let j of J){let V=U(j);X.set(V,M(j)),W.set(j,V),B.push(V)}Q.value=J,Q.flags=N;function K(){if(D){if(!Q.sinks)Q.stop=$((j)=>{let{add:V,change:C,remove:Y}=j;if(!V?.length&&!C?.length&&!Y?.length)return;let P=!1;o(()=>{if(V)for(let x of V){let b=U(x);if(X.set(b,M(x)),W.set(x,b),!B.includes(b))B.push(b);P=!0}if(C)for(let x of C){let b=q(x);if(!b)continue;let h=X.get(b);if(h&&Y$(h))W.delete(h.get()),h.set(x),W.set(x,b)}if(Y)for(let x of Y){let b=q(x);if(!b)continue;W.delete(x),X.delete(b);let h=B.indexOf(b);if(h!==-1)B.splice(h,1);P=!0}Q.flags=N|(P?y:0);for(let x=Q.sinks;x;x=x.nextSink)w(x.sink)})});A(Q,D)}}let G={[Symbol.toStringTag]:e,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let j of B){let V=X.get(j);if(V)yield V}},get length(){return K(),B.length},keys(){return K(),B.values()},get(){if(K(),Q.sources){if(Q.flags){let j=Q.flags&y;if(Q.value=s(H),j){if(Q.flags=N,T(Q),Q.error)throw Q.error}else Q.flags=p}}else if(T(Q),Q.error)throw Q.error;return Q.value},at(j){return X.get(B[j])},byKey(j){return X.get(j)},keyAt(j){return B[j]},indexOfKey(j){return B.indexOf(j)},deriveCollection(j){return c$(G,j)}};return G}function NZ($){return S($,e)}function T$($){k("Effect",$);let Z={fn:$,flags:N,sources:null,sourcesTail:null,cleanup:null},J=()=>{p$(Z),Z.fn=void 0,Z.flags=p,Z.sourcesTail=null,D$(Z)};if(c)U$(c,J);return jZ(Z),J}function PZ($,Z){if(!c)throw new k$("match");let{ok:J,err:X=console.error,nil:B}=Z,W,U=!1,z=Array($.length);for(let M=0;M<$.length;M++)try{z[M]=$[M].get()}catch(H){if(H instanceof B$){U=!0;continue}if(!W)W=[];W.push(H instanceof Error?H:Error(String(H)))}let q;try{if(U)q=B?.();else if(W)q=X(W);else q=J(z)}catch(M){X([M instanceof Error?M:Error(String(M))])}if(typeof q==="function")return q;if(q instanceof Promise){let M=c,H=new AbortController;U$(M,()=>H.abort()),q.then((Q)=>{if(!H.signal.aborted&&typeof Q==="function")U$(M,Q)}).catch((Q)=>{X([Q instanceof Error?Q:Error(String(Q))])})}}function o$($,Z){if(k(a,$,G$),Z?.value!==void 0)F(a,Z.value,Z?.guard);let J={value:Z?.value,sinks:null,sinksTail:null,equals:Z?.equals??u,guard:Z?.guard,stop:void 0};return{[Symbol.toStringTag]:a,get(){if(D){if(!J.sinks)J.stop=$((X)=>{F(a,X,J.guard),L$(J,X)});A(J,D)}return C$(a,J.value),J.value}}}function FZ($){return S($,a)}function EZ($,Z){let J=_($)||Array.isArray($),X=_(Z)||Array.isArray(Z);if(!J||!X){let Q=!Object.is($,Z);return{changed:Q,add:Q&&X?Z:{},change:{},remove:Q&&J?$:{}}}let B=new WeakSet,W={},U={},z={},q=!1,M=Object.keys($),H=Object.keys(Z);for(let Q of H)if(Q in $){if(!J$($[Q],Z[Q],B))U[Q]=Z[Q],q=!0}else W[Q]=Z[Q],q=!0;for(let Q of M)if(!(Q in Z))z[Q]=void 0,q=!0;return{add:W,change:U,remove:z,changed:q}}function S$($,Z){F($$,$,_);let J=new Map,X=(H,Q)=>{if(F(`${$$} for key "${H}"`,Q),Array.isArray(Q))J.set(H,N$(Q));else if(_(Q))J.set(H,S$(Q));else J.set(H,f(Q))},B=()=>{let H={};return J.forEach((Q,K)=>{H[K]=Q.get()}),H},W={fn:B,value:$,flags:N,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:J$,error:void 0},U=(H)=>{let Q=!1;for(let K in H.add)X(K,H.add[K]),Q=!0;if(Object.keys(H.change).length)o(()=>{for(let K in H.change){let G=H.change[K];F(`${$$} for key "${K}"`,G);let j=J.get(K);if(j)if(_(G)!==b$(j))X(K,G),Q=!0;else j.set(G)}});for(let K in H.remove)J.delete(K),Q=!0;if(Q)W.flags|=y;return H.changed},z=Z?.watched,q=z?()=>{if(D){if(!W.sinks)W.stop=z();A(W,D)}}:()=>{if(D)A(W,D)};for(let H of Object.keys($))X(H,$[H]);let M={[Symbol.toStringTag]:$$,[Symbol.isConcatSpreadable]:!1,*[Symbol.iterator](){for(let H of Array.from(J.keys())){let Q=J.get(H);if(Q)yield[H,Q]}},keys(){return q(),J.keys()},byKey(H){return J.get(H)},get(){if(q(),W.sources){if(W.flags){let H=W.flags&y;if(W.value=s(B),H){if(W.flags=N,T(W),W.error)throw W.error}else W.flags=p}}else if(T(W),W.error)throw W.error;return W.value},set(H){let Q=W.flags&N?B():W.value,K=EZ(Q,H);if(U(K)){W.flags|=N;for(let G=W.sinks;G;G=G.nextSink)w(G.sink);if(I===0)L()}},update(H){M.set(H(M.get()))},add(H,Q){if(J.has(H))throw new z$($$,H,Q);X(H,Q),W.flags|=N|y;for(let K=W.sinks;K;K=K.nextSink)w(K.sink);if(I===0)L();return H},remove(H){if(J.delete(H)){W.flags|=N|y;for(let K=W.sinks;K;K=K.nextSink)w(K.sink);if(I===0)L()}}};return new Proxy(M,{get(H,Q){if(Q in H)return Reflect.get(H,Q);if(typeof Q!=="symbol")return H.byKey(Q)},has(H,Q){if(Q in H)return!0;return H.byKey(String(Q))!==void 0},ownKeys(H){return Array.from(H.keys())},getOwnPropertyDescriptor(H,Q){if(Q in H)return Reflect.getOwnPropertyDescriptor(H,Q);if(typeof Q==="symbol")return;let K=H.byKey(String(Q));return K?{enumerable:!0,configurable:!0,writable:!0,value:K}:void 0}})}function b$($){return S($,$$)}function F$($,Z){return X$($)?P$($,Z):i($,Z)}function xZ($){if(M$($))return $;if($==null||O($)||d($))throw new K$("createMutableSignal",$);if(DZ($))return N$($);if(_($))return S$($);return f($)}function s$($){return W$($)||u$($)}function d($){let Z=[r,n,t,a,Z$,g,e,$$],J=Object.prototype.toString.call($).slice(8,-1);return Z.includes(J)}function M$($){return Y$($)||b$($)||_$($)}function i$($,Z){F(Z$,$,d);let J=$,X=Z?.guard,B={fn:()=>J.get(),value:void 0,flags:N,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:Z?.equals??u,error:void 0},W=()=>{if(D)A(B,D);if(T(B),B.error)throw B.error;return B.value},U=(q)=>{if(!M$(J))throw new h$(Z$);F(Z$,q,X),J.set(q)},z=(q)=>{F(Z$,q,d),J=q,B.flags|=N;for(let M=B.sinks;M;M=M.nextSink)w(M.sink);if(I===0)L()};return{[Symbol.toStringTag]:Z$,configurable:!0,enumerable:!0,get:W,set:U,replace:z,current:()=>J}}function x$($){return S($,Z$)}var Q$=!1,fZ="debug";var O$="warn",A$="error",hZ=new Set(["constructor","prototype"]),kZ=new Set(["id","class","className","title","role","style","dataset","lang","dir","hidden","children","innerHTML","outerHTML","textContent","innerText"]),gZ=($)=>$?`#${$}`:"",pZ=($)=>$?.length?`.${Array.from($).join(".")}`:"";var zZ=($)=>$.localName.includes("-"),qZ=($)=>zZ($)&&$.matches(":not(:defined)"),R=($)=>$?`<${$.localName}${gZ($.id)}${pZ($.classList)}>`:"<unknown>";var I$=($,Z,J=fZ)=>{if(Q$||[A$,O$].includes(J))console[J](Z,$);return $},OZ=($)=>{if(hZ.has($))return`Property name "${$}" is a reserved word`;if(kZ.has($))return`Property name "${$}" conflicts with inherited HTMLElement property`;return null};class l$ extends TypeError{constructor($){super(`Invalid component name "${$}". Custom element names must contain a hyphen, start with a lowercase letter, and contain only lowercase letters, numbers, and hyphens.`);this.name="InvalidComponentNameError"}}class r$ extends TypeError{constructor($,Z,J){super(`Invalid property name "${Z}" for component <${$}>. ${J}`);this.name="InvalidPropertyNameError"}}class n$ extends TypeError{constructor($,Z){super(`Invalid effects in component ${R($)}. Effects must be a record of effects for UI elements or the component, or a Promise that resolves to effects.`);if(this.name="InvalidEffectsError",Z)this.cause=Z}}class AZ extends TypeError{constructor($,Z,J){super(`Invalid UI key "${Z}" in ${J} of component ${R($)}`);this.name="InvalidUIKeyError"}}class y$ extends Error{constructor($,Z,J){super(`Missing required element <${Z}> in component ${R($)}. ${J}`);this.name="MissingElementError"}}class t$ extends Error{constructor($,Z){super(`Timeout waiting for: [${Z.join(", ")}] in component ${R($)}.`);this.name="DependencyTimeoutError"}}class a$ extends TypeError{constructor($,Z,J){super(`Expected reactives passed from ${R($)} to ${R(Z)} to be a record of signals, reactive property names or functions. Got ${l(J)}.`);this.name="InvalidReactivesError"}}class e$ extends TypeError{constructor($,Z){super(`Target ${R($)} is not a custom element in ${Z}.`);this.name="InvalidCustomElementError"}}var UZ=Symbol("RESET"),vZ=($,Z="")=>{return{a:"attribute ",c:"class ",d:"dataset ",h:"inner HTML",m:"method call ",p:"property ",s:"style property ",t:"text content"}[$]+Z},IZ=($,Z)=>{if(!_(Z))throw new n$($.host);return v$(()=>{for(let J of Object.keys(Z)){let X=J;if(!Z[X])continue;let B=Array.isArray(Z[X])?Z[X]:[Z[X]];if(W$($[X]))T$(()=>{for(let W of $[X].get())for(let U of B)U($.host,W)});else if($[X])for(let W of B)W($.host,$[X])}})},dZ=($,Z,J,X)=>{try{return typeof $==="string"?Z[$]:d($)?$.get():O($)?$(J):UZ}catch(B){if(X)I$(B,`Failed to resolve value of ${l($)}${X?` for ${X}`:""} in ${R(J)}${Z!==J?` in ${R(Z)}`:""}`,A$);return UZ}},m=($,Z)=>(J,X)=>{let{op:B,name:W="",read:U,update:z}=Z,q=vZ(B,W),M=(K)=>()=>{if(Q$&&J.debug)I$(X,`${K} ${q} of ${R(X)} in ${R(J)}`);Z.resolve?.(X)},H=(K)=>(G)=>{I$(G,`Failed to ${K} ${q} of ${R(X)} in ${R(J)}`,A$),Z.reject?.(G)},Q=U(X);return T$(()=>{let K=dZ($,J,X,q),G=K===UZ?Q:K===null?Z.delete?null:Q:K;if(Z.delete&&G===null)try{Z.delete(X),M("delete")()}catch(j){H("delete")(j)}else if(G!=null){let j=U(X);if(Object.is(G,j))return;try{z(X,G),M("update")()}catch(V){H("update")(V)}}})};var wZ=new WeakMap,m$=($)=>{let Z=wZ.get($);if(!Z)Z={},wZ.set($,Z);return Z};var w$=($)=>O($)&&$.length>=2,cZ=($)=>O($),E=($,Z)=>cZ(Z)?Z($):Z,uZ=($,Z)=>(J)=>{let X=$(J);return typeof X==="string"&&w$(Z)?Z(J,X):X??E(J,Z)};var oZ=200,sZ=($)=>{let Z=new Set;if($.includes("."))Z.add("class");if($.includes("#"))Z.add("id");if($.includes("[")){let J=$.split("[");for(let X=1;X<J.length;X++){let B=J[X];if(!B.includes("]"))continue;let W=B.split("=")[0].trim().replace(/[^a-zA-Z0-9_-]/g,"");if(W)Z.add(W)}}return[...Z]};function RZ($,Z){return i(()=>Array.from($.querySelectorAll(Z)),{value:[],equals:(J,X)=>J.length===X.length&&J.every((B,W)=>B===X[W]),watched:(J)=>{let X={childList:!0,subtree:!0},B=sZ(Z);if(B.length)X.attributes=!0,X.attributeFilter=B;let W=(q)=>q instanceof Element&&(q.matches(Z)||q.querySelector(Z)),U=(q)=>{if(q.type==="attributes")return!0;if(q.type==="childList")return Array.from(q.addedNodes).some(W)||Array.from(q.removedNodes).some(W);return!1},z=new MutationObserver((q)=>{for(let M of q)if(U(M)){J();return}});return z.observe($,X),()=>z.disconnect()}})}var LZ=($)=>{let Z=$.shadowRoot??$,J=new Set;function X(U,z){let q=Z.querySelector(U);if(z!=null&&!q)throw new y$($,U,z);if(q&&qZ(q))J.add(q.localName);return q??void 0}function B(U,z){let q=RZ(Z,U),M=q.get();if(z!=null&&!M.length)throw new y$($,U,z);if(M.length){for(let H of M)if(qZ(H))J.add(H.localName)}return q}return[{first:X,all:B},(U)=>{if(J.size)queueMicrotask(()=>{let z=Array.from(J).filter((q)=>!customElements.get(q));if(!z.length){U();return}Promise.race([Promise.all(z.map((q)=>customElements.whenDefined(q))),new Promise((q,M)=>{setTimeout(()=>{M(new t$($,z.filter((H)=>!customElements.get(H))))},oZ)})]).then(U).catch((q)=>{if(Q$)console[O$](q);U()})});else U()}]};function iZ($,Z={},J=()=>({}),X=()=>({})){if(!$.includes("-")||!$.match(/^[a-z][a-z0-9-]*$/))throw new l$($);for(let W of Object.keys(Z)){let U=OZ(W);if(U)throw new r$($,W,U)}class B extends HTMLElement{debug;#$;#Z;static observedAttributes=Object.entries(Z)?.filter(([,W])=>w$(W)).map(([W])=>W)??[];connectedCallback(){let[W,U]=LZ(this),z={...J(W),host:this};this.#$=z,Object.freeze(this.#$);let q=(H)=>{return O(H)},M=(H,Q)=>{let K=w$(Q)?Q(z,this.getAttribute(H)):q(Q)?Q(z):Q;if(K!=null)this.#J(H,K)};for(let[H,Q]of Object.entries(Z)){if(Q==null||H in this)continue;M(H,Q)}U(()=>{this.#Z=IZ(z,X(z))})}disconnectedCallback(){if(O(this.#Z))this.#Z()}attributeChangedCallback(W,U,z){if(!this.#$||z===U||s$(m$(this)[W]))return;let q=Z[W];if(!w$(q))return;let M=q(this.#$,z,U);if(W in this)this[W]=M;else this.#J(W,M)}#J(W,U){let z=d(U)?U:O(U)?F$(U):f(U),q=m$(this),M=W,H=q[M];if(x$(H))H.replace(z);else if(M$(z)){let Q=i$(z);q[M]=Q,Object.defineProperty(this,W,Q)}else q[M]=z,Object.defineProperty(this,W,{get:z.get,enumerable:!0})}}return customElements.define($,B),customElements.get($)}var $Z="context-request";class MZ extends Event{context;callback;subscribe;constructor($,Z,J=!1){super($Z,{bubbles:!0,composed:!0});this.context=$,this.callback=Z,this.subscribe=J}}var lZ=($)=>(Z)=>{let J=(X)=>{let{context:B,callback:W}=X;if(typeof B==="string"&&$.includes(B)&&O(W))X.stopImmediatePropagation(),W(()=>Z[B])};return Z.addEventListener($Z,J),()=>Z.removeEventListener($Z,J)},rZ=($,Z)=>(J)=>{let X=()=>E(J,Z);return J.host.dispatchEvent(new MZ($,(B)=>{X=B})),i(X)};var nZ=($)=>{if(/^(mailto|tel):/i.test($))return!0;if($.includes("://"))try{let Z=new URL($,window.location.origin);return["http:","https:","ftp:"].includes(Z.protocol)}catch{return!1}return!0},tZ=($,Z,J)=>{if(/^on/i.test(Z))throw Error(`Unsafe attribute: ${Z}`);if(J=String(J).trim(),!nZ(J))throw Error(`Unsafe URL for ${Z}: ${J}`);$.setAttribute(Z,J)},aZ=($,Z=$)=>m(Z,{op:"a",name:$,read:(J)=>J.getAttribute($),update:(J,X)=>{tZ(J,$,X)},delete:(J)=>{J.removeAttribute($)}}),eZ=($,Z=$)=>m(Z,{op:"a",name:$,read:(J)=>J.hasAttribute($),update:(J,X)=>{J.toggleAttribute($,X)}});var $4=($,Z=$)=>m(Z,{op:"c",name:$,read:(J)=>J.classList.contains($),update:(J,X)=>{J.classList.toggle($,X)}});var JZ=new Set(["scroll","resize","mousewheel","touchstart","touchmove","wheel"]),VZ=new Set,_Z=new WeakMap,ZZ,Z4=()=>{ZZ=void 0;let $=Array.from(VZ);VZ.clear();for(let Z of $)_Z.get(Z)?.()},J4=()=>{if(ZZ)cancelAnimationFrame(ZZ);ZZ=requestAnimationFrame(Z4)},V$=($,Z)=>{_Z.set($,Z),VZ.add($),J4()};var X4=($,Z,J={})=>(X,B)=>{if(!("passive"in J))J={...J,passive:JZ.has($)};let W=(U)=>{let z=()=>{let q=Z(U);if(!_(q))return;o(()=>{for(let[M,H]of Object.entries(q))try{X[M]=H}catch(Q){I$(Q,`Reactive property "${M}" on ${R(X)} from event ${$} on ${R(B)} could not be set, because it is read-only.`,A$)}})};if(J.passive)V$(B,z);else z()};return B.addEventListener($,W,J),()=>B.removeEventListener($,W)};var B4=($,Z={})=>m($,{op:"h",read:(J)=>(J.shadowRoot||!Z.shadowRootMode?J:null)?.innerHTML??"",update:(J,X)=>{let{shadowRootMode:B,allowScripts:W}=Z;if(!X){if(J.shadowRoot)J.shadowRoot.innerHTML="<slot></slot>";return""}if(B&&!J.shadowRoot)J.attachShadow({mode:B});let U=J.shadowRoot||J;return V$(J,()=>{if(U.innerHTML=X,W){let z=["type","src","async","defer","nomodule","crossorigin","integrity","referrerpolicy","fetchpriority"];U.querySelectorAll("script").forEach((q)=>{let M=document.createElement("script");for(let H of z)if(q.hasAttribute(H))M.setAttribute(H,q.getAttribute(H));if(!q.hasAttribute("src"))M.appendChild(document.createTextNode(q.textContent??""));U.appendChild(M),q.remove()})}}),W?" with scripts":""}});var W4=($)=>(Z,J)=>{if(!zZ(J))throw new e$(J,`pass from ${R(Z)}`);let X=O($)?$(J):$;if(!_(X))throw new a$(Z,J,X);let B=(z)=>{if(d(z))return z;let q=typeof z==="string"&&z in Z?()=>Z[z]:O(z)?z:void 0;return q?F$(q):void 0},W=m$(J),U=R(J);for(let[z,q]of Object.entries(X)){if(q==null)continue;if(!(z in J)){if(Q$)console[O$](`pass(): property '${z}' does not exist on ${U}`);continue}let M=O(q)&&q.length===1?q(J):q,H=Array.isArray(M)&&M.length===2,Q=B(H?M[0]:M);if(!Q)continue;let K=W[z];if(x$(K))K.replace(Q);else if(Q$)console[O$](`pass(): property '${z}' on ${U} has no Slot â€” binding skipped`)}};var Q4=($,Z=$)=>m(Z,{op:"p",name:$,read:(J)=>($ in J)?J[$]??null:null,update:(J,X)=>{J[$]=X}}),j4=($)=>m($,{op:"p",name:"hidden",read:(Z)=>!Z.hidden,update:(Z,J)=>{Z.hidden=!J}});var H4=($,Z=$)=>m(Z,{op:"s",name:$,read:(J)=>J.style.getPropertyValue($),update:(J,X)=>{J.style.setProperty($,X)},delete:(J)=>{J.style.removeProperty($)}});var z4=($)=>m($,{op:"t",read:(Z)=>Z.textContent,update:(Z,J)=>{Array.from(Z.childNodes).filter((X)=>X.nodeType!==Node.COMMENT_NODE).forEach((X)=>X.remove()),Z.append(document.createTextNode(J))}});var q4=($,Z,J)=>(X)=>{let{host:B}=X,W=E(X,$),U=W$(X[Z])?X[Z]:null,z=U?null:X[Z],q=new Map,M=(H)=>{if(z)return z.contains(H)?z:void 0;for(let Q of U.get())if(Q.contains(H))return Q};return o$((H)=>{for(let[Q,K]of Object.entries(J)){let G={passive:JZ.has(Q)},j=(V)=>{let C=V.target;if(!C)return;let Y=M(C);if(!Y)return;V.stopPropagation();let P=()=>{try{let x=K({event:V,ui:X,target:Y,prev:W});if(x==null||x instanceof Promise)return;if(!Object.is(x,W))W=x,H(x)}catch(x){throw V.stopImmediatePropagation(),x}};if(G.passive)V$(B,P);else P()};q.set(Q,j),B.addEventListener(Q,j,G)}return()=>{if(q.size){for(let[Q,K]of q)B.removeEventListener(Q,K);q.clear()}}},{value:W})};var U4=()=>($,Z)=>Z!=null&&Z!=="false";var M4=($)=>(Z,J)=>{if((J??$)==null)throw TypeError("asJSON: Value and fallback are both null or undefined");if(J==null)return E(Z,$);if(J==="")throw TypeError("Empty string is not valid JSON");let X;try{X=JSON.parse(J)}catch(B){throw SyntaxError(`Failed to parse JSON: ${String(B)}`,{cause:B})}return X??E(Z,$)};var GZ=($,Z)=>{if(Z==null)return;let J=$(Z);return Number.isFinite(J)?J:void 0},V4=($=0)=>(Z,J)=>{if(J==null)return E(Z,$);let X=J.trim();if(X.toLowerCase().startsWith("0x"))return GZ((W)=>parseInt(W,16),X)??E(Z,$);let B=GZ(parseFloat,J);return B!=null?Math.trunc(B):E(Z,$)},G4=($=0)=>(Z,J)=>GZ(parseFloat,J)??E(Z,$);var K4=($="")=>(Z,J)=>J??E(Z,$),C4=($)=>(Z,J)=>{if(J==null)return $[0];let X=J.toLowerCase();return $.find((W)=>W.toLowerCase()===X)?J:$[0]};export{l as valueString,m as updateElement,$4 as toggleClass,eZ as toggleAttribute,j4 as show,z4 as setText,H4 as setStyle,Q4 as setProperty,aZ as setAttribute,V$ as schedule,rZ as requestContext,uZ as read,lZ as provideContexts,W4 as pass,X4 as on,PZ as match,u$ as isTask,b$ as isStore,Y$ as isState,x$ as isSlot,d as isSignal,FZ as isSensor,_ as isRecord,w$ as isParser,M$ as isMutableSignal,W$ as isMemo,_$ as isList,O as isFunction,J$ as isEqual,s$ as isComputed,NZ as isCollection,X$ as isAsyncFunction,iZ as defineComponent,B4 as dangerouslySetInnerHTML,P$ as createTask,S$ as createStore,f as createState,i$ as createSlot,o$ as createSensor,v$ as createScope,xZ as createMutableSignal,i as createMemo,N$ as createList,q4 as createEventsSensor,RZ as createElementsMemo,T$ as createEffect,F$ as createComputed,YZ as createCollection,o as batch,K4 as asString,G4 as asNumber,M4 as asJSON,V4 as asInteger,C4 as asEnum,U4 as asBoolean,E$ as NullishSignalValueError,y$ as MissingElementError,AZ as InvalidUIKeyError,K$ as InvalidSignalValueError,a$ as InvalidReactivesError,r$ as InvalidPropertyNameError,n$ as InvalidEffectsError,e$ as InvalidCustomElementError,l$ as InvalidComponentNameError,f$ as InvalidCallbackError,t$ as DependencyTimeoutError,MZ as ContextRequestEvent,H$ as CircularDependencyError,$Z as CONTEXT_REQUEST};

//# debugId=3BD26B22B795E48664756E2164756E21
