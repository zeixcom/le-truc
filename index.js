function x($){return typeof $==="function"}function X$($){return x($)&&$.constructor.name==="AsyncFunction"}function G$($){return x($)&&$.constructor.name!=="AsyncFunction"}function S($,Z){return Object.prototype.toString.call($)===`[object ${Z}]`}function _($){return S($,"Object")}function CZ($,Z=(J)=>J!=null){return Array.isArray($)&&$.every(Z)}function l($){return typeof $==="string"?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($)}class Q$ extends Error{constructor($){super(`[${$}] Circular dependency detected`);this.name="CircularDependencyError"}}class f$ extends TypeError{constructor($){super(`[${$}] Signal value cannot be null or undefined`);this.name="NullishSignalValueError"}}class B$ extends Error{constructor($){super(`[${$}] Signal value is unset`);this.name="UnsetSignalValueError"}}class K$ extends TypeError{constructor($,Z){super(`[${$}] Signal value ${l(Z)} is invalid`);this.name="InvalidSignalValueError"}}class E$ extends TypeError{constructor($,Z){super(`[${$}] Callback ${l(Z)} is invalid`);this.name="InvalidCallbackError"}}class h$ extends Error{constructor($){super(`[${$}] Signal is read-only`);this.name="ReadonlySignalError"}}class k$ extends Error{constructor($){super(`[${$}] Active owner is required`);this.name="RequiredOwnerError"}}class z$ extends Error{constructor($,Z,J){super(`[${$}] Could not add key "${Z}"${J?` with value ${JSON.stringify(J)}`:""} because it already exists`);this.name="DuplicateKeyError"}}function N($,Z,J){if(Z==null)throw new f$($);if(J&&!J(Z))throw new K$($,Z)}function D$($,Z){if(Z==null)throw new B$($)}function k($,Z,J=x){if(!J(Z))throw new E$($,Z)}var r="State",n="Memo",t="Task",a="Sensor",p="List",e="Collection",$$="Store",Z$="Slot",g=0,q$=1,O=2,R$=4,y=8,C=null,c=null,p$=[],A=0,HZ=!1,u=($,Z)=>$===Z,WZ=($,Z)=>!1;function TZ($,Z){let J=Z.sourcesTail;if(J){let X=Z.sources;while(X){if(X===$)return!0;if(X===J)break;X=X.nextSource}}return!1}function I($,Z){let J=Z.sourcesTail;if(J?.source===$)return;let X=null,B=Z.flags&R$;if(B){if(X=J?J.nextSource:Z.sources,X?.source===$){Z.sourcesTail=X;return}}let H=$.sinksTail;if(H?.sink===Z&&(!B||TZ(H,Z)))return;let M={source:$,sink:Z,nextSource:X,prevSink:H,nextSink:null};if(Z.sourcesTail=$.sinksTail=M,J)J.nextSource=M;else Z.sources=M;if(H)H.nextSink=M;else $.sinks=M}function SZ($){let{source:Z,nextSource:J,nextSink:X,prevSink:B}=$;if(X)X.prevSink=B;else Z.sinksTail=B;if(B)B.nextSink=X;else Z.sinks=X;if(!Z.sinks){if(Z.stop)Z.stop(),Z.stop=void 0;if("sources"in Z&&Z.sources){let H=Z;H.sourcesTail=null,C$(H)}}return J}function C$($){let Z=$.sourcesTail,J=Z?Z.nextSource:$.sources;while(J)J=SZ(J);if(Z)Z.nextSource=null;else $.sources=null}function w($,Z=O){let J=$.flags;if("sinks"in $){if((J&(O|q$))>=Z)return;if($.flags=J|Z,"controller"in $&&$.controller)$.controller.abort(),$.controller=void 0;for(let X=$.sinks;X;X=X.nextSink)w(X.sink,q$)}else{if((J&(O|q$))>=Z)return;let X=J&(O|q$);if($.flags=Z,!X)p$.push($)}}function L$($,Z){if($.equals($.value,Z))return;$.value=Z;for(let J=$.sinks;J;J=J.nextSink)w(J.sink);if(A===0)L()}function M$($,Z){if(!$.cleanup)$.cleanup=Z;else if(Array.isArray($.cleanup))$.cleanup.push(Z);else $.cleanup=[$.cleanup,Z]}function g$($){if(!$.cleanup)return;if(Array.isArray($.cleanup))for(let Z=0;Z<$.cleanup.length;Z++)$.cleanup[Z]();else $.cleanup();$.cleanup=null}function bZ($){let Z=C;C=$,$.sourcesTail=null,$.flags=R$;let J=!1;try{let X=$.fn($.value);if($.error||!$.equals(X,$.value))$.value=X,$.error=void 0,J=!0}catch(X){J=!0,$.error=X instanceof Error?X:Error(String(X))}finally{C=Z,C$($)}if(J){for(let X=$.sinks;X;X=X.nextSink)if(X.sink.flags&q$)X.sink.flags|=O}$.flags=g}function yZ($){$.controller?.abort();let Z=new AbortController;$.controller=Z,$.error=void 0;let J=C;C=$,$.sourcesTail=null,$.flags=R$;let X;try{X=$.fn($.value,Z.signal)}catch(B){$.controller=void 0,$.error=B instanceof Error?B:Error(String(B));return}finally{C=J,C$($)}X.then((B)=>{if(Z.signal.aborted)return;if($.controller=void 0,$.error||!$.equals(B,$.value)){$.value=B,$.error=void 0;for(let H=$.sinks;H;H=H.nextSink)w(H.sink);if(A===0)L()}},(B)=>{if(Z.signal.aborted)return;$.controller=void 0;let H=B instanceof Error?B:Error(String(B));if(!$.error||H.name!==$.error.name||H.message!==$.error.message){$.error=H;for(let M=$.sinks;M;M=M.nextSink)w(M.sink);if(A===0)L()}}),$.flags=g}function jZ($){g$($);let Z=C,J=c;C=c=$,$.sourcesTail=null,$.flags=R$;try{let X=$.fn();if(typeof X==="function")M$($,X)}finally{C=Z,c=J,C$($)}$.flags=g}function T($){if($.flags&q$)for(let Z=$.sources;Z;Z=Z.nextSource){if("fn"in Z.source)T(Z.source);if($.flags&O)break}if($.flags&R$)throw new Q$("controller"in $?t:("value"in $)?n:"Effect");if($.flags&O)if("controller"in $)yZ($);else if("value"in $)bZ($);else jZ($);else $.flags=g}function L(){if(HZ)return;HZ=!0;try{for(let $=0;$<p$.length;$++){let Z=p$[$];if(Z.flags&(O|q$))T(Z)}p$.length=0}finally{HZ=!1}}function o($){A++;try{$()}finally{if(A--,A===0)L()}}function s($){let Z=C;C=null;try{return $()}finally{C=Z}}function v$($){let Z=c,J={cleanup:null};c=J;try{let X=$();if(typeof X==="function")M$(J,X);let B=()=>g$(J);if(Z)M$(Z,B);return B}finally{c=Z}}function E($,Z){N(r,$,Z?.guard);let J={value:$,sinks:null,sinksTail:null,equals:Z?.equals??u,guard:Z?.guard};return{[Symbol.toStringTag]:r,get(){if(C)I(J,C);return J.value},set(X){N(r,X,J.guard),L$(J,X)},update(X){k(r,X);let B=X(J.value);N(r,B,J.guard),L$(J,B)}}}function P$($){return S($,r)}function J$($,Z,J){if(Object.is($,Z))return!0;if(typeof $!==typeof Z)return!1;if($==null||typeof $!=="object"||Z==null||typeof Z!=="object")return!1;if(!J)J=new WeakSet;if(J.has($)||J.has(Z))throw new Q$("isEqual");J.add($),J.add(Z);try{let X=Array.isArray($);if(X!==Array.isArray(Z))return!1;if(X){let B=$,H=Z;if(B.length!==H.length)return!1;for(let M=0;M<B.length;M++)if(!J$(B[M],H[M],J))return!1;return!0}if(_($)&&_(Z)){let B=Object.keys($),H=Object.keys(Z);if(B.length!==H.length)return!1;for(let M of B){if(!(M in Z))return!1;if(!J$($[M],Z[M],J))return!1}return!0}return!1}finally{J.delete($),J.delete(Z)}}function d$($,Z){if($.length!==Z.length)return!1;for(let J=0;J<$.length;J++)if($[J]!==Z[J])return!1;return!0}function QZ($){let Z=0,J=typeof $==="function";return[typeof $==="string"?()=>`${$}${Z++}`:J?(X)=>$(X)||String(Z++):()=>String(Z++),J]}function mZ($,Z,J,X,B){let H=new WeakSet,M={},z={},U={},q=[],Q=!1,W=new Map;for(let G=0;G<$.length;G++){let j=J[G];if(j&&$[G])W.set(j,$[G])}let K=new Set;for(let G=0;G<Z.length;G++){let j=Z[G];if(j===void 0)continue;let V=B?X(j):J[G]??X(j);if(K.has(V))throw new z$(p,V,j);if(q.push(V),K.add(V),!W.has(V))M[V]=j,Q=!0;else if(!J$(W.get(V),j,H))z[V]=j,Q=!0}for(let[G]of W)if(!K.has(G))U[G]=null,Q=!0;if(!Q&&!d$(J,q))Q=!0;return{add:M,change:z,remove:U,newKeys:q,changed:Q}}function O$($,Z){N(p,$,Array.isArray);let J=new Map,X=[],[B,H]=QZ(Z?.keyConfig),M=()=>X.map((j)=>J.get(j)?.get()).filter((j)=>j!==void 0),z={fn:M,value:$,flags:O,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:J$,error:void 0},U=(j)=>{let V={};for(let D=0;D<j.length;D++){let P=j[D];if(P===void 0)continue;let Y=X[D];if(!Y)Y=B(P),X[D]=Y;V[Y]=P}return V},q=(j)=>{let V=!1;for(let D in j.add){let P=j.add[D];N(`${p} item for key "${D}"`,P),J.set(D,E(P)),V=!0}if(Object.keys(j.change).length)o(()=>{for(let D in j.change){let P=j.change[D];N(`${p} item for key "${D}"`,P);let Y=J.get(D);if(Y)Y.set(P)}});for(let D in j.remove){J.delete(D);let P=X.indexOf(D);if(P!==-1)X.splice(P,1);V=!0}if(V)z.flags|=y;return j.changed},Q=Z?.watched,W=Q?()=>{if(C){if(!z.sinks)z.stop=Q();I(z,C)}}:()=>{if(C)I(z,C)},K=U($);for(let j in K){let V=K[j];N(`${p} item for key "${j}"`,V),J.set(j,E(V))}z.value=$,z.flags=0;let G={[Symbol.toStringTag]:p,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let j of X){let V=J.get(j);if(V)yield V}},get length(){return W(),X.length},get(){if(W(),z.sources){if(z.flags){let j=z.flags&y;if(z.value=s(M),j){if(z.flags=O,T(z),z.error)throw z.error}else z.flags=g}}else if(T(z),z.error)throw z.error;return z.value},set(j){let V=z.flags&O?M():z.value,D=mZ(V,j,X,B,H);if(D.changed){X=D.newKeys,q(D),z.flags|=O;for(let P=z.sinks;P;P=P.nextSink)w(P.sink);if(A===0)L()}},update(j){G.set(j(G.get()))},at(j){return J.get(X[j])},keys(){return W(),X.values()},byKey(j){return J.get(j)},keyAt(j){return X[j]},indexOfKey(j){return X.indexOf(j)},add(j){let V=B(j);if(J.has(V))throw new z$(p,V,j);if(!X.includes(V))X.push(V);N(`${p} item for key "${V}"`,j),J.set(V,E(j)),z.flags|=O|y;for(let D=z.sinks;D;D=D.nextSink)w(D.sink);if(A===0)L();return V},remove(j){let V=typeof j==="number"?X[j]:j;if(J.delete(V)){let P=typeof j==="number"?j:X.indexOf(V);if(P>=0)X.splice(P,1);z.flags|=O|y;for(let Y=z.sinks;Y;Y=Y.nextSink)w(Y.sink);if(A===0)L()}},sort(j){let D=X.map((P)=>[P,J.get(P)?.get()]).sort(x(j)?(P,Y)=>j(P[1],Y[1]):(P,Y)=>String(P[1]).localeCompare(String(Y[1]))).map(([P])=>P);if(!d$(X,D)){X=D,z.flags|=O;for(let P=z.sinks;P;P=P.nextSink)w(P.sink);if(A===0)L()}},splice(j,V,...D){let P=X.length,Y=j<0?Math.max(0,P+j):Math.min(j,P),F=Math.max(0,Math.min(V??Math.max(0,P-Math.max(0,Y)),P-Y)),b={},h={};for(let v=0;v<F;v++){let j$=Y+v,BZ=X[j$];if(BZ){let DZ=J.get(BZ);if(DZ)h[BZ]=DZ.get()}}let XZ=X.slice(0,Y);for(let v of D){let j$=B(v);if(J.has(j$)&&!(j$ in h))throw new z$(p,j$,v);XZ.push(j$),b[j$]=v}XZ.push(...X.slice(Y+F));let KZ=!!(Object.keys(b).length||Object.keys(h).length);if(KZ){q({add:b,change:{},remove:h,changed:KZ}),X=XZ,z.flags|=O;for(let v=z.sinks;v;v=v.nextSink)w(v.sink);if(A===0)L()}return Object.values(h)},deriveCollection(j){return c$(G,j)}};return G}function _$($){return S($,p)}function i($,Z){if(k(n,$,G$),Z?.value!==void 0)N(n,Z.value,Z?.guard);let J={fn:$,value:Z?.value,flags:O,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:Z?.equals??u,error:void 0,stop:void 0},X=Z?.watched,B=X?()=>{if(C){if(!J.sinks)J.stop=X(()=>{if(w(J),A===0)L()});I(J,C)}}:()=>{if(C)I(J,C)};return{[Symbol.toStringTag]:n,get(){if(B(),T(J),J.error)throw J.error;return D$(n,J.value),J.value}}}function H$($){return S($,n)}function Y$($,Z){if(k(t,$,X$),Z?.value!==void 0)N(t,Z.value,Z?.guard);let J={fn:$,value:Z?.value,sources:null,sourcesTail:null,sinks:null,sinksTail:null,flags:O,equals:Z?.equals??u,controller:void 0,error:void 0,stop:void 0},X=Z?.watched,B=X?()=>{if(C){if(!J.sinks)J.stop=X(()=>{if(w(J),A===0)L()});I(J,C)}}:()=>{if(C)I(J,C)};return{[Symbol.toStringTag]:t,get(){if(B(),T(J),J.error)throw J.error;return D$(t,J.value),J.value},isPending(){return!!J.controller},abort(){J.controller?.abort(),J.controller=void 0}}}function u$($){return S($,t)}function c$($,Z){k(e,Z);let J=X$(Z),X=new Map,B=[],H=(G)=>{let j=J?Y$(async(V,D)=>{let P=$.byKey(G)?.get();if(P==null)return V;return Z(P,D)}):i(()=>{let V=$.byKey(G)?.get();if(V==null)return;return Z(V)});X.set(G,j)};function M(G){if(!d$(B,G)){let j=new Set(B),V=new Set(G);for(let D of B)if(!V.has(D))X.delete(D);for(let D of G)if(!j.has(D))H(D);B=G,q.flags|=y}}function z(){M(Array.from($.keys()));let G=[];for(let j of B)try{let V=X.get(j)?.get();if(V!=null)G.push(V)}catch(V){if(!(V instanceof B$))throw V}return G}let q={fn:z,value:[],flags:O,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:(G,j)=>{if(G.length!==j.length)return!1;for(let V=0;V<G.length;V++)if(G[V]!==j[V])return!1;return!0},error:void 0};function Q(){if(q.sources){if(q.flags)if(q.value=s(z),q.flags&y){if(q.flags=O,T(q),q.error)throw q.error}else q.flags=g}else if(q.sinks){if(T(q),q.error)throw q.error}else q.value=s(z)}let W=Array.from(s(()=>$.keys()));for(let G of W)H(G);B=W;let K={[Symbol.toStringTag]:e,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let G of B){let j=X.get(G);if(j)yield j}},get length(){if(C)I(q,C);return Q(),B.length},keys(){if(C)I(q,C);return Q(),B.values()},get(){if(C)I(q,C);return Q(),q.value},at(G){return X.get(B[G])},byKey(G){return X.get(G)},keyAt(G){return B[G]},indexOfKey(G){return B.indexOf(G)},deriveCollection(G){return c$(K,G)}};return K}function PZ($,Z){let J=Z?.value??[];if(J.length)N(e,J,Array.isArray);k(e,$,G$);let X=new Map,B=[],H=new Map,[M,z]=QZ(Z?.keyConfig),U=(j)=>H.get(j)??(z?M(j):void 0),q=Z?.createItem??E;function Q(){let j=[];for(let V of B)try{let D=X.get(V)?.get();if(D!=null)j.push(D)}catch(D){if(!(D instanceof B$))throw D}return j}let W={fn:Q,value:J,flags:O,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:WZ,error:void 0};for(let j of J){let V=M(j);X.set(V,q(j)),H.set(j,V),B.push(V)}W.value=J,W.flags=O;function K(){if(C){if(!W.sinks)W.stop=$((j)=>{let{add:V,change:D,remove:P}=j;if(!V?.length&&!D?.length&&!P?.length)return;let Y=!1;o(()=>{if(V)for(let F of V){let b=M(F);if(X.set(b,q(F)),H.set(F,b),!B.includes(b))B.push(b);Y=!0}if(D)for(let F of D){let b=U(F);if(!b)continue;let h=X.get(b);if(h&&P$(h))H.delete(h.get()),h.set(F),H.set(F,b)}if(P)for(let F of P){let b=U(F);if(!b)continue;H.delete(F),X.delete(b);let h=B.indexOf(b);if(h!==-1)B.splice(h,1);Y=!0}W.flags=O|(Y?y:0);for(let F=W.sinks;F;F=F.nextSink)w(F.sink)})});I(W,C)}}let G={[Symbol.toStringTag]:e,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let j of B){let V=X.get(j);if(V)yield V}},get length(){return K(),B.length},keys(){return K(),B.values()},get(){if(K(),W.sources){if(W.flags){let j=W.flags&y;if(W.value=s(Q),j){if(W.flags=O,T(W),W.error)throw W.error}else W.flags=g}}else if(T(W),W.error)throw W.error;return W.value},at(j){return X.get(B[j])},byKey(j){return X.get(j)},keyAt(j){return B[j]},indexOfKey(j){return B.indexOf(j)},deriveCollection(j){return c$(G,j)}};return G}function OZ($){return S($,e)}function T$($){k("Effect",$);let Z={fn:$,flags:O,sources:null,sourcesTail:null,cleanup:null},J=()=>{g$(Z),Z.fn=void 0,Z.flags=g,Z.sourcesTail=null,C$(Z)};if(c)M$(c,J);return jZ(Z),J}function YZ($,Z){if(!c)throw new k$("match");let{ok:J,err:X=console.error,nil:B}=Z,H,M=!1,z=Array($.length);for(let q=0;q<$.length;q++)try{z[q]=$[q].get()}catch(Q){if(Q instanceof B$){M=!0;continue}if(!H)H=[];H.push(Q instanceof Error?Q:Error(String(Q)))}let U;try{if(M)U=B?.();else if(H)U=X(H);else U=J(z)}catch(q){X([q instanceof Error?q:Error(String(q))])}if(typeof U==="function")return U;if(U instanceof Promise){let q=c,Q=new AbortController;M$(q,()=>Q.abort()),U.then((W)=>{if(!Q.signal.aborted&&typeof W==="function")M$(q,W)}).catch((W)=>{X([W instanceof Error?W:Error(String(W))])})}}function o$($,Z){if(k(a,$,G$),Z?.value!==void 0)N(a,Z.value,Z?.guard);let J={value:Z?.value,sinks:null,sinksTail:null,equals:Z?.equals??u,guard:Z?.guard,stop:void 0};return{[Symbol.toStringTag]:a,get(){if(C){if(!J.sinks)J.stop=$((X)=>{N(a,X,J.guard),L$(J,X)});I(J,C)}return D$(a,J.value),J.value}}}function NZ($){return S($,a)}function fZ($,Z){let J=_($)||Array.isArray($),X=_(Z)||Array.isArray(Z);if(!J||!X){let W=!Object.is($,Z);return{changed:W,add:W&&X?Z:{},change:{},remove:W&&J?$:{}}}let B=new WeakSet,H={},M={},z={},U=!1,q=Object.keys($),Q=Object.keys(Z);for(let W of Q)if(W in $){if(!J$($[W],Z[W],B))M[W]=Z[W],U=!0}else H[W]=Z[W],U=!0;for(let W of q)if(!(W in Z))z[W]=void 0,U=!0;return{add:H,change:M,remove:z,changed:U}}function S$($,Z){N($$,$,_);let J=new Map,X=(Q,W)=>{if(N(`${$$} for key "${Q}"`,W),Array.isArray(W))J.set(Q,O$(W));else if(_(W))J.set(Q,S$(W));else J.set(Q,E(W))},B=()=>{let Q={};return J.forEach((W,K)=>{Q[K]=W.get()}),Q},H={fn:B,value:$,flags:O,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:J$,error:void 0},M=(Q)=>{let W=!1;for(let K in Q.add)X(K,Q.add[K]),W=!0;if(Object.keys(Q.change).length)o(()=>{for(let K in Q.change){let G=Q.change[K];N(`${$$} for key "${K}"`,G);let j=J.get(K);if(j)if(_(G)!==b$(j))X(K,G),W=!0;else j.set(G)}});for(let K in Q.remove)J.delete(K),W=!0;if(W)H.flags|=y;return Q.changed},z=Z?.watched,U=z?()=>{if(C){if(!H.sinks)H.stop=z();I(H,C)}}:()=>{if(C)I(H,C)};for(let Q of Object.keys($))X(Q,$[Q]);let q={[Symbol.toStringTag]:$$,[Symbol.isConcatSpreadable]:!1,*[Symbol.iterator](){for(let Q of Array.from(J.keys())){let W=J.get(Q);if(W)yield[Q,W]}},keys(){return U(),J.keys()},byKey(Q){return J.get(Q)},get(){if(U(),H.sources){if(H.flags){let Q=H.flags&y;if(H.value=s(B),Q){if(H.flags=O,T(H),H.error)throw H.error}else H.flags=g}}else if(T(H),H.error)throw H.error;return H.value},set(Q){let W=H.flags&O?B():H.value,K=fZ(W,Q);if(M(K)){H.flags|=O;for(let G=H.sinks;G;G=G.nextSink)w(G.sink);if(A===0)L()}},update(Q){q.set(Q(q.get()))},add(Q,W){if(J.has(Q))throw new z$($$,Q,W);X(Q,W),H.flags|=O|y;for(let K=H.sinks;K;K=K.nextSink)w(K.sink);if(A===0)L();return Q},remove(Q){if(J.delete(Q)){H.flags|=O|y;for(let K=H.sinks;K;K=K.nextSink)w(K.sink);if(A===0)L()}}};return new Proxy(q,{get(Q,W){if(W in Q)return Reflect.get(Q,W);if(typeof W!=="symbol")return Q.byKey(W)},has(Q,W){if(W in Q)return!0;return Q.byKey(String(W))!==void 0},ownKeys(Q){return Array.from(Q.keys())},getOwnPropertyDescriptor(Q,W){if(W in Q)return Reflect.getOwnPropertyDescriptor(Q,W);if(typeof W==="symbol")return;let K=Q.byKey(String(W));return K?{enumerable:!0,configurable:!0,writable:!0,value:K}:void 0}})}function b$($){return S($,$$)}function N$($,Z){return X$($)?Y$($,Z):i($,Z)}function FZ($){if(U$($))return $;if($==null||x($)||d($))throw new K$("createMutableSignal",$);if(CZ($))return O$($);if(_($))return S$($);return E($)}function s$($){return H$($)||u$($)}function d($){let Z=[r,n,t,a,Z$,p,e,$$],J=Object.prototype.toString.call($).slice(8,-1);return Z.includes(J)}function U$($){return P$($)||b$($)||_$($)}function i$($,Z){N(Z$,$,d);let J=$,X=Z?.guard,B={fn:()=>J.get(),value:void 0,flags:O,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:Z?.equals??u,error:void 0},H=()=>{if(C)I(B,C);if(T(B),B.error)throw B.error;return B.value},M=(U)=>{if(!U$(J))throw new h$(Z$);N(Z$,U,X),J.set(U)},z=(U)=>{N(Z$,U,d),J=U,B.flags|=O;for(let q=B.sinks;q;q=q.nextSink)w(q.sink);if(A===0)L()};return{[Symbol.toStringTag]:Z$,configurable:!0,enumerable:!0,get:H,set:M,replace:z,current:()=>J}}function F$($){return S($,Z$)}var W$=!1,EZ="debug";var x$="warn",I$="error",hZ=new Set(["constructor","prototype"]),kZ=new Set(["id","class","className","title","role","style","dataset","lang","dir","hidden","children","innerHTML","outerHTML","textContent","innerText"]),pZ=($)=>$?`#${$}`:"",gZ=($)=>$?.length?`.${Array.from($).join(".")}`:"";var zZ=($)=>$.localName.includes("-"),qZ=($)=>zZ($)&&$.matches(":not(:defined)"),R=($)=>$?`<${$.localName}${pZ($.id)}${gZ($.classList)}>`:"<unknown>";var A$=($,Z,J=EZ)=>{if(W$||[I$,x$].includes(J))console[J](Z,$);return $},xZ=($)=>{if(hZ.has($))return`Property name "${$}" is a reserved word`;if(kZ.has($))return`Property name "${$}" conflicts with inherited HTMLElement property`;return null};class l$ extends TypeError{constructor($){super(`Invalid component name "${$}". Custom element names must contain a hyphen, start with a lowercase letter, and contain only lowercase letters, numbers, and hyphens.`);this.name="InvalidComponentNameError"}}class r$ extends TypeError{constructor($,Z,J){super(`Invalid property name "${Z}" for component <${$}>. ${J}`);this.name="InvalidPropertyNameError"}}class n$ extends TypeError{constructor($,Z){super(`Invalid effects in component ${R($)}. Effects must be a record of effects for UI elements or the component, or a Promise that resolves to effects.`);if(this.name="InvalidEffectsError",Z)this.cause=Z}}class IZ extends TypeError{constructor($,Z,J){super(`Invalid UI key "${Z}" in ${J} of component ${R($)}`);this.name="InvalidUIKeyError"}}class y$ extends Error{constructor($,Z,J){super(`Missing required element <${Z}> in component ${R($)}. ${J}`);this.name="MissingElementError"}}class t$ extends Error{constructor($,Z){super(`Timeout waiting for: [${Z.join(", ")}] in component ${R($)}.`);this.name="DependencyTimeoutError"}}class a$ extends TypeError{constructor($,Z,J){super(`Expected reactives passed from ${R($)} to ${R(Z)} to be a record of signals, reactive property names or functions. Got ${l(J)}.`);this.name="InvalidReactivesError"}}class e$ extends TypeError{constructor($,Z){super(`Target ${R($)} is not a custom element in ${Z}.`);this.name="InvalidCustomElementError"}}var MZ=Symbol("RESET"),vZ=($,Z="")=>{return{a:"attribute ",c:"class ",d:"dataset ",h:"inner HTML",m:"method call ",p:"property ",s:"style property ",t:"text content"}[$]+Z},AZ=($,Z)=>{if(!_(Z))throw new n$($.host);return v$(()=>{for(let J of Object.keys(Z)){let X=J;if(!Z[X])continue;let B=Array.isArray(Z[X])?Z[X]:[Z[X]];if(H$($[X]))T$(()=>{for(let H of $[X].get())for(let M of B)M($.host,H)});else if($[X])for(let H of B)H($.host,$[X])}})},dZ=($,Z,J,X)=>{try{return typeof $==="string"?Z[$]:d($)?$.get():x($)?$(J):MZ}catch(B){if(X)A$(B,`Failed to resolve value of ${l($)}${X?` for ${X}`:""} in ${R(J)}${Z!==J?` in ${R(Z)}`:""}`,I$);return MZ}},m=($,Z)=>(J,X)=>{let{op:B,name:H="",read:M,update:z}=Z,U=vZ(B,H),q=(K)=>()=>{if(W$&&J.debug)A$(X,`${K} ${U} of ${R(X)} in ${R(J)}`);Z.resolve?.(X)},Q=(K)=>(G)=>{A$(G,`Failed to ${K} ${U} of ${R(X)} in ${R(J)}`,I$),Z.reject?.(G)},W=M(X);return T$(()=>{let K=dZ($,J,X,U),G=K===MZ?W:K===null?Z.delete?null:W:K;if(Z.delete&&G===null)try{Z.delete(X),q("delete")()}catch(j){Q("delete")(j)}else if(G!=null){let j=M(X);if(Object.is(G,j))return;try{z(X,G),q("update")()}catch(V){Q("update")(V)}}})};var wZ=new WeakMap,m$=($)=>{let Z=wZ.get($);if(!Z)Z={},wZ.set($,Z);return Z};var w$=($)=>x($)&&$.length>=2,cZ=($)=>x($),f=($,Z)=>cZ(Z)?Z($):Z,uZ=($,Z)=>(J)=>{let X=$(J);return typeof X==="string"&&w$(Z)?Z(J,X):X??f(J,Z)};var oZ=200,sZ=($)=>{let Z=new Set;if($.includes("."))Z.add("class");if($.includes("#"))Z.add("id");if($.includes("[")){let J=$.split("[");for(let X=1;X<J.length;X++){let B=J[X];if(!B.includes("]"))continue;let H=B.split("=")[0].trim().replace(/[^a-zA-Z0-9_-]/g,"");if(H)Z.add(H)}}return[...Z]};function RZ($,Z){return i(()=>Array.from($.querySelectorAll(Z)),{value:[],equals:(J,X)=>J.length===X.length&&J.every((B,H)=>B===X[H]),watched:(J)=>{let X={childList:!0,subtree:!0},B=sZ(Z);if(B.length)X.attributes=!0,X.attributeFilter=B;let H=(z)=>z instanceof Element&&(z.matches(Z)||z.querySelector(Z)),M=new MutationObserver((z)=>{for(let U of z){if(U.type==="attributes"){J();return}for(let q of U.addedNodes)if(H(q)){J();return}for(let q of U.removedNodes)if(H(q)){J();return}}});return M.observe($,X),()=>M.disconnect()}})}var LZ=($)=>{let Z=$.shadowRoot??$,J=new Set;function X(M,z){let U=Z.querySelector(M);if(z!=null&&!U)throw new y$($,M,z);if(U&&qZ(U))J.add(U.localName);return U??void 0}function B(M,z){let U=RZ(Z,M),q=U.get();if(z!=null&&!q.length)throw new y$($,M,z);if(q.length){for(let Q of q)if(qZ(Q))J.add(Q.localName)}return U}return[{first:X,all:B},(M)=>{if(J.size)queueMicrotask(()=>{let z=Array.from(J).filter((U)=>!customElements.get(U));if(!z.length){M();return}Promise.race([Promise.all(z.map((U)=>customElements.whenDefined(U))),new Promise((U,q)=>{setTimeout(()=>{q(new t$($,z.filter((Q)=>!customElements.get(Q))))},oZ)})]).then(M).catch((U)=>{if(W$)console[x$](U);M()})});else M()}]};function iZ($,Z={},J=()=>({}),X=()=>({})){if(!$.includes("-")||!$.match(/^[a-z][a-z0-9-]*$/))throw new l$($);for(let H of Object.keys(Z)){let M=xZ(H);if(M)throw new r$($,H,M)}class B extends HTMLElement{debug;#$;#Z;static observedAttributes=Object.entries(Z)?.filter(([,H])=>w$(H)).map(([H])=>H)??[];connectedCallback(){let[H,M]=LZ(this),z={...J(H),host:this};this.#$=z,Object.freeze(this.#$);let U=(Q)=>{return x(Q)},q=(Q,W)=>{let K=w$(W)?W(z,this.getAttribute(Q)):U(W)?W(z):W;if(K!=null)this.#J(Q,K)};for(let[Q,W]of Object.entries(Z)){if(W==null||Q in this)continue;q(Q,W)}M(()=>{this.#Z=AZ(z,X(z))})}disconnectedCallback(){if(x(this.#Z))this.#Z()}attributeChangedCallback(H,M,z){if(!this.#$||z===M||s$(m$(this)[H]))return;let U=Z[H];if(!w$(U))return;let q=U(this.#$,z,M);if(H in this)this[H]=q;else this.#J(H,q)}#J(H,M){let z=d(M)?M:x(M)?N$(M):E(M),U=m$(this),q=H,Q=U[q];if(F$(Q))Q.replace(z);else if(U$(z)){let W=i$(z);U[q]=W,Object.defineProperty(this,H,W)}else U[q]=z,Object.defineProperty(this,H,{get:z.get,enumerable:!0})}}return customElements.define($,B),customElements.get($)}var $Z="context-request";class UZ extends Event{context;callback;subscribe;constructor($,Z,J=!1){super($Z,{bubbles:!0,composed:!0});this.context=$,this.callback=Z,this.subscribe=J}}var lZ=($)=>(Z)=>{let J=(X)=>{let{context:B,callback:H}=X;if(typeof B==="string"&&$.includes(B)&&x(H))X.stopImmediatePropagation(),H(()=>Z[B])};return Z.addEventListener($Z,J),()=>Z.removeEventListener($Z,J)},rZ=($,Z)=>(J)=>{let X=()=>f(J,Z);return J.host.dispatchEvent(new UZ($,(B)=>{X=B})),i(X)};var nZ=($)=>{if(/^(mailto|tel):/i.test($))return!0;if($.includes("://"))try{let Z=new URL($,window.location.origin);return["http:","https:","ftp:"].includes(Z.protocol)}catch{return!1}return!0},tZ=($,Z,J)=>{if(/^on/i.test(Z))throw Error(`Unsafe attribute: ${Z}`);if(J=String(J).trim(),!nZ(J))throw Error(`Unsafe URL for ${Z}: ${J}`);$.setAttribute(Z,J)},aZ=($,Z=$)=>m(Z,{op:"a",name:$,read:(J)=>J.getAttribute($),update:(J,X)=>{tZ(J,$,X)},delete:(J)=>{J.removeAttribute($)}}),eZ=($,Z=$)=>m(Z,{op:"a",name:$,read:(J)=>J.hasAttribute($),update:(J,X)=>{J.toggleAttribute($,X)}});var $4=($,Z=$)=>m(Z,{op:"c",name:$,read:(J)=>J.classList.contains($),update:(J,X)=>{J.classList.toggle($,X)}});var JZ=new Set(["scroll","resize","mousewheel","touchstart","touchmove","wheel"]),VZ=new Set,_Z=new WeakMap,ZZ,Z4=()=>{ZZ=void 0;let $=Array.from(VZ);VZ.clear();for(let Z of $)_Z.get(Z)?.()},J4=()=>{if(ZZ)cancelAnimationFrame(ZZ);ZZ=requestAnimationFrame(Z4)},V$=($,Z)=>{_Z.set($,Z),VZ.add($),J4()};var X4=($,Z,J={})=>(X,B)=>{if(!("passive"in J))J={...J,passive:JZ.has($)};let H=(M)=>{let z=()=>{let U=Z(M);if(!_(U))return;o(()=>{for(let[q,Q]of Object.entries(U))try{X[q]=Q}catch(W){A$(W,`Reactive property "${q}" on ${R(X)} from event ${$} on ${R(B)} could not be set, because it is read-only.`,I$)}})};if(J.passive)V$(B,z);else z()};return B.addEventListener($,H,J),()=>B.removeEventListener($,H)};var B4=($,Z={})=>m($,{op:"h",read:(J)=>(J.shadowRoot||!Z.shadowRootMode?J:null)?.innerHTML??"",update:(J,X)=>{let{shadowRootMode:B,allowScripts:H}=Z;if(!X){if(J.shadowRoot)J.shadowRoot.innerHTML="<slot></slot>";return""}if(B&&!J.shadowRoot)J.attachShadow({mode:B});let M=J.shadowRoot||J;return V$(J,()=>{if(M.innerHTML=X,H){let z=["type","src","async","defer","nomodule","crossorigin","integrity","referrerpolicy","fetchpriority"];M.querySelectorAll("script").forEach((U)=>{let q=document.createElement("script");for(let Q of z)if(U.hasAttribute(Q))q.setAttribute(Q,U.getAttribute(Q));if(!U.hasAttribute("src"))q.appendChild(document.createTextNode(U.textContent??""));M.appendChild(q),U.remove()})}}),H?" with scripts":""}});var H4=($)=>(Z,J)=>{if(!zZ(J))throw new e$(J,`pass from ${R(Z)}`);let X=x($)?$(J):$;if(!_(X))throw new a$(Z,J,X);let B=(z)=>{if(d(z))return z;let U=typeof z==="string"&&z in Z?()=>Z[z]:x(z)?z:void 0;return U?N$(U):void 0},H=m$(J),M=R(J);for(let[z,U]of Object.entries(X)){if(U==null)continue;if(!(z in J)){if(W$)console[x$](`pass(): property '${z}' does not exist on ${M}`);continue}let q=x(U)&&U.length===1?U(J):U,Q=Array.isArray(q)&&q.length===2,W=B(Q?q[0]:q);if(!W)continue;let K=H[z];if(F$(K))K.replace(W);else if(W$)console[x$](`pass(): property '${z}' on ${M} has no Slot â€” binding skipped`)}};var W4=($,Z=$)=>m(Z,{op:"p",name:$,read:(J)=>($ in J)?J[$]??null:null,update:(J,X)=>{J[$]=X}}),j4=($)=>m($,{op:"p",name:"hidden",read:(Z)=>!Z.hidden,update:(Z,J)=>{Z.hidden=!J}});var Q4=($,Z=$)=>m(Z,{op:"s",name:$,read:(J)=>J.style.getPropertyValue($),update:(J,X)=>{J.style.setProperty($,X)},delete:(J)=>{J.style.removeProperty($)}});var z4=($)=>m($,{op:"t",read:(Z)=>Z.textContent,update:(Z,J)=>{Array.from(Z.childNodes).filter((X)=>X.nodeType!==Node.COMMENT_NODE).forEach((X)=>X.remove()),Z.append(document.createTextNode(J))}});var q4=($,Z,J)=>(X)=>{let{host:B}=X,H=f(X,$),M=H$(X[Z])?X[Z]:null,z=M?null:X[Z],U=new Map,q=(Q)=>{if(z)return z.contains(Q)?z:void 0;for(let W of M.get())if(W.contains(Q))return W};return o$((Q)=>{for(let[W,K]of Object.entries(J)){let G={passive:JZ.has(W)},j=(V)=>{let D=V.target;if(!D)return;let P=q(D);if(!P)return;V.stopPropagation();let Y=()=>{try{let F=K({event:V,ui:X,target:P,prev:H});if(F==null||F instanceof Promise)return;if(!Object.is(F,H))H=F,Q(F)}catch(F){throw V.stopImmediatePropagation(),F}};if(G.passive)V$(B,Y);else Y()};U.set(W,j),B.addEventListener(W,j,G)}return()=>{if(U.size){for(let[W,K]of U)B.removeEventListener(W,K);U.clear()}}},{value:H})};var M4=()=>($,Z)=>Z!=null&&Z!=="false";var U4=($)=>(Z,J)=>{if((J??$)==null)throw TypeError("asJSON: Value and fallback are both null or undefined");if(J==null)return f(Z,$);if(J==="")throw TypeError("Empty string is not valid JSON");let X;try{X=JSON.parse(J)}catch(B){throw SyntaxError(`Failed to parse JSON: ${String(B)}`,{cause:B})}return X??f(Z,$)};var GZ=($,Z)=>{if(Z==null)return;let J=$(Z);return Number.isFinite(J)?J:void 0},V4=($=0)=>(Z,J)=>{if(J==null)return f(Z,$);let X=J.trim();if(X.toLowerCase().startsWith("0x"))return GZ((H)=>parseInt(H,16),X)??f(Z,$);let B=GZ(parseFloat,J);return B!=null?Math.trunc(B):f(Z,$)},G4=($=0)=>(Z,J)=>GZ(parseFloat,J)??f(Z,$);var K4=($="")=>(Z,J)=>J??f(Z,$),D4=($)=>(Z,J)=>{if(J==null)return $[0];let X=J.toLowerCase();return $.find((H)=>H.toLowerCase()===X)?J:$[0]};export{l as valueString,m as updateElement,$4 as toggleClass,eZ as toggleAttribute,j4 as show,z4 as setText,Q4 as setStyle,W4 as setProperty,aZ as setAttribute,V$ as schedule,rZ as requestContext,uZ as read,lZ as provideContexts,H4 as pass,X4 as on,YZ as match,u$ as isTask,b$ as isStore,P$ as isState,F$ as isSlot,d as isSignal,NZ as isSensor,_ as isRecord,w$ as isParser,U$ as isMutableSignal,H$ as isMemo,_$ as isList,x as isFunction,J$ as isEqual,s$ as isComputed,OZ as isCollection,X$ as isAsyncFunction,iZ as defineComponent,B4 as dangerouslySetInnerHTML,Y$ as createTask,S$ as createStore,E as createState,i$ as createSlot,o$ as createSensor,v$ as createScope,FZ as createMutableSignal,i as createMemo,O$ as createList,q4 as createEventsSensor,RZ as createElementsMemo,T$ as createEffect,N$ as createComputed,PZ as createCollection,o as batch,K4 as asString,G4 as asNumber,U4 as asJSON,V4 as asInteger,D4 as asEnum,M4 as asBoolean,f$ as NullishSignalValueError,y$ as MissingElementError,IZ as InvalidUIKeyError,K$ as InvalidSignalValueError,a$ as InvalidReactivesError,r$ as InvalidPropertyNameError,n$ as InvalidEffectsError,e$ as InvalidCustomElementError,l$ as InvalidComponentNameError,E$ as InvalidCallbackError,t$ as DependencyTimeoutError,UZ as ContextRequestEvent,Q$ as CircularDependencyError,$Z as CONTEXT_REQUEST};

//# debugId=1F39D8BAA0F1F27264756E2164756E21
