class w extends Error{constructor($){super(`Circular dependency detected in ${$}`);this.name="CircularDependencyError"}}class $$ extends TypeError{constructor($,B){super(`Invalid signal value ${B} in ${$}`);this.name="InvalidSignalValueError"}}class p extends TypeError{constructor($){super(`Nullish signal values are not allowed in ${$}`);this.name="NullishSignalValueError"}}class B$ extends Error{constructor($,B){super(`Could not add store key "${$}" with value ${B} because it already exists`);this.name="StoreKeyExistsError"}}class X$ extends RangeError{constructor($){super(`Could not remove store index ${String($)} because it is out of range`);this.name="StoreKeyRangeError"}}class Z$ extends Error{constructor($,B){super(`Could not set store key "${$}" to ${B} because it is readonly`);this.name="StoreKeyReadonlyError"}}var z=Symbol(),T=($)=>typeof $==="string",L$=($)=>typeof $==="number",s=($)=>typeof $==="symbol",U=($)=>typeof $==="function",i=($)=>U($)&&$.constructor.name==="AsyncFunction",s$=($)=>!!$&&typeof $==="object",v=($,B)=>Object.prototype.toString.call($)===`[object ${B}]`,_=($)=>v($,"Object"),J$=($)=>_($)||Array.isArray($),i$=($)=>{if(!$.length)return null;let B=$.map((X)=>T(X)?parseInt(X,10):L$(X)?X:NaN);return B.every((X)=>Number.isFinite(X)&&X>=0)?B.sort((X,Z)=>X-Z):null};var c=($)=>$ instanceof DOMException&&$.name==="AbortError",S=($)=>$ instanceof Error?$:Error(String($));var x$=($)=>{let B=i$(Object.keys($));if(B===null)return $;let X=[];for(let Z of B)X.push($[String(Z)]);return X},Y$=($)=>T($)?`"${$}"`:s$($)?JSON.stringify($):String($);var k=($,B,X)=>{if(Object.is($,B))return!0;if(typeof $!==typeof B)return!1;if(typeof $!=="object"||$===null||B===null)return!1;if(!X)X=new WeakSet;if(X.has($)||X.has(B))throw new w("isEqual");X.add($),X.add(B);try{if(Array.isArray($)&&Array.isArray(B)){if($.length!==B.length)return!1;for(let Z=0;Z<$.length;Z++)if(!k($[Z],B[Z],X))return!1;return!0}if(Array.isArray($)!==Array.isArray(B))return!1;if(_($)&&_(B)){let Z=Object.keys($),W=Object.keys(B);if(Z.length!==W.length)return!1;for(let J of Z){if(!(J in B))return!1;if(!k($[J],B[J],X))return!1}return!0}return!1}finally{X.delete($),X.delete(B)}},H$=($,B)=>{let X=J$($),Z=J$(B);if(!X||!Z){let G=!Object.is($,B);return{changed:G,add:G&&Z?B:{},change:{},remove:G&&X?$:{}}}let W=new WeakSet,J={},Q={},Y={},H=Object.keys($),C=Object.keys(B),L=new Set([...H,...C]);for(let G of L){let I=G in $,R=G in B;if(!I&&R){J[G]=B[G];continue}else if(I&&!R){Y[G]=z;continue}let x=$[G],K=B[G];if(!k(x,K,W))Q[G]=K}return{changed:Object.keys(J).length>0||Object.keys(Q).length>0||Object.keys(Y).length>0,add:J,change:Q,remove:Y}};var u,G$=new Set,D$=0,_$=new Map,C$,h$=()=>{C$=void 0;let $=Array.from(_$.values());_$.clear();for(let B of $)B()},l$=()=>{if(C$)cancelAnimationFrame(C$);C$=requestAnimationFrame(h$)};queueMicrotask(h$);var Q$=($)=>{let B=new Set,X=$;return X.off=(Z)=>{B.add(Z)},X.cleanup=()=>{for(let Z of B)Z();B.clear()},X},h=($)=>{if(u&&!$.has(u)){let B=u;$.add(B),u.off(()=>{$.delete(B)})}},P=($)=>{for(let B of $)if(D$)G$.add(B);else B()},q$=()=>{while(G$.size){let $=Array.from(G$);G$.clear();for(let B of $)B()}},l=($)=>{D$++;try{$()}finally{q$(),D$--}},K$=($,B)=>{let X=u;u=B;try{$()}finally{u=X}},m$=($,B)=>new Promise((X,Z)=>{_$.set(B||Symbol(),()=>{try{X($())}catch(W){Z(W)}}),l$()});var V$="Computed",m=($)=>{let B=new Set,X=z,Z,W,J=!0,Q=!1,Y=!1,H=(x)=>{if(!k(x,X))X=x,Q=!0;Z=void 0,J=!1},C=()=>{Q=z!==X,X=z,Z=void 0},L=(x)=>{let K=S(x);Q=!Z||K.name!==Z.name||K.message!==Z.message,X=z,Z=K},F=(x)=>(K)=>{if(Y=!1,W=void 0,x(K),Q)P(B)},G=Q$(()=>{if(J=!0,W?.abort(),B.size)P(B);else G.cleanup()});G.off(()=>{W?.abort()});let I=()=>K$(()=>{if(Y)throw new w("computed");if(Q=!1,i($)){if(W)return X;W=new AbortController,W.signal.addEventListener("abort",()=>{Y=!1,W=void 0,I()},{once:!0})}let x;Y=!0;try{x=W?$(W.signal):$()}catch(K){if(c(K))C();else L(K);Y=!1;return}if(x instanceof Promise)x.then(F(H),F(L));else if(x==null||z===x)C();else H(x);Y=!1},G);return{[Symbol.toStringTag]:V$,get:()=>{if(h(B),q$(),J)I();if(Z)throw Z;return X}}},g=($)=>v($,V$),o=($)=>U($)&&$.length<2;var E=($)=>{let B=i($),X=!1,Z,W=Q$(()=>K$(()=>{if(X)throw new w("effect");X=!0,Z?.abort(),Z=void 0;let J;try{if(B){Z=new AbortController;let Q=Z;$(Z.signal).then((Y)=>{if(U(Y)&&Z===Q)W.off(Y)}).catch((Y)=>{if(!c(Y))console.error("Async effect error:",Y)})}else if(J=$(),U(J))W.off(J)}catch(Q){if(!c(Q))console.error("Effect callback error:",Q)}X=!1},W));return W(),()=>{Z?.abort(),W.cleanup()}};function g$($,B){try{if($.pending)B.nil?.();else if($.errors)B.err?.($.errors);else if($.ok)B.ok($.values)}catch(X){if(B.err&&(!$.errors||!$.errors.includes(S(X))))B.err($.errors?[...$.errors,S(X)]:[S(X)]);else throw X}}function f$($){let B=[],X=!1,Z={};for(let[W,J]of Object.entries($))try{let Q=J.get();if(Q===z)X=!0;else Z[W]=Q}catch(Q){B.push(S(Q))}if(X)return{ok:!1,pending:!0};if(B.length>0)return{ok:!1,errors:B};return{ok:!0,values:Z}}var R$="State",b=($)=>{let B=new Set,X=$,Z={[Symbol.toStringTag]:R$,get:()=>{return h(B),X},set:(W)=>{if(W==null)throw new p("state");if(k(X,W))return;if(X=W,P(B),z===X)B.clear()},update:(W)=>{Z.set(W(X))}};return Z},O=($)=>v($,R$);var A$="Store",P$="store-add",d$="store-change",p$="store-remove",r$="store-sort",r=($)=>{let B=new Set,X=new EventTarget,Z=new Map,W=new Map,J=Array.isArray($),Q=b(0),Y=()=>{let x={};for(let[K,A]of Z)x[K]=A.get();return x},H=(x,K)=>X.dispatchEvent(new CustomEvent(x,{detail:K})),C=()=>Array.from(Z.keys()).map((x)=>Number(x)).filter((x)=>Number.isInteger(x)).sort((x,K)=>x-K),L=(x,K)=>{if(K==null)throw new p(`store for key "${x}"`);if(K===z)return!0;if(s(K)||U(K)||g(K))throw new $$(`store for key "${x}"`,Y$(K));return!0},F=(x,K,A=!1)=>{if(!L(x,K))return!1;let q=O(K)||f(K)?K:_(K)?r(K):Array.isArray(K)?r(K):b(K);Z.set(x,q);let M=E(()=>{let D=q.get();if(D!=null)H(d$,{[x]:D})});if(W.set(x,M),A)Q.set(Z.size),P(B),H(P$,{[x]:K});return!0},G=(x,K=!1)=>{let A=Z.delete(x);if(A){let q=W.get(x);if(q)q();W.delete(x)}if(K)Q.set(Z.size),P(B),H(p$,{[x]:z});return A},I=(x,K,A)=>{let q=H$(x,K);return l(()=>{if(Object.keys(q.add).length){for(let M in q.add){let D=q.add[M]??z;F(M,D)}if(A)setTimeout(()=>{H(P$,q.add)},0);else H(P$,q.add)}if(Object.keys(q.change).length){for(let M in q.change){let D=q.change[M];if(!L(M,D))continue;let W$=Z.get(M);if(t(W$))W$.set(D);else throw new Z$(M,Y$(D))}H(d$,q.change)}if(Object.keys(q.remove).length){for(let M in q.remove)G(M);H(p$,q.remove)}Q.set(Z.size)}),q.changed};I({},$,!0);let R={add:J?(x)=>{let K=Z.size,A=String(K);F(A,x,!0)}:(x,K)=>{if(!Z.has(x))F(x,K,!0);else throw new B$(x,Y$(K))},get:()=>{return h(B),x$(Y())},remove:J?(x)=>{let K=x$(Y()),A=Z.size;if(!Array.isArray(K)||x<=-A||x>=A)throw new X$(x);let q=[...K];if(q.splice(x,1),I(K,q))P(B)}:(x)=>{if(Z.has(x))G(x,!0)},set:(x)=>{if(I(Y(),x)){if(P(B),z===x)B.clear()}},update:(x)=>{let K=Y(),A=x(x$(K));if(I(K,A)){if(P(B),z===A)B.clear()}},sort:(x)=>{let K=Array.from(Z.entries()).map(([M,D])=>[M,D.get()]).sort(x?(M,D)=>x(M[1],D[1]):(M,D)=>String(M[1]).localeCompare(String(D[1]))),A=K.map(([M])=>String(M)),q=new Map;K.forEach(([M],D)=>{let W$=String(M),n$=J?String(D):String(M),b$=Z.get(W$);if(b$)q.set(n$,b$)}),Z.clear(),q.forEach((M,D)=>Z.set(D,M)),P(B),H(r$,A)},addEventListener:X.addEventListener.bind(X),removeEventListener:X.removeEventListener.bind(X),dispatchEvent:X.dispatchEvent.bind(X),size:Q};return new Proxy({},{get(x,K){if(K===Symbol.toStringTag)return A$;if(K===Symbol.isConcatSpreadable)return J;if(K===Symbol.iterator)return J?function*(){let A=C();for(let q of A){let M=Z.get(String(q));if(M)yield M}}:function*(){for(let[A,q]of Z)yield[A,q]};if(s(K))return;if(K in R)return R[K];if(K==="length"&&J)return h(B),Q.get();return Z.get(K)},has(x,K){let A=String(K);return A&&Z.has(A)||Object.keys(R).includes(A)||K===Symbol.toStringTag||K===Symbol.iterator||K===Symbol.isConcatSpreadable||K==="length"&&J},ownKeys(){return J?C().map((x)=>String(x)).concat(["length"]):Array.from(Z.keys()).map((x)=>String(x))},getOwnPropertyDescriptor(x,K){let A=(M)=>({enumerable:!1,configurable:!0,writable:!1,value:M});if(K==="length"&&J)return{enumerable:!0,configurable:!0,writable:!1,value:Q.get()};if(K===Symbol.isConcatSpreadable)return A(J);if(K===Symbol.toStringTag)return A(A$);if(s(K))return;if(Object.keys(R).includes(K))return A(R[K]);let q=Z.get(K);return q?{enumerable:!0,configurable:!0,writable:!0,value:q}:void 0}})},f=($)=>v($,A$);var y=($)=>O($)||g($)||f($),t=($)=>O($)||f($);function v$($){if(y($))return $;if(o($))return m($);if(Array.isArray($)||_($))return r($);return b($)}var z$=!1,t$="debug";var a$="warn",n="error",e$=new Set(["constructor","prototype"]),$B=new Set(["id","class","className","title","role","style","dataset","lang","dir","hidden","children","innerHTML","outerHTML","textContent","innerText"]),BB=($)=>$?`#${$}`:"",XB=($)=>$?.length?`.${Array.from($).join(".")}`:"";var M$=($)=>$.localName.includes("-"),j=($)=>$?`<${$.localName}${BB($.id)}${XB($.classList)}>`:"<unknown>",U$=($)=>T($)?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($);var d=($,B,X=t$)=>{if(z$||[n,a$].includes(X))console[X](B,$);return $},c$=($)=>{if(e$.has($))return`Property name "${$}" is a reserved word`;if($B.has($))return`Property name "${$}" conflicts with inherited HTMLElement property`;return null};class T$ extends TypeError{constructor($){super(`Invalid component name "${$}". Custom element names must contain a hyphen, start with a lowercase letter, and contain only lowercase letters, numbers, and hyphens.`);this.name="InvalidComponentNameError"}}class O$ extends TypeError{constructor($,B,X){super(`Invalid property name "${B}" for component <${$}>. ${X}`);this.name="InvalidPropertyNameError"}}class I$ extends TypeError{constructor($,B){super(`Invalid effects in component ${j($)}. Effects must be a record of effects for UI elements or the component, or a Promise that resolves to effects.`);if(this.name="InvalidEffectsError",B)this.cause=B}}class j$ extends Error{constructor($,B,X){super(`Missing required element <${B}> in component ${j($)}. ${X}`);this.name="MissingElementError"}}class N$ extends Error{constructor($,B){super(`Timeout waiting for: [${B.join(", ")}] in component ${j($)}.`);this.name="DependencyTimeoutError"}}class S$ extends TypeError{constructor($,B,X){super(`Expected reactives passed from ${j($)} to ${j(B)} to be a record of signals, reactive property names or functions. Got ${U$(X)}.`);this.name="InvalidReactivesError"}}class y$ extends TypeError{constructor($,B){super(`Target ${j($)} is not a custom element in ${B}.`);this.name="InvalidCustomElementError"}}var a=Symbol("RESET"),ZB=($,B="")=>{return{a:"attribute ",c:"class ",d:"dataset ",h:"inner HTML",m:"method call ",p:"property ",s:"style property ",t:"text content"}[$]+B},w$=($,B,X)=>{let Z=$[B],W=Array.isArray(Z)?Z:[Z];if(!W.length)return;try{if(X instanceof Promise)throw X;let J=[];for(let Q of X)W.forEach((Y)=>{let H=Q($.host,Y);if(H)J.push(H)});return()=>{J.forEach((Q)=>Q()),J.length=0}}catch(J){if(J instanceof Promise)J.then(()=>w$($,B,X));else throw new I$($.host,J instanceof Error?J:Error(String(J)))}},k$=($,B)=>{if(!_(B))throw new I$($.host);let X=[],Z=Object.keys(B);for(let W of Z){let J=W;if(!B[J])continue;let Q=w$($,J,Array.isArray(B[J])?B[J]:[B[J]]);if(Q)X.push(Q)}return()=>{X.forEach((W)=>W()),X.length=0}},F$=($,B,X,Z)=>{try{return T($)?B[$]:y($)?$.get():U($)?$(X):a}catch(W){if(Z)d(W,`Failed to resolve value of ${U$($)}${Z?` for ${Z}`:""} in ${j(X)}${B!==X?` in ${j(B)}`:""}`,n);return a}},V=($,B)=>(X,Z)=>{let{op:W,name:J="",read:Q,update:Y}=B,H=ZB(W,J),C=(G)=>()=>{if(z$&&X.debug)d(Z,`${G} ${H} of ${j(Z)} in ${j(X)}`);B.resolve?.(Z)},L=(G)=>(I)=>{d(I,`Failed to ${G} ${H} of ${j(Z)} in ${j(X)}`,n),B.reject?.(I)},F=Q(Z);return E(()=>{let G=F$($,X,Z,H),I=G===a?F:G===z?B.delete?null:F:G;if(B.delete&&I===null)try{B.delete(Z),C("delete")()}catch(R){L("delete")(R)}else if(I!=null){let R=Q(Z);if(Object.is(I,R))return;try{Y(Z,I),C("update")()}catch(x){L("update")(x)}}})},JB=($,B)=>(X,Z)=>{let W=(Q)=>()=>{if(z$&&X.debug)d(Z,`${Q} element in ${j(Z)} in ${j(X)}`);if(U(B?.resolve))B.resolve(Z);else{let Y=y($)?$:void 0;if(O(Y))Y.set(0)}},J=(Q)=>(Y)=>{d(Y,`Failed to ${Q} element in ${j(Z)} in ${j(X)}`,n),B?.reject?.(Y)};return E(()=>{let Q=F$($,X,Z,"insertion or deletion"),Y=Q===a?0:Q;if(Y>0){if(!B)throw TypeError("No inserter provided");try{for(let H=0;H<Y;H++){let C=B.create(Z);if(!C)continue;Z.insertAdjacentElement(B.position??"beforeend",C)}W("insert")()}catch(H){J("insert")(H)}}else if(Y<0)try{if(B&&(B.position==="afterbegin"||B.position==="beforeend"))for(let H=0;H>Y;H--)if(B.position==="afterbegin")Z.firstElementChild?.remove();else Z.lastElementChild?.remove();else Z.remove();W("remove")()}catch(H){J("remove")(H)}})};var e=($)=>U($)&&$.length>=2,N=($,B)=>U(B)?B($):B,QB=($,B)=>(X)=>{let Z=$(X);return T(Z)&&e(B)?B(X,Z):Z??N(X,B)};var u$=($)=>M$($)&&$.matches(":not(:defined)");var o$=($)=>{let B=$.shadowRoot??$,X=new Set;function Z(J,Q){let Y=B.querySelector(J);if(Q!=null&&!Y)throw new j$($,J,Q);if(Y&&u$(Y))X.add(Y.localName);return Y??void 0}function W(J,Q){let Y=B.querySelectorAll(J);if(Q!=null&&!Y.length)throw new j$($,J,Q);if(Y.length)Y.forEach((H)=>{if(u$(H))X.add(H.localName)});return Array.from(Y)}return[{first:Z,all:W},()=>Array.from(X)]};var KB=50;function WB($,B={},X=()=>({}),Z=()=>({})){if(!$.includes("-")||!$.match(/^[a-z][a-z0-9-]*$/))throw new T$($);for(let J of Object.keys(B)){let Q=c$(J);if(Q)throw new O$($,J,Q)}class W extends HTMLElement{debug;#$={};#B={};#X;static observedAttributes=Object.entries(B)?.filter(([,J])=>e(J)).map(([J])=>J)??[];connectedCallback(){let[J,Q]=o$(this);this.#$={...X(J),host:this},Object.freeze(this.#$);let Y=(F,G)=>{let I=U(G)?e(G)?G(this.#$,null):G(this.#$):G;if(I!=null)this.#Z(F,I)};for(let[F,G]of Object.entries(B)){if(G==null||F in this)continue;Y(F,G)}let H=Z(this.#$),C=Q(),L=()=>{this.#X=k$(this.#$,H)};if(C.length)Promise.race([Promise.all(C.map((F)=>customElements.whenDefined(F))),new Promise((F,G)=>{setTimeout(()=>{G(new N$(this,C.filter((I)=>!customElements.get(I))))},KB)})]).then(L).catch(()=>{L()});else L()}disconnectedCallback(){if(U(this.#X))this.#X()}attributeChangedCallback(J,Q,Y){if(Y===Q||g(this.#B[J]))return;let H=B[J];if(!e(H))return;let C=H(this.#$,Y,Q);if(J in this)this[J]=C;else this.#Z(J,C)}#Z(J,Q){let Y=y(Q)?Q:o(Q)?m(Q):b(Q),H=this.#B[J],C=t(Y);if(this.#B[J]=Y,Object.defineProperty(this,J,{get:Y.get,set:C?Y.set:void 0,enumerable:!0,configurable:C}),H&&O(H)||f(H))H.set(z)}}return customElements.define($,W),customElements.get($)}var xB=($)=>{if(/^(mailto|tel):/i.test($))return!0;if($.includes("://"))try{let B=new URL($,window.location.origin);return["http:","https:","ftp:"].includes(B.protocol)}catch{return!1}return!0},YB=($,B,X)=>{if(/^on/i.test(B))throw Error(`Unsafe attribute: ${B}`);if(X=String(X).trim(),!xB(X))throw Error(`Unsafe URL for ${B}: ${X}`);$.setAttribute(B,X)},HB=($,B=$)=>V(B,{op:"a",name:$,read:(X)=>X.getAttribute($),update:(X,Z)=>{YB(X,$,Z)},delete:(X)=>{X.removeAttribute($)}}),GB=($,B=$)=>V(B,{op:"a",name:$,read:(X)=>X.hasAttribute($),update:(X,Z)=>{X.toggleAttribute($,Z)}});var CB=($,B=$)=>V(B,{op:"c",name:$,read:(X)=>X.classList.contains($),update:(X,Z)=>{X.classList.toggle($,Z)}});var qB=($,B,X=!1)=>(Z,W)=>{let J=(Q)=>{let Y=B({host:Z,target:W,event:Q});if(!_(Y))return;l(()=>{for(let[H,C]of Object.entries(Y))try{Z[H]=C}catch(L){d(L,`Reactive property "${H}" on ${j(Z)} from event ${$} on ${j(W)} could not be set, because it is read-only.`,n)}})};return W.addEventListener($,J,X),()=>W.removeEventListener($,J)},AB=($,B)=>(X,Z)=>E(()=>{let W=F$(B,X,Z,`custom event "${$}" detail`);if(W===a||W===z)return;Z.dispatchEvent(new CustomEvent($,{detail:W,bubbles:!0}))});var zB=($,B={})=>V($,{op:"h",read:(X)=>(X.shadowRoot||!B.shadowRootMode?X:null)?.innerHTML??"",update:(X,Z)=>{let{shadowRootMode:W,allowScripts:J}=B;if(!Z){if(X.shadowRoot)X.shadowRoot.innerHTML="<slot></slot>";return""}if(W&&!X.shadowRoot)X.attachShadow({mode:W});let Q=X.shadowRoot||X;if(Q.innerHTML=Z,!J)return"";return Q.querySelectorAll("script").forEach((Y)=>{let H=document.createElement("script");H.appendChild(document.createTextNode(Y.textContent??"")),Q.appendChild(H),Y.remove()})," with scripts"}});var MB=($)=>(B,X)=>{if(!M$(X))throw new y$(X,`pass from ${j(B)}`);let Z=U($)?$(X):$;if(!_(Z))throw new S$(B,X,Z);let W={},J=(Q)=>{if(y(Q))return Q.get;let Y=T(Q)&&Q in B?()=>B[Q]:o(Q)?Q:void 0;return Y?m(Y).get:void 0};for(let[Q,Y]of Object.entries(Z)){if(Y==null)continue;let H=Object.getOwnPropertyDescriptor(X,Q);if(!(Q in X)||!H?.configurable)continue;let C=U(Y)&&Y.length===1?Y(X):Y,L=Array.isArray(C)&&C.length===2,F=J(L?C[0]:C),G=L&&U(C[1])?C[1]:void 0;if(!F)continue;W[Q]=H,Object.defineProperty(X,Q,{configurable:!0,enumerable:!0,get:F,set:G}),H.set?.call(X,z)}return()=>{Object.defineProperties(X,W)}};var UB=($,B=$)=>V(B,{op:"p",name:$,read:(X)=>($ in X)?X[$]:z,update:(X,Z)=>{X[$]=Z}}),IB=($)=>V($,{op:"p",name:"hidden",read:(B)=>!B.hidden,update:(B,X)=>{B.hidden=!X}});var jB=($,B=$)=>V(B,{op:"s",name:$,read:(X)=>X.style.getPropertyValue($),update:(X,Z)=>{X.style.setProperty($,Z)},delete:(X)=>{X.style.removeProperty($)}});var FB=($)=>V($,{op:"t",read:(B)=>B.textContent,update:(B,X)=>{Array.from(B.childNodes).filter((Z)=>Z.nodeType!==Node.COMMENT_NODE).forEach((Z)=>Z.remove()),B.append(document.createTextNode(X))}});var LB=()=>($,B)=>B!=null&&B!=="false";var DB=($)=>(B,X)=>{if((X??$)==null)throw TypeError("asJSON: Value and fallback are both null or undefined");if(X==null)return N(B,$);if(X==="")throw TypeError("Empty string is not valid JSON");let Z;try{Z=JSON.parse(X)}catch(W){throw SyntaxError(`Failed to parse JSON: ${String(W)}`,{cause:W})}return Z??N(B,$)};var E$=($,B)=>{if(B==null)return;let X=$(B);return Number.isFinite(X)?X:void 0},_B=($=0)=>(B,X)=>{if(X==null)return N(B,$);let Z=X.trim();if(Z.toLowerCase().startsWith("0x"))return E$((J)=>parseInt(J,16),Z)??N(B,$);let W=E$(parseFloat,X);return W!=null?Math.trunc(W):N(B,$)},VB=($=0)=>(B,X)=>E$(parseFloat,X)??N(B,$);var RB=($="")=>(B,X)=>X??N(B,$),PB=($)=>(B,X)=>{if(X==null)return $[0];let Z=X.toLowerCase();return $.find((J)=>J.toLowerCase()===Z)?X:$[0]};export{V as updateElement,CB as toggleClass,GB as toggleAttribute,v$ as toSignal,S as toError,r as store,b as state,IB as show,FB as setText,jB as setStyle,UB as setProperty,HB as setAttribute,w$ as runElementEffects,k$ as runEffects,f$ as resolve,QB as read,MB as pass,qB as on,g$ as match,s as isSymbol,T as isString,f as isStore,O as isState,y as isSignal,J$ as isRecordOrArray,_ as isRecord,e as isParser,L$ as isNumber,t as isMutableSignal,U as isFunction,k as isEqual,g as isComputed,i as isAsyncFunction,c as isAbortError,JB as insertOrRemoveElement,m$ as enqueue,AB as emit,E as effect,H$ as diff,zB as dangerouslySetInnerHTML,m as computed,WB as component,l as batch,RB as asString,VB as asNumber,DB as asJSON,_B as asInteger,PB as asEnum,LB as asBoolean,z as UNSET,Z$ as StoreKeyReadonlyError,X$ as StoreKeyRangeError,B$ as StoreKeyExistsError,p as NullishSignalValueError,$$ as InvalidSignalValueError,w as CircularDependencyError};

//# debugId=9953727927DBB39864756E2164756E21
