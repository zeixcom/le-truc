class w extends Error{constructor($){super(`Circular dependency detected in ${$}`);this.name="CircularDependencyError"}}class $$ extends TypeError{constructor($,B){super(`Invalid signal value ${B} in ${$}`);this.name="InvalidSignalValueError"}}class p extends TypeError{constructor($){super(`Nullish signal values are not allowed in ${$}`);this.name="NullishSignalValueError"}}class B$ extends Error{constructor($,B){super(`Could not add store key "${$}" with value ${B} because it already exists`);this.name="StoreKeyExistsError"}}class X$ extends RangeError{constructor($){super(`Could not remove store index ${String($)} because it is out of range`);this.name="StoreKeyRangeError"}}class Z$ extends Error{constructor($,B){super(`Could not set store key "${$}" to ${B} because it is readonly`);this.name="StoreKeyReadonlyError"}}var z=Symbol(),T=($)=>typeof $==="string",D$=($)=>typeof $==="number",s=($)=>typeof $==="symbol",I=($)=>typeof $==="function",i=($)=>I($)&&$.constructor.name==="AsyncFunction",s$=($)=>!!$&&typeof $==="object",v=($,B)=>Object.prototype.toString.call($)===`[object ${B}]`,_=($)=>v($,"Object"),J$=($)=>_($)||Array.isArray($),i$=($)=>{if(!$.length)return null;let B=$.map((X)=>T(X)?parseInt(X,10):D$(X)?X:NaN);return B.every((X)=>Number.isFinite(X)&&X>=0)?B.sort((X,Z)=>X-Z):null};var c=($)=>$ instanceof DOMException&&$.name==="AbortError",S=($)=>$ instanceof Error?$:Error(String($));var x$=($)=>{let B=i$(Object.keys($));if(B===null)return $;let X=[];for(let Z of B)X.push($[String(Z)]);return X},Y$=($)=>T($)?`"${$}"`:s$($)?JSON.stringify($):String($);var k=($,B,X)=>{if(Object.is($,B))return!0;if(typeof $!==typeof B)return!1;if(typeof $!=="object"||$===null||B===null)return!1;if(!X)X=new WeakSet;if(X.has($)||X.has(B))throw new w("isEqual");X.add($),X.add(B);try{if(Array.isArray($)&&Array.isArray(B)){if($.length!==B.length)return!1;for(let Z=0;Z<$.length;Z++)if(!k($[Z],B[Z],X))return!1;return!0}if(Array.isArray($)!==Array.isArray(B))return!1;if(_($)&&_(B)){let Z=Object.keys($),W=Object.keys(B);if(Z.length!==W.length)return!1;for(let J of Z){if(!(J in B))return!1;if(!k($[J],B[J],X))return!1}return!0}return!1}finally{X.delete($),X.delete(B)}},H$=($,B)=>{let X=J$($),Z=J$(B);if(!X||!Z){let G=!Object.is($,B);return{changed:G,add:G&&Z?B:{},change:{},remove:G&&X?$:{}}}let W=new WeakSet,J={},Q={},x={},H=Object.keys($),C=Object.keys(B),L=new Set([...H,...C]);for(let G of L){let M=G in $,R=G in B;if(!M&&R){J[G]=B[G];continue}else if(M&&!R){x[G]=z;continue}let Y=$[G],K=B[G];if(!k(Y,K,W))Q[G]=K}return{changed:Object.keys(J).length>0||Object.keys(Q).length>0||Object.keys(x).length>0,add:J,change:Q,remove:x}};var o,G$=new Set,_$=0,V$=new Map,C$,m$=()=>{C$=void 0;let $=Array.from(V$.values());V$.clear();for(let B of $)B()},l$=()=>{if(C$)cancelAnimationFrame(C$);C$=requestAnimationFrame(m$)};queueMicrotask(m$);var Q$=($)=>{let B=new Set,X=$;return X.off=(Z)=>{B.add(Z)},X.cleanup=()=>{for(let Z of B)Z();B.clear()},X},m=($)=>{if(o&&!$.has(o)){let B=o;$.add(B),o.off(()=>{$.delete(B)})}},P=($)=>{for(let B of $)if(_$)G$.add(B);else B()},q$=()=>{while(G$.size){let $=Array.from(G$);G$.clear();for(let B of $)B()}},l=($)=>{_$++;try{$()}finally{q$(),_$--}},K$=($,B)=>{let X=o;o=B;try{$()}finally{o=X}},h$=($,B)=>new Promise((X,Z)=>{V$.set(B||Symbol(),()=>{try{X($())}catch(W){Z(W)}}),l$()});var R$="Computed",h=($)=>{let B=new Set,X=z,Z,W,J=!0,Q=!1,x=!1,H=(Y)=>{if(!k(Y,X))X=Y,Q=!0;Z=void 0,J=!1},C=()=>{Q=z!==X,X=z,Z=void 0},L=(Y)=>{let K=S(Y);Q=!Z||K.name!==Z.name||K.message!==Z.message,X=z,Z=K},F=(Y)=>(K)=>{if(x=!1,W=void 0,Y(K),Q)P(B)},G=Q$(()=>{if(J=!0,W?.abort(),B.size)P(B);else G.cleanup()});G.off(()=>{W?.abort()});let M=()=>K$(()=>{if(x)throw new w("computed");if(Q=!1,i($)){if(W)return X;W=new AbortController,W.signal.addEventListener("abort",()=>{x=!1,W=void 0,M()},{once:!0})}let Y;x=!0;try{Y=W?$(W.signal):$()}catch(K){if(c(K))C();else L(K);x=!1;return}if(Y instanceof Promise)Y.then(F(H),F(L));else if(Y==null||z===Y)C();else H(Y);x=!1},G);return{[Symbol.toStringTag]:R$,get:()=>{if(m(B),q$(),J)M();if(Z)throw Z;return X}}},g=($)=>v($,R$),u=($)=>I($)&&$.length<2;var E=($)=>{let B=i($),X=!1,Z,W=Q$(()=>K$(()=>{if(X)throw new w("effect");X=!0,Z?.abort(),Z=void 0;let J;try{if(B){Z=new AbortController;let Q=Z;$(Z.signal).then((x)=>{if(I(x)&&Z===Q)W.off(x)}).catch((x)=>{if(!c(x))console.error("Async effect error:",x)})}else if(J=$(),I(J))W.off(J)}catch(Q){if(!c(Q))console.error("Effect callback error:",Q)}X=!1},W));return W(),()=>{Z?.abort(),W.cleanup()}};function g$($,B){try{if($.pending)B.nil?.();else if($.errors)B.err?.($.errors);else if($.ok)B.ok($.values)}catch(X){if(B.err&&(!$.errors||!$.errors.includes(S(X))))B.err($.errors?[...$.errors,S(X)]:[S(X)]);else throw X}}function f$($){let B=[],X=!1,Z={};for(let[W,J]of Object.entries($))try{let Q=J.get();if(Q===z)X=!0;else Z[W]=Q}catch(Q){B.push(S(Q))}if(X)return{ok:!1,pending:!0};if(B.length>0)return{ok:!1,errors:B};return{ok:!0,values:Z}}var P$="State",b=($)=>{let B=new Set,X=$,Z={[Symbol.toStringTag]:P$,get:()=>{return m(B),X},set:(W)=>{if(W==null)throw new p("state");if(k(X,W))return;if(X=W,P(B),z===X)B.clear()},update:(W)=>{Z.set(W(X))}};return Z},O=($)=>v($,P$);var A$="Store",T$="store-add",d$="store-change",p$="store-remove",r$="store-sort",r=($)=>{let B=new Set,X=new EventTarget,Z=new Map,W=new Map,J=Array.isArray($),Q=b(0),x=()=>{let Y={};for(let[K,A]of Z)Y[K]=A.get();return Y},H=(Y,K)=>X.dispatchEvent(new CustomEvent(Y,{detail:K})),C=()=>Array.from(Z.keys()).map((Y)=>Number(Y)).filter((Y)=>Number.isInteger(Y)).sort((Y,K)=>Y-K),L=(Y,K)=>{if(K==null)throw new p(`store for key "${Y}"`);if(K===z)return!0;if(s(K)||I(K)||g(K))throw new $$(`store for key "${Y}"`,Y$(K));return!0},F=(Y,K,A=!1)=>{if(!L(Y,K))return!1;let q=O(K)||f(K)?K:_(K)?r(K):Array.isArray(K)?r(K):b(K);Z.set(Y,q);let U=E(()=>{let D=q.get();if(D!=null)H(d$,{[Y]:D})});if(W.set(Y,U),A)Q.set(Z.size),P(B),H(T$,{[Y]:K});return!0},G=(Y,K=!1)=>{let A=Z.delete(Y);if(A){let q=W.get(Y);if(q)q();W.delete(Y)}if(K)Q.set(Z.size),P(B),H(p$,{[Y]:z});return A},M=(Y,K,A)=>{let q=H$(Y,K);return l(()=>{if(Object.keys(q.add).length){for(let U in q.add){let D=q.add[U]??z;F(U,D)}if(A)setTimeout(()=>{H(T$,q.add)},0);else H(T$,q.add)}if(Object.keys(q.change).length){for(let U in q.change){let D=q.change[U];if(!L(U,D))continue;let W$=Z.get(U);if(t(W$))W$.set(D);else throw new Z$(U,Y$(D))}H(d$,q.change)}if(Object.keys(q.remove).length){for(let U in q.remove)G(U);H(p$,q.remove)}Q.set(Z.size)}),q.changed};M({},$,!0);let R={add:J?(Y)=>{let K=Z.size,A=String(K);F(A,Y,!0)}:(Y,K)=>{if(!Z.has(Y))F(Y,K,!0);else throw new B$(Y,Y$(K))},get:()=>{return m(B),x$(x())},remove:J?(Y)=>{let K=x$(x()),A=Z.size;if(!Array.isArray(K)||Y<=-A||Y>=A)throw new X$(Y);let q=[...K];if(q.splice(Y,1),M(K,q))P(B)}:(Y)=>{if(Z.has(Y))G(Y,!0)},set:(Y)=>{if(M(x(),Y)){if(P(B),z===Y)B.clear()}},update:(Y)=>{let K=x(),A=Y(x$(K));if(M(K,A)){if(P(B),z===A)B.clear()}},sort:(Y)=>{let K=Array.from(Z.entries()).map(([U,D])=>[U,D.get()]).sort(Y?(U,D)=>Y(U[1],D[1]):(U,D)=>String(U[1]).localeCompare(String(D[1]))),A=K.map(([U])=>String(U)),q=new Map;K.forEach(([U],D)=>{let W$=String(U),n$=J?String(D):String(U),b$=Z.get(W$);if(b$)q.set(n$,b$)}),Z.clear(),q.forEach((U,D)=>Z.set(D,U)),P(B),H(r$,A)},addEventListener:X.addEventListener.bind(X),removeEventListener:X.removeEventListener.bind(X),dispatchEvent:X.dispatchEvent.bind(X),size:Q};return new Proxy({},{get(Y,K){if(K===Symbol.toStringTag)return A$;if(K===Symbol.isConcatSpreadable)return J;if(K===Symbol.iterator)return J?function*(){let A=C();for(let q of A){let U=Z.get(String(q));if(U)yield U}}:function*(){for(let[A,q]of Z)yield[A,q]};if(s(K))return;if(K in R)return R[K];if(K==="length"&&J)return m(B),Q.get();return Z.get(K)},has(Y,K){let A=String(K);return A&&Z.has(A)||Object.keys(R).includes(A)||K===Symbol.toStringTag||K===Symbol.iterator||K===Symbol.isConcatSpreadable||K==="length"&&J},ownKeys(){return J?C().map((Y)=>String(Y)).concat(["length"]):Array.from(Z.keys()).map((Y)=>String(Y))},getOwnPropertyDescriptor(Y,K){let A=(U)=>({enumerable:!1,configurable:!0,writable:!1,value:U});if(K==="length"&&J)return{enumerable:!0,configurable:!0,writable:!1,value:Q.get()};if(K===Symbol.isConcatSpreadable)return A(J);if(K===Symbol.toStringTag)return A(A$);if(s(K))return;if(Object.keys(R).includes(K))return A(R[K]);let q=Z.get(K);return q?{enumerable:!0,configurable:!0,writable:!0,value:q}:void 0}})},f=($)=>v($,A$);var y=($)=>O($)||g($)||f($),t=($)=>O($)||f($);function v$($){if(y($))return $;if(u($))return h($);if(Array.isArray($)||_($))return r($);return b($)}var z$=!1,t$="debug";var a$="warn",n="error",e$=new Set(["constructor","prototype"]),$B=new Set(["id","class","className","title","role","style","dataset","lang","dir","hidden","children","innerHTML","outerHTML","textContent","innerText"]),BB=($)=>$?`#${$}`:"",XB=($)=>$?.length?`.${Array.from($).join(".")}`:"";var U$=($)=>$.localName.includes("-"),j=($)=>$?`<${$.localName}${BB($.id)}${XB($.classList)}>`:"<unknown>",I$=($)=>T($)?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($);var d=($,B,X=t$)=>{if(z$||[n,a$].includes(X))console[X](B,$);return $},c$=($)=>{if(e$.has($))return`Property name "${$}" is a reserved word`;if($B.has($))return`Property name "${$}" conflicts with inherited HTMLElement property`;return null};class O$ extends TypeError{constructor($){super(`Invalid component name "${$}". Custom element names must contain a hyphen, start with a lowercase letter, and contain only lowercase letters, numbers, and hyphens.`);this.name="InvalidComponentNameError"}}class N$ extends TypeError{constructor($,B,X){super(`Invalid property name "${B}" for component <${$}>. ${X}`);this.name="InvalidPropertyNameError"}}class M$ extends TypeError{constructor($,B){super(`Invalid effects in component ${j($)}. Effects must be a record of effects for UI elements or the component, or a Promise that resolves to effects.`);if(this.name="InvalidEffectsError",B)this.cause=B}}class j$ extends Error{constructor($,B,X){super(`Missing required element <${B}> in component ${j($)}. ${X}`);this.name="MissingElementError"}}class S$ extends Error{constructor($,B){super(`Timeout waiting for: [${B.join(", ")}] in component ${j($)}.`);this.name="DependencyTimeoutError"}}class y$ extends TypeError{constructor($,B,X){super(`Expected reactives passed from ${j($)} to ${j(B)} to be a record of signals, reactive property names or functions. Got ${I$(X)}.`);this.name="InvalidReactivesError"}}class w$ extends TypeError{constructor($,B){super(`Target ${j($)} is not a custom element in ${B}.`);this.name="InvalidCustomElementError"}}var a=Symbol("RESET"),ZB=($,B="")=>{return{a:"attribute ",c:"class ",d:"dataset ",h:"inner HTML",m:"method call ",p:"property ",s:"style property ",t:"text content"}[$]+B},F$=($,B,X)=>{try{if(X instanceof Promise)throw X;let Z=[];for(let W of X){let J=W($,B);if(J)Z.push(J)}return()=>{Z.forEach((W)=>W()),Z.length=0}}catch(Z){if(Z instanceof Promise)Z.then(()=>F$($,B,X));else throw new M$($,Z instanceof Error?Z:Error(String(Z)))}},k$=($,B)=>{if(!_(B))throw new M$($.host);let X=[],Z=Object.keys(B);for(let W of Z){let J=W;if(!B[J])continue;let Q=Array.isArray(B[J])?B[J]:[B[J]];if(Array.isArray($[J]))for(let x of $[J]){let H=F$($.host,x,Q);if(H)X.push(H)}else if($[J]){let x=F$($.host,$[J],Q);if(x)X.push(x)}}return()=>{X.forEach((W)=>W()),X.length=0}},L$=($,B,X,Z)=>{try{return T($)?B[$]:y($)?$.get():I($)?$(X):a}catch(W){if(Z)d(W,`Failed to resolve value of ${I$($)}${Z?` for ${Z}`:""} in ${j(X)}${B!==X?` in ${j(B)}`:""}`,n);return a}},V=($,B)=>(X,Z)=>{let{op:W,name:J="",read:Q,update:x}=B,H=ZB(W,J),C=(G)=>()=>{if(z$&&X.debug)d(Z,`${G} ${H} of ${j(Z)} in ${j(X)}`);B.resolve?.(Z)},L=(G)=>(M)=>{d(M,`Failed to ${G} ${H} of ${j(Z)} in ${j(X)}`,n),B.reject?.(M)},F=Q(Z);return E(()=>{let G=L$($,X,Z,H),M=G===a?F:G===z?B.delete?null:F:G;if(B.delete&&M===null)try{B.delete(Z),C("delete")()}catch(R){L("delete")(R)}else if(M!=null){let R=Q(Z);if(Object.is(M,R))return;try{x(Z,M),C("update")()}catch(Y){L("update")(Y)}}})},JB=($,B)=>(X,Z)=>{let W=(Q)=>()=>{if(z$&&X.debug)d(Z,`${Q} element in ${j(Z)} in ${j(X)}`);if(I(B?.resolve))B.resolve(Z);else{let x=y($)?$:void 0;if(O(x))x.set(0)}},J=(Q)=>(x)=>{d(x,`Failed to ${Q} element in ${j(Z)} in ${j(X)}`,n),B?.reject?.(x)};return E(()=>{let Q=L$($,X,Z,"insertion or deletion"),x=Q===a?0:Q;if(x>0){if(!B)throw TypeError("No inserter provided");try{for(let H=0;H<x;H++){let C=B.create(Z);if(!C)continue;Z.insertAdjacentElement(B.position??"beforeend",C)}W("insert")()}catch(H){J("insert")(H)}}else if(x<0)try{if(B&&(B.position==="afterbegin"||B.position==="beforeend"))for(let H=0;H>x;H--)if(B.position==="afterbegin")Z.firstElementChild?.remove();else Z.lastElementChild?.remove();else Z.remove();W("remove")()}catch(H){J("remove")(H)}})};var e=($)=>I($)&&$.length>=2,N=($,B)=>I(B)?B($):B,QB=($,B)=>(X)=>{let Z=$(X);return T(Z)&&e(B)?B(X,Z):Z??N(X,B)};var o$=($)=>U$($)&&$.matches(":not(:defined)");var u$=($)=>{let B=$.shadowRoot??$,X=new Set;function Z(J,Q){let x=B.querySelector(J);if(Q!=null&&!x)throw new j$($,J,Q);if(x&&o$(x))X.add(x.localName);return x??void 0}function W(J,Q){let x=B.querySelectorAll(J);if(Q!=null&&!x.length)throw new j$($,J,Q);if(x.length)x.forEach((H)=>{if(o$(H))X.add(H.localName)});return Array.from(x)}return[{first:Z,all:W},()=>Array.from(X)]};var KB=50;function WB($,B={},X=()=>({}),Z=()=>({})){if(!$.includes("-")||!$.match(/^[a-z][a-z0-9-]*$/))throw new O$($);for(let J of Object.keys(B)){let Q=c$(J);if(Q)throw new N$($,J,Q)}class W extends HTMLElement{debug;#$={};#B={};#X;static observedAttributes=Object.entries(B)?.filter(([,J])=>e(J)).map(([J])=>J)??[];connectedCallback(){let[J,Q]=u$(this);this.#$={...X(J),host:this},Object.freeze(this.#$);let x=(F,G)=>{let M=I(G)?e(G)?G(this.#$,null):G(this.#$):G;if(M!=null)this.#Z(F,M)};for(let[F,G]of Object.entries(B)){if(G==null||F in this)continue;x(F,G)}let H=Z(this.#$),C=Q(),L=()=>{this.#X=k$(this.#$,H)};if(C.length)Promise.race([Promise.all(C.map((F)=>customElements.whenDefined(F))),new Promise((F,G)=>{setTimeout(()=>{G(new S$(this,C.filter((M)=>!customElements.get(M))))},KB)})]).then(L).catch(()=>{L()});else L()}disconnectedCallback(){if(I(this.#X))this.#X()}attributeChangedCallback(J,Q,x){if(x===Q||g(this.#B[J]))return;let H=B[J];if(!e(H))return;let C=H(this.#$,x,Q);if(J in this)this[J]=C;else this.#Z(J,C)}#Z(J,Q){let x=y(Q)?Q:u(Q)?h(Q):b(Q),H=this.#B[J],C=t(x);if(this.#B[J]=x,Object.defineProperty(this,J,{get:x.get,set:C?x.set:void 0,enumerable:!0,configurable:C}),H&&O(H)||f(H))H.set(z)}}return customElements.define($,W),customElements.get($)}var xB=($)=>{if(/^(mailto|tel):/i.test($))return!0;if($.includes("://"))try{let B=new URL($,window.location.origin);return["http:","https:","ftp:"].includes(B.protocol)}catch{return!1}return!0},YB=($,B,X)=>{if(/^on/i.test(B))throw Error(`Unsafe attribute: ${B}`);if(X=String(X).trim(),!xB(X))throw Error(`Unsafe URL for ${B}: ${X}`);$.setAttribute(B,X)},HB=($,B=$)=>V(B,{op:"a",name:$,read:(X)=>X.getAttribute($),update:(X,Z)=>{YB(X,$,Z)},delete:(X)=>{X.removeAttribute($)}}),GB=($,B=$)=>V(B,{op:"a",name:$,read:(X)=>X.hasAttribute($),update:(X,Z)=>{X.toggleAttribute($,Z)}});var CB=($,B=$)=>V(B,{op:"c",name:$,read:(X)=>X.classList.contains($),update:(X,Z)=>{X.classList.toggle($,Z)}});var qB=($,B,X=!1)=>(Z,W)=>{let J=(Q)=>{let x=B({host:Z,target:W,event:Q});if(!_(x))return;l(()=>{for(let[H,C]of Object.entries(x))try{Z[H]=C}catch(L){d(L,`Reactive property "${H}" on ${j(Z)} from event ${$} on ${j(W)} could not be set, because it is read-only.`,n)}})};return W.addEventListener($,J,X),()=>W.removeEventListener($,J)},AB=($,B)=>(X,Z)=>E(()=>{let W=L$(B,X,Z,`custom event "${$}" detail`);if(W===a||W===z)return;Z.dispatchEvent(new CustomEvent($,{detail:W,bubbles:!0}))});var zB=($,B={})=>V($,{op:"h",read:(X)=>(X.shadowRoot||!B.shadowRootMode?X:null)?.innerHTML??"",update:(X,Z)=>{let{shadowRootMode:W,allowScripts:J}=B;if(!Z){if(X.shadowRoot)X.shadowRoot.innerHTML="<slot></slot>";return""}if(W&&!X.shadowRoot)X.attachShadow({mode:W});let Q=X.shadowRoot||X;if(Q.innerHTML=Z,!J)return"";return Q.querySelectorAll("script").forEach((x)=>{let H=document.createElement("script");H.appendChild(document.createTextNode(x.textContent??"")),Q.appendChild(H),x.remove()})," with scripts"}});var UB=($)=>(B,X)=>{if(!U$(X))throw new w$(X,`pass from ${j(B)}`);let Z=I($)?$(X):$;if(!_(Z))throw new y$(B,X,Z);let W={},J=(Q)=>{if(y(Q))return Q.get;let x=T(Q)&&Q in B?()=>B[Q]:u(Q)?Q:void 0;return x?h(x).get:void 0};for(let[Q,x]of Object.entries(Z)){if(x==null)continue;let H=Object.getOwnPropertyDescriptor(X,Q);if(!(Q in X)||!H?.configurable)continue;let C=I(x)&&x.length===1?x(X):x,L=Array.isArray(C)&&C.length===2,F=J(L?C[0]:C),G=L&&I(C[1])?C[1]:void 0;if(!F)continue;W[Q]=H,Object.defineProperty(X,Q,{configurable:!0,enumerable:!0,get:F,set:G}),H.set?.call(X,z)}return()=>{Object.defineProperties(X,W)}};var IB=($,B=$)=>V(B,{op:"p",name:$,read:(X)=>($ in X)?X[$]:z,update:(X,Z)=>{X[$]=Z}}),MB=($)=>V($,{op:"p",name:"hidden",read:(B)=>!B.hidden,update:(B,X)=>{B.hidden=!X}});var jB=($,B=$)=>V(B,{op:"s",name:$,read:(X)=>X.style.getPropertyValue($),update:(X,Z)=>{X.style.setProperty($,Z)},delete:(X)=>{X.style.removeProperty($)}});var FB=($)=>V($,{op:"t",read:(B)=>B.textContent,update:(B,X)=>{Array.from(B.childNodes).filter((Z)=>Z.nodeType!==Node.COMMENT_NODE).forEach((Z)=>Z.remove()),B.append(document.createTextNode(X))}});var LB=()=>($,B)=>B!=null&&B!=="false";var DB=($)=>(B,X)=>{if((X??$)==null)throw TypeError("asJSON: Value and fallback are both null or undefined");if(X==null)return N(B,$);if(X==="")throw TypeError("Empty string is not valid JSON");let Z;try{Z=JSON.parse(X)}catch(W){throw SyntaxError(`Failed to parse JSON: ${String(W)}`,{cause:W})}return Z??N(B,$)};var E$=($,B)=>{if(B==null)return;let X=$(B);return Number.isFinite(X)?X:void 0},_B=($=0)=>(B,X)=>{if(X==null)return N(B,$);let Z=X.trim();if(Z.toLowerCase().startsWith("0x"))return E$((J)=>parseInt(J,16),Z)??N(B,$);let W=E$(parseFloat,X);return W!=null?Math.trunc(W):N(B,$)},VB=($=0)=>(B,X)=>E$(parseFloat,X)??N(B,$);var RB=($="")=>(B,X)=>X??N(B,$),PB=($)=>(B,X)=>{if(X==null)return $[0];let Z=X.toLowerCase();return $.find((J)=>J.toLowerCase()===Z)?X:$[0]};export{V as updateElement,CB as toggleClass,GB as toggleAttribute,v$ as toSignal,S as toError,r as store,b as state,MB as show,FB as setText,jB as setStyle,IB as setProperty,HB as setAttribute,F$ as runElementEffects,k$ as runEffects,f$ as resolve,QB as read,UB as pass,qB as on,g$ as match,s as isSymbol,T as isString,f as isStore,O as isState,y as isSignal,J$ as isRecordOrArray,_ as isRecord,e as isParser,D$ as isNumber,t as isMutableSignal,I as isFunction,k as isEqual,g as isComputed,i as isAsyncFunction,c as isAbortError,JB as insertOrRemoveElement,h$ as enqueue,AB as emit,E as effect,H$ as diff,zB as dangerouslySetInnerHTML,h as computed,WB as component,l as batch,RB as asString,VB as asNumber,DB as asJSON,_B as asInteger,PB as asEnum,LB as asBoolean,z as UNSET,Z$ as StoreKeyReadonlyError,X$ as StoreKeyRangeError,B$ as StoreKeyExistsError,p as NullishSignalValueError,$$ as InvalidSignalValueError,w as CircularDependencyError};

//# debugId=A4640025D6E8934B64756E2164756E21
