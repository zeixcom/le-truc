class k extends Error{constructor($){super(`Circular dependency detected in ${$}`);this.name="CircularDependencyError"}}class Q$ extends TypeError{constructor($,B){super(`Invalid signal value ${B} in ${$}`);this.name="InvalidSignalValueError"}}class c extends TypeError{constructor($){super(`Nullish signal values are not allowed in ${$}`);this.name="NullishSignalValueError"}}class X$ extends Error{constructor($,B){super(`Could not add store key "${$}" with value ${B} because it already exists`);this.name="StoreKeyExistsError"}}class Z$ extends RangeError{constructor($){super(`Could not remove store index ${String($)} because it is out of range`);this.name="StoreKeyRangeError"}}class J$ extends Error{constructor($,B){super(`Could not set store key "${$}" to ${B} because it is readonly`);this.name="StoreKeyReadonlyError"}}var q=Symbol(),N=($)=>typeof $==="string",L$=($)=>typeof $==="number",l=($)=>typeof $==="symbol",F=($)=>typeof $==="function",r=($)=>F($)&&$.constructor.name==="AsyncFunction",s$=($)=>!!$&&typeof $==="object",u=($,B)=>Object.prototype.toString.call($)===`[object ${B}]`,P=($)=>u($,"Object"),K$=($)=>P($)||Array.isArray($),l$=($)=>{if(!$.length)return null;let B=$.map((Q)=>N(Q)?parseInt(Q,10):L$(Q)?Q:NaN);return B.every((Q)=>Number.isFinite(Q)&&Q>=0)?B.sort((Q,X)=>Q-X):null};var o=($)=>$ instanceof DOMException&&$.name==="AbortError",S=($)=>$ instanceof Error?$:Error(String($));var G$=($)=>{let B=l$(Object.keys($));if(B===null)return $;let Q=[];for(let X of B)Q.push($[String(X)]);return Q},C$=($)=>N($)?`"${$}"`:s$($)?JSON.stringify($):String($);var b=($,B,Q)=>{if(Object.is($,B))return!0;if(typeof $!==typeof B)return!1;if(typeof $!=="object"||$===null||B===null)return!1;if(!Q)Q=new WeakSet;if(Q.has($)||Q.has(B))throw new k("isEqual");Q.add($),Q.add(B);try{if(Array.isArray($)&&Array.isArray(B)){if($.length!==B.length)return!1;for(let X=0;X<$.length;X++)if(!b($[X],B[X],Q))return!1;return!0}if(Array.isArray($)!==Array.isArray(B))return!1;if(P($)&&P(B)){let X=Object.keys($),Z=Object.keys(B);if(X.length!==Z.length)return!1;for(let J of X){if(!(J in B))return!1;if(!b($[J],B[J],Q))return!1}return!0}return!1}finally{Q.delete($),Q.delete(B)}},U$=($,B)=>{let Q=K$($),X=K$(B);if(!Q||!X){let G=!Object.is($,B);return{changed:G,add:G&&X?B:{},change:{},remove:G&&Q?$:{}}}let Z=new WeakSet,J={},K={},W={},x=Object.keys($),C=Object.keys(B),L=new Set([...x,...C]);for(let G of L){let M=G in $,V=G in B;if(!M&&V){J[G]=B[G];continue}else if(M&&!V){W[G]=q;continue}let H=$[G],Y=B[G];if(!b(H,Y,Z))K[G]=Y}return{changed:Object.keys(J).length>0||Object.keys(K).length>0||Object.keys(W).length>0,add:J,change:K,remove:W}};var n,z$=new Set,D$=0,P$=new Map,q$,g$=()=>{q$=void 0;let $=Array.from(P$.values());P$.clear();for(let B of $)B()},r$=()=>{if(q$)cancelAnimationFrame(q$);q$=requestAnimationFrame(g$)};queueMicrotask(g$);var W$=($)=>{let B=new Set,Q=$;return Q.off=(X)=>{B.add(X)},Q.cleanup=()=>{for(let X of B)X();B.clear()},Q},g=($)=>{if(n&&!$.has(n)){let B=n;$.add(B),n.off(()=>{$.delete(B)})}},T=($)=>{for(let B of $)if(D$)z$.add(B);else B()},A$=()=>{while(z$.size){let $=Array.from(z$);z$.clear();for(let B of $)B()}},t=($)=>{D$++;try{$()}finally{A$(),D$--}},Y$=($,B)=>{let Q=n;n=B;try{$()}finally{n=Q}},h$=($,B)=>new Promise((Q,X)=>{P$.set(B||Symbol(),()=>{try{Q($())}catch(Z){X(Z)}}),r$()});var R$="Computed",h=($)=>{let B=new Set,Q=q,X,Z,J=!0,K=!1,W=!1,x=(H)=>{if(!b(H,Q))Q=H,K=!0;X=void 0,J=!1},C=()=>{K=q!==Q,Q=q,X=void 0},L=(H)=>{let Y=S(H);K=!X||Y.name!==X.name||Y.message!==X.message,Q=q,X=Y},j=(H)=>(Y)=>{if(W=!1,Z=void 0,H(Y),K)T(B)},G=W$(()=>{if(J=!0,Z?.abort(),B.size)T(B);else G.cleanup()});G.off(()=>{Z?.abort()});let M=()=>Y$(()=>{if(W)throw new k("computed");if(K=!1,r($)){if(Z)return Q;Z=new AbortController,Z.signal.addEventListener("abort",()=>{W=!1,Z=void 0,M()},{once:!0})}let H;W=!0;try{H=Z?$(Z.signal):$()}catch(Y){if(o(Y))C();else L(Y);W=!1;return}if(H instanceof Promise)H.then(j(x),j(L));else if(H==null||q===H)C();else x(H);W=!1},G);return{[Symbol.toStringTag]:R$,get:()=>{if(g(B),A$(),J)M();if(X)throw X;return Q}}},d=($)=>u($,R$),i=($)=>F($)&&$.length<2;var E=($)=>{let B=r($),Q=!1,X,Z=W$(()=>Y$(()=>{if(Q)throw new k("effect");Q=!0,X?.abort(),X=void 0;let J;try{if(B){X=new AbortController;let K=X;$(X.signal).then((W)=>{if(F(W)&&X===K)Z.off(W)}).catch((W)=>{if(!o(W))console.error("Async effect error:",W)})}else if(J=$(),F(J))Z.off(J)}catch(K){if(!o(K))console.error("Effect callback error:",K)}Q=!1},Z));return Z(),()=>{X?.abort(),Z.cleanup()}};function d$($,B){try{if($.pending)B.nil?.();else if($.errors)B.err?.($.errors);else if($.ok)B.ok($.values)}catch(Q){if(B.err&&(!$.errors||!$.errors.includes(S(Q))))B.err($.errors?[...$.errors,S(Q)]:[S(Q)]);else throw Q}}function p$($){let B=[],Q=!1,X={};for(let[Z,J]of Object.entries($))try{let K=J.get();if(K===q)Q=!0;else X[Z]=K}catch(K){B.push(S(K))}if(Q)return{ok:!1,pending:!0};if(B.length>0)return{ok:!1,errors:B};return{ok:!0,values:X}}var _$="State",f=($)=>{let B=new Set,Q=$,X={[Symbol.toStringTag]:_$,get:()=>{return g(B),Q},set:(Z)=>{if(Z==null)throw new c("state");if(b(Q,Z))return;if(Q=Z,T(B),q===Q)B.clear()},update:(Z)=>{X.set(Z(Q))}};return X},O=($)=>u($,_$);var I$="Store",V$="store-add",v$="store-change",c$="store-remove",t$="store-sort",a=($)=>{let B=new Set,Q=new EventTarget,X=new Map,Z=new Map,J=Array.isArray($),K=f(0),W=()=>{let H={};for(let[Y,z]of X)H[Y]=z.get();return H},x=(H,Y)=>Q.dispatchEvent(new CustomEvent(H,{detail:Y})),C=()=>Array.from(X.keys()).map((H)=>Number(H)).filter((H)=>Number.isInteger(H)).sort((H,Y)=>H-Y),L=(H,Y)=>{if(Y==null)throw new c(`store for key "${H}"`);if(Y===q)return!0;if(l(Y)||F(Y)||d(Y))throw new Q$(`store for key "${H}"`,C$(Y));return!0},j=(H,Y,z=!1)=>{if(!L(H,Y))return!1;let U=O(Y)||p(Y)?Y:P(Y)?a(Y):Array.isArray(Y)?a(Y):f(Y);X.set(H,U);let A=E(()=>{let D=U.get();if(D!=null)x(v$,{[H]:D})});if(Z.set(H,A),z)K.set(X.size),T(B),x(V$,{[H]:Y});return!0},G=(H,Y=!1)=>{let z=X.delete(H);if(z){let U=Z.get(H);if(U)U();Z.delete(H)}if(Y)K.set(X.size),T(B),x(c$,{[H]:q});return z},M=(H,Y,z)=>{let U=U$(H,Y);return t(()=>{if(Object.keys(U.add).length){for(let A in U.add){let D=U.add[A]??q;j(A,D)}if(z)setTimeout(()=>{x(V$,U.add)},0);else x(V$,U.add)}if(Object.keys(U.change).length){for(let A in U.change){let D=U.change[A];if(!L(A,D))continue;let x$=X.get(A);if(e(x$))x$.set(D);else throw new J$(A,C$(D))}x(v$,U.change)}if(Object.keys(U.remove).length){for(let A in U.remove)G(A);x(c$,U.remove)}K.set(X.size)}),U.changed};M({},$,!0);let V={add:J?(H)=>{let Y=X.size,z=String(Y);j(z,H,!0)}:(H,Y)=>{if(!X.has(H))j(H,Y,!0);else throw new X$(H,C$(Y))},get:()=>{return g(B),G$(W())},remove:J?(H)=>{let Y=G$(W()),z=X.size;if(!Array.isArray(Y)||H<=-z||H>=z)throw new Z$(H);let U=[...Y];if(U.splice(H,1),M(Y,U))T(B)}:(H)=>{if(X.has(H))G(H,!0)},set:(H)=>{if(M(W(),H)){if(T(B),q===H)B.clear()}},update:(H)=>{let Y=W(),z=H(G$(Y));if(M(Y,z)){if(T(B),q===z)B.clear()}},sort:(H)=>{let Y=Array.from(X.entries()).map(([A,D])=>[A,D.get()]).sort(H?(A,D)=>H(A[1],D[1]):(A,D)=>String(A[1]).localeCompare(String(D[1]))),z=Y.map(([A])=>String(A)),U=new Map;Y.forEach(([A],D)=>{let x$=String(A),i$=J?String(D):String(A),m$=X.get(x$);if(m$)U.set(i$,m$)}),X.clear(),U.forEach((A,D)=>X.set(D,A)),T(B),x(t$,z)},addEventListener:Q.addEventListener.bind(Q),removeEventListener:Q.removeEventListener.bind(Q),dispatchEvent:Q.dispatchEvent.bind(Q),size:K};return new Proxy({},{get(H,Y){if(Y===Symbol.toStringTag)return I$;if(Y===Symbol.isConcatSpreadable)return J;if(Y===Symbol.iterator)return J?function*(){let z=C();for(let U of z){let A=X.get(String(U));if(A)yield A}}:function*(){for(let[z,U]of X)yield[z,U]};if(l(Y))return;if(Y in V)return V[Y];if(Y==="length"&&J)return g(B),K.get();return X.get(Y)},has(H,Y){let z=String(Y);return z&&X.has(z)||Object.keys(V).includes(z)||Y===Symbol.toStringTag||Y===Symbol.iterator||Y===Symbol.isConcatSpreadable||Y==="length"&&J},ownKeys(){return J?C().map((H)=>String(H)).concat(["length"]):Array.from(X.keys()).map((H)=>String(H))},getOwnPropertyDescriptor(H,Y){let z=(A)=>({enumerable:!1,configurable:!0,writable:!1,value:A});if(Y==="length"&&J)return{enumerable:!0,configurable:!0,writable:!1,value:K.get()};if(Y===Symbol.isConcatSpreadable)return z(J);if(Y===Symbol.toStringTag)return z(I$);if(l(Y))return;if(Object.keys(V).includes(Y))return z(V[Y]);let U=X.get(Y);return U?{enumerable:!0,configurable:!0,writable:!0,value:U}:void 0}})},p=($)=>u($,I$);var w=($)=>O($)||d($)||p($),e=($)=>O($)||p($);function u$($){if(w($))return $;if(i($))return h($);if(Array.isArray($)||P($))return a($);return f($)}var y=!1,a$="debug";var T$="warn",s="error",e$=new Set(["constructor","prototype"]),$B=new Set(["id","class","className","title","role","style","dataset","lang","dir","hidden","children","innerHTML","outerHTML","textContent","innerText"]),BB=($)=>$?`#${$}`:"",QB=($)=>$?.length?`.${Array.from($).join(".")}`:"";var H$=($)=>$.localName.includes("-"),I=($)=>$?`<${$.localName}${BB($.id)}${QB($.classList)}>`:"<unknown>",v=($)=>N($)?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($),N$=($)=>{if($===null)return"null";if(typeof $!=="object")return typeof $;if(Array.isArray($))return"Array";if(Symbol.toStringTag in Object($))return $[Symbol.toStringTag];return $.constructor?.name||"Object"},_=($,B,Q=a$)=>{if(y||[s,T$].includes(Q))console[Q](B,$);return $},o$=($)=>{if(e$.has($))return`Property name "${$}" is a reserved word`;if($B.has($))return`Property name "${$}" conflicts with inherited HTMLElement property`;return null};class O$ extends TypeError{constructor($){super(`Invalid component name "${$}". Custom element names must contain a hyphen, start with a lowercase letter, and contain only lowercase letters, numbers, and hyphens.`);this.name="InvalidComponentNameError"}}class S$ extends TypeError{constructor($,B,Q){super(`Invalid property name "${B}" for component <${$}>. ${Q}`);this.name="InvalidPropertyNameError"}}class F$ extends TypeError{constructor($,B){super(`Invalid effects in component ${I($)}. Effects must be a record of effects for UI elements or the component, or a Promise that resolves to effects.`);if(this.name="InvalidEffectsError",B)this.cause=B}}class j$ extends Error{constructor($,B,Q){super(`Missing required element <${B}> in component ${I($)}. ${Q}`);this.name="MissingElementError"}}class w$ extends Error{constructor($,B){super(`Timeout waiting for: [${B.join(", ")}] in component ${I($)}.`);this.name="DependencyTimeoutError"}}class y$ extends TypeError{constructor($,B,Q){super(`Expected reactives passed from ${I($)} to ${I(B)} to be a record of signals, reactive property names or functions. Got ${v(Q)}.`);this.name="InvalidReactivesError"}}class k$ extends TypeError{constructor($,B){super(`Target ${I($)} is not a custom element in ${B}.`);this.name="InvalidCustomElementError"}}var $$=Symbol("RESET"),XB=($,B="")=>{return{a:"attribute ",c:"class ",d:"dataset ",h:"inner HTML",m:"method call ",p:"property ",s:"style property ",t:"text content"}[$]+B},b$=($,B,Q)=>{let X=B==="component"?[$]:Array.isArray($.ui[B])?$.ui[B]:[$.ui[B]];if(!X.length)return;try{if(Q instanceof Promise)throw Q;let Z=[];for(let J of Q)X.forEach((K)=>{let W=J($,K);if(W)Z.push(W)});return()=>{Z.forEach((J)=>J()),Z.length=0}}catch(Z){if(Z instanceof Promise)Z.then(()=>b$($,B,Q));else throw new F$($,Z instanceof Error?Z:Error(String(Z)))}},E$=($,B)=>{if(!P(B))throw new F$($);let Q=[],X=Object.keys(B);for(let Z of X){if(!B[Z])continue;let J=b$($,Z,Array.isArray(B[Z])?B[Z]:[B[Z]]);if(J)Q.push(J)}return()=>{Q.forEach((Z)=>Z()),Q.length=0}},M$=($,B,Q,X)=>{try{return N($)?B[$]:w($)?$.get():F($)?$(Q):$$}catch(Z){if(X)_(Z,`Failed to resolve value of ${v($)}${X?` for ${X}`:""} in ${I(Q)}${B!==Q?` in ${I(B)}`:""}`,s);return $$}},R=($,B)=>(Q,X)=>{let{op:Z,name:J="",read:K,update:W}=B,x=XB(Z,J),C=(G)=>()=>{if(y&&Q.debug)_(X,`${G} ${x} of ${I(X)} in ${I(Q)}`);B.resolve?.(X)},L=(G)=>(M)=>{_(M,`Failed to ${G} ${x} of ${I(X)} in ${I(Q)}`,s),B.reject?.(M)},j=K(X);return E(()=>{let G=M$($,Q,X,x),M=G===$$?j:G===q?B.delete?null:j:G;if(B.delete&&M===null)try{B.delete(X),C("delete")()}catch(V){L("delete")(V)}else if(M!=null){let V=K(X);if(Object.is(M,V))return;try{W(X,M),C("update")()}catch(H){L("update")(H)}}})},ZB=($,B)=>(Q,X)=>{let Z=(K)=>()=>{if(y&&Q.debug)_(X,`${K} element in ${I(X)} in ${I(Q)}`);if(F(B?.resolve))B.resolve(X);else{let W=w($)?$:void 0;if(O(W))W.set(0)}},J=(K)=>(W)=>{_(W,`Failed to ${K} element in ${I(X)} in ${I(Q)}`,s),B?.reject?.(W)};return E(()=>{let K=M$($,Q,X,"insertion or deletion"),W=K===$$?0:K;if(W>0){if(!B)throw TypeError("No inserter provided");try{for(let x=0;x<W;x++){let C=B.create(X);if(!C)continue;X.insertAdjacentElement(B.position??"beforeend",C)}Z("insert")()}catch(x){J("insert")(x)}}else if(W<0)try{if(B&&(B.position==="afterbegin"||B.position==="beforeend"))for(let x=0;x>W;x--)if(B.position==="afterbegin")X.firstElementChild?.remove();else X.lastElementChild?.remove();else X.remove();Z("remove")()}catch(x){J("remove")(x)}})};var f$=($,B)=>{if(B==null)return;let Q=$(B);return Number.isFinite(Q)?Q:void 0},B$=($)=>F($)&&$.length>=2,m=($,B)=>F(B)?B($):B,JB=()=>($,B)=>B!=null&&B!=="false",KB=($=0)=>(B,Q)=>{if(Q==null)return m(B,$);let X=Q.trim();if(X.toLowerCase().startsWith("0x"))return f$((J)=>parseInt(J,16),X)??m(B,$);let Z=f$(parseFloat,Q);return Z!=null?Math.trunc(Z):m(B,$)},WB=($=0)=>(B,Q)=>f$(parseFloat,Q)??m(B,$),YB=($="")=>(B,Q)=>Q??m(B,$),HB=($)=>(B,Q)=>{if(Q==null)return $[0];let X=Q.toLowerCase();return $.find((J)=>J.toLowerCase()===X)?Q:$[0]},xB=($)=>(B,Q)=>{if((Q??$)==null)throw TypeError("asJSON: Value and fallback are both null or undefined");if(Q==null)return m(B,$);if(Q==="")throw TypeError("Empty string is not valid JSON");let X;try{X=JSON.parse(Q)}catch(Z){throw SyntaxError(`Failed to parse JSON: ${String(Z)}`,{cause:Z})}return X??m(B,$)};var n$=($)=>{let B=$.shadowRoot??$,Q=new Set;function X(J,K){let W=B.querySelector(J);if(K!=null&&!W)throw new j$($,J,K);if(W&&H$(W)&&W.matches(":not(:defined)"))Q.add(W.localName);return W}function Z(J,K){let W=B.querySelectorAll(J);if(K!=null&&!W.length)throw new j$($,J,K);if(W.length)W.forEach((x)=>{if(H$(x)&&x.matches(":not(:defined)"))Q.add(x.localName)});return Array.from(W)}return[{first:X,all:Z},()=>Array.from(Q)]};var GB=50;function CB($,B=()=>({}),Q={},X=()=>({})){if(!$.includes("-")||!$.match(/^[a-z][a-z0-9-]*$/))throw new O$($);for(let J of Object.keys(Q)){let K=o$(J);if(K)throw new S$($,J,K)}class Z extends HTMLElement{debug;#$={};#B;static observedAttributes=Object.entries(Q)?.filter(([,J])=>B$(J)).map(([J])=>J)??[];ui={};connectedCallback(){if(y){if(this.debug=this.hasAttribute("debug"),this.debug)_(this,"Connected")}let[J,K]=n$(this);this.ui=B(J),Object.freeze(this.ui);let W=(j,G)=>{let M=F(G)?G(this,null):G;if(M!=null)this.#Q(j,M)};for(let[j,G]of Object.entries(Q)){if(G==null||j in this)continue;W(j,G)}let x=X(this),C=K(),L=()=>{this.#B=E$(this,x)};if(C.length)Promise.race([Promise.all(C.map((j)=>customElements.whenDefined(j))),new Promise((j,G)=>{setTimeout(()=>{G(new w$(this,C.filter((M)=>!customElements.get(M))))},GB)})]).then(L).catch((j)=>{if(y)_(j,`Error during setup of <${$}>. Trying to run effects anyway.`,T$);L()});else L()}disconnectedCallback(){if(F(this.#B))this.#B();if(y&&this.debug)_(this,"Disconnected")}attributeChangedCallback(J,K,W){if(W===K||d(this.#$[J]))return;let x=Q[J];if(!B$(x))return;let C=x(this,W,K);if(y&&this.debug)_(W,`Attribute "${String(J)}" of ${I(this)} changed from ${v(K)} to ${v(W)}, parsed as <${N$(C)}> ${v(C)}`);if(J in this)this[J]=C;else this.#Q(J,C)}#Q(J,K){let W=w(K)?K:i(K)?h(K):f(K),x=this.#$[J],C=e(W);if(this.#$[J]=W,Object.defineProperty(this,J,{get:W.get,set:C?W.set:void 0,enumerable:!0,configurable:C}),x&&O(x)||p(x))x.set(q);if(y&&this.debug)_(W,`Set ${N$(W)} "${String(J)}" in ${I(this)}`)}}return customElements.define($,Z),customElements.get($)}var UB=($)=>{if(/^(mailto|tel):/i.test($))return!0;if($.includes("://"))try{let B=new URL($,window.location.origin);return["http:","https:","ftp:"].includes(B.protocol)}catch{return!1}return!0},zB=($,B,Q)=>{if(/^on/i.test(B))throw Error(`Unsafe attribute: ${B}`);if(Q=String(Q).trim(),!UB(Q))throw Error(`Unsafe URL for ${B}: ${Q}`);$.setAttribute(B,Q)},qB=($,B=$)=>R(B,{op:"a",name:$,read:(Q)=>Q.getAttribute($),update:(Q,X)=>{zB(Q,$,X)},delete:(Q)=>{Q.removeAttribute($)}}),AB=($,B=$)=>R(B,{op:"a",name:$,read:(Q)=>Q.hasAttribute($),update:(Q,X)=>{Q.toggleAttribute($,X)}});var IB=($,B=$)=>R(B,{op:"c",name:$,read:(Q)=>Q.classList.contains($),update:(Q,X)=>{Q.classList.toggle($,X)}});var FB=($,B,Q=!1)=>(X,Z)=>{let J=(K)=>{let W=B({host:X,target:Z,event:K});if(!P(W))return;t(()=>{for(let[x,C]of Object.entries(W))try{X[x]=C}catch(L){_(L,`Reactive property "${x}" on ${I(X)} from event ${$} on ${I(Z)} could not be set, because it is read-only.`,s)}})};return Z.addEventListener($,J,Q),()=>Z.removeEventListener($,J)},jB=($,B)=>(Q,X)=>E(()=>{let Z=M$(B,Q,X,`custom event "${$}" detail`);if(Z===$$||Z===q)return;X.dispatchEvent(new CustomEvent($,{detail:Z,bubbles:!0}))});var MB=($,B={})=>R($,{op:"h",read:(Q)=>(Q.shadowRoot||!B.shadowRootMode?Q:null)?.innerHTML??"",update:(Q,X)=>{let{shadowRootMode:Z,allowScripts:J}=B;if(!X){if(Q.shadowRoot)Q.shadowRoot.innerHTML="<slot></slot>";return""}if(Z&&!Q.shadowRoot)Q.attachShadow({mode:Z});let K=Q.shadowRoot||Q;if(K.innerHTML=X,!J)return"";return K.querySelectorAll("script").forEach((W)=>{let x=document.createElement("script");x.appendChild(document.createTextNode(W.textContent??"")),K.appendChild(x),W.remove()})," with scripts"}});var LB=($)=>(B,Q)=>{if(!H$(Q))throw new k$(Q,`pass from ${I(B)}`);let X=F($)?$(Q):$;if(!P(X))throw new y$(B,Q,X);let Z={},J=(K)=>{if(w(K))return K.get;let W=N(K)&&K in B?()=>B[K]:i(K)?K:void 0;return W?h(W).get:void 0};for(let[K,W]of Object.entries(X)){if(W==null)continue;let x=Object.getOwnPropertyDescriptor(Q,K);if(!(K in Q)||!x?.configurable)continue;let C=F(W)&&W.length===1?W(Q):W,L=Array.isArray(C)&&C.length===2,j=J(L?C[0]:C),G=L&&F(C[1])?C[1]:void 0;if(!j)continue;Z[K]=x,Object.defineProperty(Q,K,{configurable:!0,enumerable:!0,get:j,set:G}),x.set?.call(Q,q)}return()=>{Object.defineProperties(Q,Z)}};var DB=($,B=$)=>R(B,{op:"p",name:$,read:(Q)=>($ in Q)?Q[$]:q,update:(Q,X)=>{Q[$]=X}}),PB=($)=>R($,{op:"p",name:"hidden",read:(B)=>!B.hidden,update:(B,Q)=>{B.hidden=!Q}});var RB=($,B=$)=>R(B,{op:"s",name:$,read:(Q)=>Q.style.getPropertyValue($),update:(Q,X)=>{Q.style.setProperty($,X)},delete:(Q)=>{Q.style.removeProperty($)}});var _B=($)=>R($,{op:"t",read:(B)=>B.textContent,update:(B,Q)=>{Array.from(B.childNodes).filter((X)=>X.nodeType!==Node.COMMENT_NODE).forEach((X)=>X.remove()),B.append(document.createTextNode(Q))}});var VB=($,B)=>(Q)=>{let X=void 0;for(let[Z,J]of Object.entries($)){if(!J)continue;let K=Array.isArray(Q.ui[Z])?Q.ui[Z][0]:Q.ui[Z];if(!K)continue;if(X=J(K),X!=null)break}return N(X)&&B$(B)?B(Q,X):X??m(Q,B)},TB=()=>($)=>$.textContent?.trim(),NB=($)=>(B)=>{let Q=B.getAttribute($);return Q?document.getElementById(Q)?.textContent?.trim():void 0},OB=($)=>(B)=>B[$],SB=($)=>(B)=>B.hasAttribute($),wB=($)=>(B)=>B.getAttribute($),yB=($)=>(B)=>B.classList.contains($),kB=($)=>(B)=>window.getComputedStyle(B).getPropertyValue($);export{R as updateElement,IB as toggleClass,AB as toggleAttribute,u$ as toSignal,S as toError,a as store,f as state,PB as show,_B as setText,RB as setStyle,DB as setProperty,qB as setAttribute,b$ as runElementEffects,E$ as runEffects,p$ as resolve,VB as read,LB as pass,FB as on,d$ as match,l as isSymbol,N as isString,p as isStore,O as isState,w as isSignal,K$ as isRecordOrArray,P as isRecord,B$ as isParser,L$ as isNumber,e as isMutableSignal,F as isFunction,b as isEqual,d as isComputed,r as isAsyncFunction,o as isAbortError,ZB as insertOrRemoveElement,yB as hasClass,SB as hasAttribute,TB as getText,kB as getStyle,OB as getProperty,NB as getIdrefText,wB as getAttribute,h$ as enqueue,jB as emit,E as effect,U$ as diff,MB as dangerouslySetInnerHTML,h as computed,CB as component,t as batch,YB as asString,WB as asNumber,xB as asJSON,KB as asInteger,HB as asEnum,JB as asBoolean,q as UNSET,J$ as StoreKeyReadonlyError,Z$ as StoreKeyRangeError,X$ as StoreKeyExistsError,c as NullishSignalValueError,Q$ as InvalidSignalValueError,k as CircularDependencyError};

//# debugId=61662ADF164B4B5C64756E2164756E21
