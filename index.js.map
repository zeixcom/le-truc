{
  "version": 3,
  "sources": ["node_modules/@zeix/cause-effect/src/util.ts", "node_modules/@zeix/cause-effect/src/errors.ts", "node_modules/@zeix/cause-effect/src/graph.ts", "node_modules/@zeix/cause-effect/src/nodes/state.ts", "node_modules/@zeix/cause-effect/src/nodes/list.ts", "node_modules/@zeix/cause-effect/src/nodes/memo.ts", "node_modules/@zeix/cause-effect/src/nodes/task.ts", "node_modules/@zeix/cause-effect/src/nodes/collection.ts", "node_modules/@zeix/cause-effect/src/nodes/effect.ts", "node_modules/@zeix/cause-effect/src/nodes/sensor.ts", "node_modules/@zeix/cause-effect/src/nodes/store.ts", "node_modules/@zeix/cause-effect/src/signal.ts", "node_modules/@zeix/cause-effect/src/nodes/slot.ts", "src/util.ts", "src/errors.ts", "src/effects.ts", "src/internal.ts", "src/parsers.ts", "src/ui.ts", "src/component.ts", "src/context.ts", "src/effects/attribute.ts", "src/effects/class.ts", "src/scheduler.ts", "src/effects/event.ts", "src/effects/html.ts", "src/effects/pass.ts", "src/effects/property.ts", "src/effects/style.ts", "src/effects/text.ts", "src/events.ts", "src/parsers/boolean.ts", "src/parsers/json.ts", "src/parsers/number.ts", "src/parsers/string.ts"],
  "sourcesContent": [
    "/* === Utility Functions === */\n\nfunction isFunction<T>(fn: unknown): fn is (...args: unknown[]) => T {\n\treturn typeof fn === 'function'\n}\n\nfunction isAsyncFunction<T>(\n\tfn: unknown,\n): fn is (...args: unknown[]) => Promise<T> {\n\treturn isFunction(fn) && fn.constructor.name === 'AsyncFunction'\n}\n\nfunction isSyncFunction<T extends unknown & { then?: undefined }>(\n\tfn: unknown,\n): fn is (...args: unknown[]) => T {\n\treturn isFunction(fn) && fn.constructor.name !== 'AsyncFunction'\n}\n\nfunction isObjectOfType<T>(value: unknown, type: string): value is T {\n\treturn Object.prototype.toString.call(value) === `[object ${type}]`\n}\n\nfunction isRecord<T extends Record<string, unknown>>(\n\tvalue: unknown,\n): value is T {\n\treturn isObjectOfType(value, 'Object')\n}\n\nfunction isUniformArray<T>(\n\tvalue: unknown,\n\tguard: (item: T) => item is T & {} = (item): item is T & {} => item != null,\n): value is T[] {\n\treturn Array.isArray(value) && value.every(guard)\n}\n\nfunction valueString(value: unknown): string {\n\treturn typeof value === 'string'\n\t\t? `\"${value}\"`\n\t\t: !!value && typeof value === 'object'\n\t\t\t? JSON.stringify(value)\n\t\t\t: String(value)\n}\n\n/* === Exports === */\n\nexport {\n\tisFunction,\n\tisAsyncFunction,\n\tisSyncFunction,\n\tisObjectOfType,\n\tisRecord,\n\tisUniformArray,\n\tvalueString,\n}\n",
    "import { isFunction, valueString } from './util'\n\n/* === Types === */\n\n/**\n * A type guard function that validates whether an unknown value is of type T.\n * Used to ensure type safety when updating signals.\n *\n * @template T - The type to guard against\n * @param value - The value to check\n * @returns True if the value is of type T\n */\ntype Guard<T extends {}> = (value: unknown) => value is T\n\n/* === Error Classes === */\n\n/**\n * Error thrown on re-entrance on an already running function.\n */\nclass CircularDependencyError extends Error {\n\t/**\n\t * Constructs a new CircularDependencyError.\n\t *\n\t * @param where - The location where the error occurred.\n\t */\n\tconstructor(where: string) {\n\t\tsuper(`[${where}] Circular dependency detected`)\n\t\tthis.name = 'CircularDependencyError'\n\t}\n}\n\n/**\n * Error thrown when a signal value is null or undefined.\n */\nclass NullishSignalValueError extends TypeError {\n\t/**\n\t * Constructs a new NullishSignalValueError.\n\t *\n\t * @param where - The location where the error occurred.\n\t */\n\tconstructor(where: string) {\n\t\tsuper(`[${where}] Signal value cannot be null or undefined`)\n\t\tthis.name = 'NullishSignalValueError'\n\t}\n}\n\n/**\n * Error thrown when a signal is read before it has a value.\n */\nclass UnsetSignalValueError extends Error {\n\t/**\n\t * Constructs a new UnsetSignalValueError.\n\t *\n\t * @param where - The location where the error occurred.\n\t */\n\tconstructor(where: string) {\n\t\tsuper(`[${where}] Signal value is unset`)\n\t\tthis.name = 'UnsetSignalValueError'\n\t}\n}\n\n/**\n * Error thrown when a signal value is invalid.\n */\nclass InvalidSignalValueError extends TypeError {\n\t/**\n\t * Constructs a new InvalidSignalValueError.\n\t *\n\t * @param where - The location where the error occurred.\n\t * @param value - The invalid value.\n\t */\n\tconstructor(where: string, value: unknown) {\n\t\tsuper(`[${where}] Signal value ${valueString(value)} is invalid`)\n\t\tthis.name = 'InvalidSignalValueError'\n\t}\n}\n\n/**\n * Error thrown when a callback is invalid.\n */\nclass InvalidCallbackError extends TypeError {\n\t/**\n\t * Constructs a new InvalidCallbackError.\n\t *\n\t * @param where - The location where the error occurred.\n\t * @param value - The invalid value.\n\t */\n\tconstructor(where: string, value: unknown) {\n\t\tsuper(`[${where}] Callback ${valueString(value)} is invalid`)\n\t\tthis.name = 'InvalidCallbackError'\n\t}\n}\n\nclass ReadonlySignalError extends Error {\n\t/**\n\t * Constructs a new ReadonlySignalError.\n\t *\n\t * @param where - The location where the error occurred.\n\t */\n\tconstructor(where: string) {\n\t\tsuper(`[${where}] Signal is read-only`)\n\t\tthis.name = 'ReadonlySignalError'\n\t}\n}\n\n/**\n * Error thrown when an API requiring an owner is called without one.\n */\nclass RequiredOwnerError extends Error {\n\t/**\n\t * Constructs a new RequiredOwnerError.\n\t *\n\t * @param where - The location where the error occurred.\n\t */\n\tconstructor(where: string) {\n\t\tsuper(`[${where}] Active owner is required`)\n\t\tthis.name = 'RequiredOwnerError'\n\t}\n}\n\nclass DuplicateKeyError extends Error {\n\tconstructor(where: string, key: string, value?: unknown) {\n\t\tsuper(\n\t\t\t`[${where}] Could not add key \"${key}\"${\n\t\t\t\tvalue ? ` with value ${JSON.stringify(value)}` : ''\n\t\t\t} because it already exists`,\n\t\t)\n\t\tthis.name = 'DuplicateKeyError'\n\t}\n}\n\n/* === Validation Functions === */\n\nfunction validateSignalValue<T extends {}>(\n\twhere: string,\n\tvalue: unknown,\n\tguard?: Guard<T>,\n): asserts value is T {\n\tif (value == null) throw new NullishSignalValueError(where)\n\tif (guard && !guard(value)) throw new InvalidSignalValueError(where, value)\n}\n\nfunction validateReadValue<T extends {}>(\n\twhere: string,\n\tvalue: T | null | undefined,\n): asserts value is T {\n\tif (value == null) throw new UnsetSignalValueError(where)\n}\n\nfunction validateCallback(\n\twhere: string,\n\tvalue: unknown,\n): asserts value is (...args: unknown[]) => unknown\nfunction validateCallback<T>(\n\twhere: string,\n\tvalue: unknown,\n\tguard: (value: unknown) => value is T,\n): asserts value is T\nfunction validateCallback(\n\twhere: string,\n\tvalue: unknown,\n\tguard: (value: unknown) => boolean = isFunction,\n): void {\n\tif (!guard(value)) throw new InvalidCallbackError(where, value)\n}\n\nexport {\n\ttype Guard,\n\tCircularDependencyError,\n\tNullishSignalValueError,\n\tInvalidSignalValueError,\n\tUnsetSignalValueError,\n\tInvalidCallbackError,\n\tReadonlySignalError,\n\tRequiredOwnerError,\n\tDuplicateKeyError,\n\tvalidateSignalValue,\n\tvalidateReadValue,\n\tvalidateCallback,\n}\n",
    "import { CircularDependencyError, type Guard } from './errors'\n\n/* === Internal Types === */\n\ntype SourceFields<T extends {}> = {\n\tvalue: T\n\tsinks: Edge | null\n\tsinksTail: Edge | null\n\tstop?: Cleanup\n}\n\ntype OptionsFields<T extends {}> = {\n\tequals: (a: T, b: T) => boolean\n\tguard?: Guard<T>\n}\n\ntype SinkFields = {\n\tfn: unknown\n\tflags: number\n\tsources: Edge | null\n\tsourcesTail: Edge | null\n}\n\ntype OwnerFields = {\n\tcleanup: Cleanup | Cleanup[] | null\n}\n\ntype AsyncFields = {\n\tcontroller: AbortController | undefined\n\terror: Error | undefined\n}\n\ntype StateNode<T extends {}> = SourceFields<T> & OptionsFields<T>\n\ntype MemoNode<T extends {}> = SourceFields<T> &\n\tOptionsFields<T> &\n\tSinkFields & {\n\t\tfn: MemoCallback<T>\n\t\terror: Error | undefined\n\t}\n\ntype TaskNode<T extends {}> = SourceFields<T> &\n\tOptionsFields<T> &\n\tSinkFields &\n\tAsyncFields & {\n\t\tfn: (prev: T, abort: AbortSignal) => Promise<T>\n\t}\n\ntype EffectNode = SinkFields &\n\tOwnerFields & {\n\t\tfn: EffectCallback\n\t}\n\ntype Scope = OwnerFields\n\ntype SourceNode = SourceFields<unknown & {}>\ntype SinkNode = MemoNode<unknown & {}> | TaskNode<unknown & {}> | EffectNode\ntype OwnerNode = EffectNode | Scope\n\ntype Edge = {\n\tsource: SourceNode\n\tsink: SinkNode\n\tnextSource: Edge | null\n\tprevSink: Edge | null\n\tnextSink: Edge | null\n}\n\n/* === Public API Types === */\n\ntype Signal<T extends {}> = {\n\tget(): T\n}\n\n/**\n * A cleanup function that can be called to dispose of resources.\n */\ntype Cleanup = () => void\n\n// biome-ignore lint/suspicious/noConfusingVoidType: optional Cleanup return type\ntype MaybeCleanup = Cleanup | undefined | void\n\n/**\n * Options for configuring signal behavior.\n *\n * @template T - The type of value in the signal\n */\ntype SignalOptions<T extends {}> = {\n\t/**\n\t * Optional type guard to validate values.\n\t * If provided, will throw an error if an invalid value is set.\n\t */\n\tguard?: Guard<T>\n\n\t/**\n\t * Optional custom equality function.\n\t * Used to determine if a new value is different from the old value.\n\t * Defaults to reference equality (===).\n\t */\n\tequals?: (a: T, b: T) => boolean\n}\n\ntype ComputedOptions<T extends {}> = SignalOptions<T> & {\n\t/**\n\t * Optional initial value.\n\t * Useful for reducer patterns so that calculations start with a value of correct type.\n\t */\n\tvalue?: T\n\n\t/**\n\t * Optional callback invoked when the signal is first watched by an effect.\n\t * Receives an `invalidate` function that marks the signal dirty and triggers re-evaluation.\n\t * Must return a cleanup function that is called when the signal is no longer watched.\n\t *\n\t * This enables lazy resource activation for computed signals that need to\n\t * react to external events (e.g. DOM mutations, timers) in addition to\n\t * tracked signal dependencies.\n\t */\n\twatched?: (invalidate: () => void) => Cleanup\n}\n\n/**\n * A callback function for memos that computes a value based on the previous value.\n *\n * @template T - The type of value computed\n * @param prev - The previous computed value\n * @returns The new computed value\n */\ntype MemoCallback<T extends {}> = (prev: T | undefined) => T\n\n/**\n * A callback function for tasks that asynchronously computes a value.\n *\n * @template T - The type of value computed\n * @param prev - The previous computed value\n * @param signal - An AbortSignal that will be triggered if the task is aborted\n * @returns A promise that resolves to the new computed value\n */\ntype TaskCallback<T extends {}> = (\n\tprev: T | undefined,\n\tsignal: AbortSignal,\n) => Promise<T>\n\n/**\n * A callback function for effects that can perform side effects.\n *\n * @returns An optional cleanup function that will be called before the effect re-runs or is disposed\n */\ntype EffectCallback = () => MaybeCleanup\n\n/* === Constants === */\n\nconst TYPE_STATE = 'State'\nconst TYPE_MEMO = 'Memo'\nconst TYPE_TASK = 'Task'\nconst TYPE_SENSOR = 'Sensor'\nconst TYPE_LIST = 'List'\nconst TYPE_COLLECTION = 'Collection'\nconst TYPE_STORE = 'Store'\nconst TYPE_SLOT = 'Slot'\n\nconst FLAG_CLEAN = 0\nconst FLAG_CHECK = 1 << 0\nconst FLAG_DIRTY = 1 << 1\nconst FLAG_RUNNING = 1 << 2\nconst FLAG_RELINK = 1 << 3\n\n/* === Module State === */\n\nlet activeSink: SinkNode | null = null\nlet activeOwner: OwnerNode | null = null\nconst queuedEffects: EffectNode[] = []\nlet batchDepth = 0\nlet flushing = false\n\n/* === Utility Functions === */\n\nconst DEFAULT_EQUALITY = <T extends {}>(a: T, b: T): boolean => a === b\n\n/**\n * Equality function that always returns false, causing propagation on every update.\n * Use with `createSensor` for observing mutable objects where the reference stays the same\n * but internal state changes (e.g., DOM elements observed via MutationObserver).\n *\n * @example\n * ```ts\n * const el = createSensor<HTMLElement>((set) => {\n *   const node = document.getElementById('box')!;\n *   set(node);\n *   const obs = new MutationObserver(() => set(node));\n *   obs.observe(node, { attributes: true });\n *   return () => obs.disconnect();\n * }, { value: node, equals: SKIP_EQUALITY });\n * ```\n */\nconst SKIP_EQUALITY = (_a?: unknown, _b?: unknown): boolean => false\n\n/* === Link Management === */\n\nfunction isValidEdge(checkEdge: Edge, node: SinkNode): boolean {\n\tconst sourcesTail = node.sourcesTail\n\tif (sourcesTail) {\n\t\tlet edge = node.sources\n\t\twhile (edge) {\n\t\t\tif (edge === checkEdge) return true\n\t\t\tif (edge === sourcesTail) break\n\t\t\tedge = edge.nextSource\n\t\t}\n\t}\n\treturn false\n}\n\nfunction link(source: SourceNode, sink: SinkNode): void {\n\tconst prevSource = sink.sourcesTail\n\tif (prevSource?.source === source) return\n\n\tlet nextSource: Edge | null = null\n\tconst isRecomputing = sink.flags & FLAG_RUNNING\n\tif (isRecomputing) {\n\t\tnextSource = prevSource ? prevSource.nextSource : sink.sources\n\t\tif (nextSource?.source === source) {\n\t\t\tsink.sourcesTail = nextSource\n\t\t\treturn\n\t\t}\n\t}\n\n\tconst prevSink = source.sinksTail\n\tif (\n\t\tprevSink?.sink === sink &&\n\t\t(!isRecomputing || isValidEdge(prevSink, sink))\n\t)\n\t\treturn\n\n\tconst newEdge = { source, sink, nextSource, prevSink, nextSink: null }\n\tsink.sourcesTail = source.sinksTail = newEdge\n\tif (prevSource) prevSource.nextSource = newEdge\n\telse sink.sources = newEdge\n\tif (prevSink) prevSink.nextSink = newEdge\n\telse source.sinks = newEdge\n}\n\nfunction unlink(edge: Edge): Edge | null {\n\tconst { source, nextSource, nextSink, prevSink } = edge\n\n\tif (nextSink) nextSink.prevSink = prevSink\n\telse source.sinksTail = prevSink\n\tif (prevSink) prevSink.nextSink = nextSink\n\telse source.sinks = nextSink\n\n\tif (!source.sinks) {\n\t\tif (source.stop) {\n\t\t\tsource.stop()\n\t\t\tsource.stop = undefined\n\t\t}\n\n\t\t// Cascade: if the source is also a sink (e.g. MemoNode, derived collection),\n\t\t// trim its own sources so upstream watched callbacks can clean up\n\t\tif ('sources' in source && source.sources) {\n\t\t\tconst sinkNode = source as SinkNode\n\t\t\tsinkNode.sourcesTail = null\n\t\t\ttrimSources(sinkNode)\n\t\t}\n\t}\n\n\treturn nextSource\n}\n\nfunction trimSources(node: SinkNode): void {\n\tconst tail = node.sourcesTail\n\tlet source = tail ? tail.nextSource : node.sources\n\twhile (source) source = unlink(source)\n\tif (tail) tail.nextSource = null\n\telse node.sources = null\n}\n\n/* === Propagation === */\n\nfunction propagate(node: SinkNode, newFlag = FLAG_DIRTY): void {\n\tconst flags = node.flags\n\n\tif ('sinks' in node) {\n\t\tif ((flags & (FLAG_DIRTY | FLAG_CHECK)) >= newFlag) return\n\n\t\tnode.flags = flags | newFlag\n\n\t\t// Abort in-flight work when sources change\n\t\tif ('controller' in node && node.controller) {\n\t\t\tnode.controller.abort()\n\t\t\tnode.controller = undefined\n\t\t}\n\n\t\t// Propagate Check to sinks\n\t\tfor (let e = node.sinks; e; e = e.nextSink)\n\t\t\tpropagate(e.sink, FLAG_CHECK)\n\t} else {\n\t\tif (flags & FLAG_DIRTY) return\n\n\t\t// Enqueue effect for later execution\n\t\tnode.flags = FLAG_DIRTY\n\t\tqueuedEffects.push(node as EffectNode)\n\t}\n}\n\n/* === State Management === */\n\nfunction setState<T extends {}>(node: StateNode<T>, next: T): void {\n\tif (node.equals(node.value, next)) return\n\n\tnode.value = next\n\tfor (let e = node.sinks; e; e = e.nextSink) propagate(e.sink)\n\tif (batchDepth === 0) flush()\n}\n\n/* === Cleanup Management === */\n\nfunction registerCleanup(owner: OwnerNode, fn: Cleanup): void {\n\tif (!owner.cleanup) owner.cleanup = fn\n\telse if (Array.isArray(owner.cleanup)) owner.cleanup.push(fn)\n\telse owner.cleanup = [owner.cleanup, fn]\n}\n\nfunction runCleanup(owner: OwnerNode): void {\n\tif (!owner.cleanup) return\n\n\tif (Array.isArray(owner.cleanup))\n\t\tfor (let i = 0; i < owner.cleanup.length; i++) owner.cleanup[i]()\n\telse owner.cleanup()\n\towner.cleanup = null\n}\n\n/* === Recomputation === */\n\nfunction recomputeMemo(node: MemoNode<unknown & {}>): void {\n\tconst prevWatcher = activeSink\n\tactiveSink = node\n\tnode.sourcesTail = null\n\tnode.flags = FLAG_RUNNING\n\n\tlet changed = false\n\ttry {\n\t\tconst next = node.fn(node.value)\n\t\tif (node.error || !node.equals(next, node.value)) {\n\t\t\tnode.value = next\n\t\t\tnode.error = undefined\n\t\t\tchanged = true\n\t\t}\n\t} catch (err: unknown) {\n\t\tchanged = true\n\t\tnode.error = err instanceof Error ? err : new Error(String(err))\n\t} finally {\n\t\tactiveSink = prevWatcher\n\t\ttrimSources(node)\n\t}\n\n\tif (changed) {\n\t\tfor (let e = node.sinks; e; e = e.nextSink)\n\t\t\tif (e.sink.flags & FLAG_CHECK) e.sink.flags |= FLAG_DIRTY\n\t}\n\n\tnode.flags = FLAG_CLEAN\n}\n\nfunction recomputeTask(node: TaskNode<unknown & {}>): void {\n\tnode.controller?.abort()\n\n\tconst controller = new AbortController()\n\tnode.controller = controller\n\tnode.error = undefined\n\n\tconst prevWatcher = activeSink\n\tactiveSink = node\n\tnode.sourcesTail = null\n\tnode.flags = FLAG_RUNNING\n\n\tlet promise: Promise<unknown & {}>\n\ttry {\n\t\tpromise = node.fn(node.value, controller.signal)\n\t} catch (err) {\n\t\tnode.controller = undefined\n\t\tnode.error = err instanceof Error ? err : new Error(String(err))\n\t\treturn\n\t} finally {\n\t\tactiveSink = prevWatcher\n\t\ttrimSources(node)\n\t}\n\n\tpromise.then(\n\t\tnext => {\n\t\t\tif (controller.signal.aborted) return\n\n\t\t\tnode.controller = undefined\n\t\t\tif (node.error || !node.equals(next, node.value)) {\n\t\t\t\tnode.value = next\n\t\t\t\tnode.error = undefined\n\t\t\t\tfor (let e = node.sinks; e; e = e.nextSink) propagate(e.sink)\n\t\t\t\tif (batchDepth === 0) flush()\n\t\t\t}\n\t\t},\n\t\t(err: unknown) => {\n\t\t\tif (controller.signal.aborted) return\n\n\t\t\tnode.controller = undefined\n\t\t\tconst error = err instanceof Error ? err : new Error(String(err))\n\t\t\tif (\n\t\t\t\t!node.error ||\n\t\t\t\terror.name !== node.error.name ||\n\t\t\t\terror.message !== node.error.message\n\t\t\t) {\n\t\t\t\t// We don't clear old value on errors\n\t\t\t\tnode.error = error\n\t\t\t\tfor (let e = node.sinks; e; e = e.nextSink) propagate(e.sink)\n\t\t\t\tif (batchDepth === 0) flush()\n\t\t\t}\n\t\t},\n\t)\n\n\tnode.flags = FLAG_CLEAN\n}\n\nfunction runEffect(node: EffectNode): void {\n\trunCleanup(node)\n\tconst prevContext = activeSink\n\tconst prevOwner = activeOwner\n\tactiveSink = activeOwner = node\n\tnode.sourcesTail = null\n\tnode.flags = FLAG_RUNNING\n\n\ttry {\n\t\tconst out = node.fn()\n\t\tif (typeof out === 'function') registerCleanup(node, out)\n\t} finally {\n\t\tactiveSink = prevContext\n\t\tactiveOwner = prevOwner\n\t\ttrimSources(node)\n\t}\n\n\tnode.flags = FLAG_CLEAN\n}\n\nfunction refresh(node: SinkNode): void {\n\tif (node.flags & FLAG_CHECK) {\n\t\tfor (let e = node.sources; e; e = e.nextSource) {\n\t\t\tif ('fn' in e.source) refresh(e.source as SinkNode)\n\t\t\tif (node.flags & FLAG_DIRTY) break\n\t\t}\n\t}\n\n\tif (node.flags & FLAG_RUNNING) {\n\t\tthrow new CircularDependencyError(\n\t\t\t'controller' in node\n\t\t\t\t? TYPE_TASK\n\t\t\t\t: 'value' in node\n\t\t\t\t\t? TYPE_MEMO\n\t\t\t\t\t: 'Effect',\n\t\t)\n\t}\n\n\tif (node.flags & FLAG_DIRTY) {\n\t\tif ('controller' in node) recomputeTask(node)\n\t\telse if ('value' in node) recomputeMemo(node)\n\t\telse runEffect(node)\n\t} else {\n\t\tnode.flags = FLAG_CLEAN\n\t}\n}\n\n/* === Batching === */\n\nfunction flush(): void {\n\tif (flushing) return\n\tflushing = true\n\ttry {\n\t\tfor (let i = 0; i < queuedEffects.length; i++) {\n\t\t\tconst effect = queuedEffects[i]\n\t\t\tif (effect.flags & FLAG_DIRTY) refresh(effect)\n\t\t}\n\t\tqueuedEffects.length = 0\n\t} finally {\n\t\tflushing = false\n\t}\n}\n\n/**\n * Batches multiple signal updates together.\n * Effects will not run until the batch completes.\n * Batches can be nested; effects run when the outermost batch completes.\n *\n * @param fn - The function to execute within the batch\n *\n * @example\n * ```ts\n * const count = createState(0);\n * const double = createMemo(() => count.get() * 2);\n *\n * batch(() => {\n *   count.set(1);\n *   count.set(2);\n *   count.set(3);\n *   // Effects run only once at the end with count = 3\n * });\n * ```\n */\nfunction batch(fn: () => void): void {\n\tbatchDepth++\n\ttry {\n\t\tfn()\n\t} finally {\n\t\tbatchDepth--\n\t\tif (batchDepth === 0) flush()\n\t}\n}\n\n/**\n * Runs a callback without tracking dependencies.\n * Any signal reads inside the callback will not create edges to the current active sink.\n *\n * @param fn - The function to execute without tracking\n * @returns The return value of the function\n *\n * @example\n * ```ts\n * const count = createState(0);\n * const label = createState('Count');\n *\n * createEffect(() => {\n *   // Only re-runs when count changes, not when label changes\n *   const name = untrack(() => label.get());\n *   console.log(`${name}: ${count.get()}`);\n * });\n * ```\n */\nfunction untrack<T>(fn: () => T): T {\n\tconst prev = activeSink\n\tactiveSink = null\n\ttry {\n\t\treturn fn()\n\t} finally {\n\t\tactiveSink = prev\n\t}\n}\n\n/* === Scope Management === */\n\n/**\n * Creates a new ownership scope for managing cleanup of nested effects and resources.\n * All effects created within the scope will be automatically disposed when the scope is disposed.\n * Scopes can be nested - disposing a parent scope disposes all child scopes.\n *\n * @param fn - The function to execute within the scope, may return a cleanup function\n * @returns A dispose function that cleans up the scope\n *\n * @example\n * ```ts\n * const dispose = createScope(() => {\n *   const count = createState(0);\n *\n *   createEffect(() => {\n *     console.log(count.get());\n *   });\n *\n *   return () => console.log('Scope disposed');\n * });\n *\n * dispose(); // Cleans up the effect and runs cleanup callbacks\n * ```\n */\nfunction createScope(fn: () => MaybeCleanup): Cleanup {\n\tconst prevOwner = activeOwner\n\tconst scope: Scope = { cleanup: null }\n\tactiveOwner = scope\n\n\ttry {\n\t\tconst out = fn()\n\t\tif (typeof out === 'function') registerCleanup(scope, out)\n\t\tconst dispose = () => runCleanup(scope)\n\t\tif (prevOwner) registerCleanup(prevOwner, dispose)\n\t\treturn dispose\n\t} finally {\n\t\tactiveOwner = prevOwner\n\t}\n}\n\nexport {\n\ttype Cleanup,\n\ttype ComputedOptions,\n\ttype EffectCallback,\n\ttype EffectNode,\n\ttype MaybeCleanup,\n\ttype MemoCallback,\n\ttype MemoNode,\n\ttype Scope,\n\ttype Signal,\n\ttype SignalOptions,\n\ttype SinkNode,\n\ttype StateNode,\n\ttype TaskCallback,\n\ttype TaskNode,\n\tactiveOwner,\n\tactiveSink,\n\tbatch,\n\tbatchDepth,\n\tcreateScope,\n\tDEFAULT_EQUALITY,\n\tSKIP_EQUALITY,\n\tFLAG_CLEAN,\n\tFLAG_DIRTY,\n\tFLAG_RELINK,\n\tflush,\n\tlink,\n\tpropagate,\n\trefresh,\n\tregisterCleanup,\n\trunCleanup,\n\trunEffect,\n\tsetState,\n\ttrimSources,\n\tTYPE_COLLECTION,\n\tTYPE_LIST,\n\tTYPE_MEMO,\n\tTYPE_SENSOR,\n\tTYPE_STATE,\n\tTYPE_SLOT,\n\tTYPE_STORE,\n\tTYPE_TASK,\n\tunlink,\n\tuntrack,\n}\n",
    "import { validateCallback, validateSignalValue } from '../errors'\nimport {\n\tactiveSink,\n\tDEFAULT_EQUALITY,\n\tlink,\n\ttype SignalOptions,\n\ttype StateNode,\n\tsetState,\n\tTYPE_STATE,\n} from '../graph'\nimport { isObjectOfType } from '../util'\n\n/* === Types === */\n\n/**\n * A callback function for states that updates a value based on the previous value.\n *\n * @template T - The type of value\n * @param prev - The previous state value\n * @returns The new state value\n */\ntype UpdateCallback<T extends {}> = (prev: T) => T\n\n/**\n * A mutable reactive state container.\n * Changes to the state will automatically propagate to dependent computations and effects.\n *\n * @template T - The type of value stored in the state\n */\ntype State<T extends {}> = {\n\treadonly [Symbol.toStringTag]: 'State'\n\n\t/**\n\t * Gets the current value of the state.\n\t * When called inside a memo, task, or effect, creates a dependency.\n\t * @returns The current value\n\t */\n\tget(): T\n\n\t/**\n\t * Sets a new value for the state.\n\t * If the new value is different (according to the equality function), all dependents will be notified.\n\t * @param next - The new value to set\n\t */\n\tset(next: T): void\n\n\t/**\n\t * Updates the state with a new value computed by a callback function.\n\t * The callback receives the current value as an argument.\n\t * @param fn - The callback function to compute the new value\n\t */\n\tupdate(fn: UpdateCallback<T>): void\n}\n\n/* === Exported Functions === */\n\n/**\n * Creates a mutable reactive state container.\n *\n * @since 0.9.0\n * @template T - The type of value stored in the state\n * @param value - The initial value\n * @param options - Optional configuration for the state\n * @returns A State object with get() and set() methods\n *\n * @example\n * ```ts\n * const count = createState(0);\n * count.set(1);\n * console.log(count.get()); // 1\n * ```\n *\n * @example\n * ```ts\n * // With type guard\n * const count = createState(0, {\n *   guard: (v): v is number => typeof v === 'number'\n * });\n * ```\n */\nfunction createState<T extends {}>(\n\tvalue: T,\n\toptions?: SignalOptions<T>,\n): State<T> {\n\tvalidateSignalValue(TYPE_STATE, value, options?.guard)\n\n\tconst node: StateNode<T> = {\n\t\tvalue,\n\t\tsinks: null,\n\t\tsinksTail: null,\n\t\tequals: options?.equals ?? DEFAULT_EQUALITY,\n\t\tguard: options?.guard,\n\t}\n\n\treturn {\n\t\t[Symbol.toStringTag]: TYPE_STATE,\n\t\tget(): T {\n\t\t\tif (activeSink) link(node, activeSink)\n\t\t\treturn node.value\n\t\t},\n\t\tset(next: T): void {\n\t\t\tvalidateSignalValue(TYPE_STATE, next, node.guard)\n\t\t\tsetState(node, next)\n\t\t},\n\t\tupdate(fn: UpdateCallback<T>): void {\n\t\t\tvalidateCallback(TYPE_STATE, fn)\n\t\t\tconst next = fn(node.value)\n\t\t\tvalidateSignalValue(TYPE_STATE, next, node.guard)\n\t\t\tsetState(node, next)\n\t\t},\n\t}\n}\n\n/**\n * Checks if a value is a State signal.\n *\n * @since 0.9.0\n * @param value - The value to check\n * @returns True if the value is a State\n *\n * @example\n * ```ts\n * const state = createState(0);\n * if (isState(state)) {\n *   state.set(1); // TypeScript knows state has set()\n * }\n * ```\n */\nfunction isState<T extends {} = unknown & {}>(\n\tvalue: unknown,\n): value is State<T> {\n\treturn isObjectOfType(value, TYPE_STATE)\n}\n\nexport { createState, isState, type State, type UpdateCallback }\n",
    "import {\n\tCircularDependencyError,\n\tDuplicateKeyError,\n\tvalidateSignalValue,\n} from '../errors'\nimport {\n\tactiveSink,\n\tbatch,\n\tbatchDepth,\n\ttype Cleanup,\n\tFLAG_CLEAN,\n\tFLAG_DIRTY,\n\tFLAG_RELINK,\n\tflush,\n\tlink,\n\ttype MemoNode,\n\tpropagate,\n\trefresh,\n\ttype SinkNode,\n\tTYPE_LIST,\n\tuntrack,\n} from '../graph'\nimport { isFunction, isObjectOfType, isRecord } from '../util'\nimport {\n\ttype Collection,\n\ttype CollectionSource,\n\ttype DeriveCollectionCallback,\n\tderiveCollection,\n} from './collection'\nimport { createState, type State } from './state'\n\n/* === Types === */\n\ntype UnknownRecord = Record<string, unknown>\n\ntype DiffResult = {\n\tchanged: boolean\n\tadd: UnknownRecord\n\tchange: UnknownRecord\n\tremove: UnknownRecord\n}\n\ntype KeyConfig<T> = string | ((item: T) => string | undefined)\n\ntype ListOptions<T extends {}> = {\n\tkeyConfig?: KeyConfig<T>\n\twatched?: () => Cleanup\n}\n\ntype List<T extends {}> = {\n\treadonly [Symbol.toStringTag]: 'List'\n\treadonly [Symbol.isConcatSpreadable]: true\n\t[Symbol.iterator](): IterableIterator<State<T>>\n\treadonly length: number\n\tget(): T[]\n\tset(next: T[]): void\n\tupdate(fn: (prev: T[]) => T[]): void\n\tat(index: number): State<T> | undefined\n\tkeys(): IterableIterator<string>\n\tbyKey(key: string): State<T> | undefined\n\tkeyAt(index: number): string | undefined\n\tindexOfKey(key: string): number\n\tadd(value: T): string\n\tremove(keyOrIndex: string | number): void\n\tsort(compareFn?: (a: T, b: T) => number): void\n\tsplice(start: number, deleteCount?: number, ...items: T[]): T[]\n\tderiveCollection<R extends {}>(\n\t\tcallback: (sourceValue: T) => R,\n\t): Collection<R>\n\tderiveCollection<R extends {}>(\n\t\tcallback: (sourceValue: T, abort: AbortSignal) => Promise<R>,\n\t): Collection<R>\n}\n\n/* === Functions === */\n\n/**\n * Checks if two values are equal with cycle detection\n *\n * @since 0.15.0\n * @param a - First value to compare\n * @param b - Second value to compare\n * @param visited - Set to track visited objects for cycle detection\n * @returns Whether the two values are equal\n */\nfunction isEqual<T>(a: T, b: T, visited?: WeakSet<object>): boolean {\n\t// Fast paths\n\tif (Object.is(a, b)) return true\n\tif (typeof a !== typeof b) return false\n\tif (\n\t\ta == null ||\n\t\ttypeof a !== 'object' ||\n\t\tb == null ||\n\t\ttypeof b !== 'object'\n\t)\n\t\treturn false\n\n\t// Cycle detection (only allocate WeakSet when both values are objects)\n\tif (!visited) visited = new WeakSet()\n\tif (visited.has(a as object) || visited.has(b as object))\n\t\tthrow new CircularDependencyError('isEqual')\n\tvisited.add(a)\n\tvisited.add(b)\n\n\ttry {\n\t\tconst aIsArray = Array.isArray(a)\n\t\tif (aIsArray !== Array.isArray(b)) return false\n\n\t\tif (aIsArray) {\n\t\t\tconst aa = a as unknown[]\n\t\t\tconst ba = b as unknown[]\n\t\t\tif (aa.length !== ba.length) return false\n\t\t\tfor (let i = 0; i < aa.length; i++)\n\t\t\t\tif (!isEqual(aa[i], ba[i], visited)) return false\n\t\t\treturn true\n\t\t}\n\n\t\tif (isRecord(a) && isRecord(b)) {\n\t\t\tconst aKeys = Object.keys(a)\n\t\t\tconst bKeys = Object.keys(b)\n\n\t\t\tif (aKeys.length !== bKeys.length) return false\n\t\t\tfor (const key of aKeys) {\n\t\t\t\tif (!(key in b)) return false\n\t\t\t\tif (!isEqual(a[key], b[key], visited)) return false\n\t\t\t}\n\t\t\treturn true\n\t\t}\n\n\t\t// For non-records/non-arrays, they are only equal if they are the same reference\n\t\t// (which would have been caught by Object.is at the beginning)\n\t\treturn false\n\t} finally {\n\t\tvisited.delete(a)\n\t\tvisited.delete(b)\n\t}\n}\n\n/** Shallow equality check for string arrays */\nfunction keysEqual(a: string[], b: string[]): boolean {\n\tif (a.length !== b.length) return false\n\tfor (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return false\n\treturn true\n}\n\nfunction getKeyGenerator<T extends {}>(\n\tkeyConfig?: KeyConfig<T>,\n): [(item: T) => string, boolean] {\n\tlet keyCounter = 0\n\tconst contentBased = typeof keyConfig === 'function'\n\treturn [\n\t\ttypeof keyConfig === 'string'\n\t\t\t? () => `${keyConfig}${keyCounter++}`\n\t\t\t: contentBased\n\t\t\t\t? (item: T) => keyConfig(item) || String(keyCounter++)\n\t\t\t\t: () => String(keyCounter++),\n\t\tcontentBased,\n\t]\n}\n\n/**\n * Compares two arrays using existing keys and returns differences as a DiffResult.\n * Avoids object conversion by working directly with arrays and keys.\n *\n * @since 0.18.0\n * @param prev - The old array\n * @param next - The new array\n * @param prevKeys - Current keys array (may be sparse or shorter than oldArray)\n * @param generateKey - Function to generate keys for new items\n * @param contentBased - When true, always use generateKey (content-based keys);\n *   when false, reuse positional keys from currentKeys (synthetic keys)\n * @returns The differences in DiffResult format plus updated keys array\n */\nfunction diffArrays<T>(\n\tprev: T[],\n\tnext: T[],\n\tprevKeys: string[],\n\tgenerateKey: (item: T) => string,\n\tcontentBased: boolean,\n): DiffResult & { newKeys: string[] } {\n\tconst visited = new WeakSet()\n\tconst add = {} as UnknownRecord\n\tconst change = {} as UnknownRecord\n\tconst remove = {} as UnknownRecord\n\tconst nextKeys: string[] = []\n\tlet changed = false\n\n\t// Build a map of old values by key for quick lookup\n\tconst prevByKey = new Map<string, T>()\n\tfor (let i = 0; i < prev.length; i++) {\n\t\tconst key = prevKeys[i]\n\t\tif (key && prev[i]) prevByKey.set(key, prev[i])\n\t}\n\n\t// Track which old keys we've seen\n\tconst seenKeys = new Set<string>()\n\n\t// Process new array and build new keys array\n\tfor (let i = 0; i < next.length; i++) {\n\t\tconst val = next[i]\n\t\tif (val === undefined) continue\n\n\t\t// Content-based keys: always derive from item; synthetic keys: reuse by position\n\t\tconst key = contentBased\n\t\t\t? generateKey(val)\n\t\t\t: (prevKeys[i] ?? generateKey(val))\n\n\t\tif (seenKeys.has(key)) throw new DuplicateKeyError(TYPE_LIST, key, val)\n\n\t\tnextKeys.push(key)\n\t\tseenKeys.add(key)\n\n\t\t// Check if this key existed before\n\t\tif (!prevByKey.has(key)) {\n\t\t\tadd[key] = val\n\t\t\tchanged = true\n\t\t} else if (!isEqual(prevByKey.get(key), val, visited)) {\n\t\t\tchange[key] = val\n\t\t\tchanged = true\n\t\t}\n\t}\n\n\t// Find removed keys (existed in old but not in new)\n\tfor (const [key] of prevByKey) {\n\t\tif (!seenKeys.has(key)) {\n\t\t\tremove[key] = null\n\t\t\tchanged = true\n\t\t}\n\t}\n\n\t// Detect reorder even when no values changed\n\tif (!changed && !keysEqual(prevKeys, nextKeys)) changed = true\n\n\treturn { add, change, remove, newKeys: nextKeys, changed }\n}\n\n/**\n * Creates a reactive list with stable keys and per-item reactivity.\n *\n * @since 0.18.0\n * @param value - Initial array of items\n * @param options - Optional configuration for key generation and watch lifecycle\n * @returns A List signal\n */\nfunction createList<T extends {}>(\n\tvalue: T[],\n\toptions?: ListOptions<T>,\n): List<T> {\n\tvalidateSignalValue(TYPE_LIST, value, Array.isArray)\n\n\tconst signals = new Map<string, State<T>>()\n\tlet keys: string[] = []\n\n\tconst [generateKey, contentBased] = getKeyGenerator(options?.keyConfig)\n\n\t// --- Internal helpers ---\n\n\t// Build current value from child signals\n\tconst buildValue = (): T[] =>\n\t\tkeys\n\t\t\t.map(key => signals.get(key)?.get())\n\t\t\t.filter(v => v !== undefined) as T[]\n\n\t// Structural tracking node — not a general-purpose Memo.\n\t// On first get(): refresh() establishes edges from child signals.\n\t// On subsequent get(): untrack(buildValue) rebuilds without re-linking.\n\t// Mutation methods set FLAG_RELINK to force re-establishment on next read.\n\tconst node: MemoNode<T[]> = {\n\t\tfn: buildValue,\n\t\tvalue,\n\t\tflags: FLAG_DIRTY,\n\t\tsources: null,\n\t\tsourcesTail: null,\n\t\tsinks: null,\n\t\tsinksTail: null,\n\t\tequals: isEqual,\n\t\terror: undefined,\n\t}\n\n\tconst toRecord = (array: T[]): Record<string, T> => {\n\t\tconst record = {} as Record<string, T>\n\t\tfor (let i = 0; i < array.length; i++) {\n\t\t\tconst val = array[i]\n\t\t\tif (val === undefined) continue\n\t\t\tlet key = keys[i]\n\t\t\tif (!key) {\n\t\t\t\tkey = generateKey(val)\n\t\t\t\tkeys[i] = key\n\t\t\t}\n\t\t\trecord[key] = val\n\t\t}\n\t\treturn record\n\t}\n\n\tconst applyChanges = (changes: DiffResult): boolean => {\n\t\tlet structural = false\n\n\t\t// Additions\n\t\tfor (const key in changes.add) {\n\t\t\tconst val = changes.add[key] as T\n\t\t\tvalidateSignalValue(`${TYPE_LIST} item for key \"${key}\"`, val)\n\t\t\tsignals.set(key, createState(val))\n\t\t\tstructural = true\n\t\t}\n\n\t\t// Changes\n\t\tif (Object.keys(changes.change).length) {\n\t\t\tbatch(() => {\n\t\t\t\tfor (const key in changes.change) {\n\t\t\t\t\tconst val = changes.change[key]\n\t\t\t\t\tvalidateSignalValue(\n\t\t\t\t\t\t`${TYPE_LIST} item for key \"${key}\"`,\n\t\t\t\t\t\tval,\n\t\t\t\t\t)\n\t\t\t\t\tconst signal = signals.get(key)\n\t\t\t\t\tif (signal) signal.set(val as T)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t\t// Removals\n\t\tfor (const key in changes.remove) {\n\t\t\tsignals.delete(key)\n\t\t\tconst index = keys.indexOf(key)\n\t\t\tif (index !== -1) keys.splice(index, 1)\n\t\t\tstructural = true\n\t\t}\n\n\t\tif (structural) node.flags |= FLAG_RELINK\n\n\t\treturn changes.changed\n\t}\n\n\tconst watched = options?.watched\n\tconst subscribe = watched\n\t\t? () => {\n\t\t\t\tif (activeSink) {\n\t\t\t\t\tif (!node.sinks) node.stop = watched()\n\t\t\t\t\tlink(node, activeSink)\n\t\t\t\t}\n\t\t\t}\n\t\t: () => {\n\t\t\t\tif (activeSink) link(node, activeSink)\n\t\t\t}\n\n\t// --- Initialize ---\n\tconst initRecord = toRecord(value)\n\tfor (const key in initRecord) {\n\t\tconst val = initRecord[key]\n\t\tvalidateSignalValue(`${TYPE_LIST} item for key \"${key}\"`, val)\n\t\tsignals.set(key, createState(val))\n\t}\n\n\t// Starts clean: mutation methods (add/remove/set/splice) explicitly call\n\t// propagate() + invalidate edges, so refresh() on first get() is not needed.\n\tnode.value = value\n\tnode.flags = 0\n\n\t// --- List object ---\n\tconst list: List<T> = {\n\t\t[Symbol.toStringTag]: TYPE_LIST,\n\t\t[Symbol.isConcatSpreadable]: true as const,\n\n\t\t*[Symbol.iterator]() {\n\t\t\tfor (const key of keys) {\n\t\t\t\tconst signal = signals.get(key)\n\t\t\t\tif (signal) yield signal\n\t\t\t}\n\t\t},\n\n\t\tget length() {\n\t\t\tsubscribe()\n\t\t\treturn keys.length\n\t\t},\n\n\t\tget() {\n\t\t\tsubscribe()\n\t\t\tif (node.sources) {\n\t\t\t\t// Fast path: edges already established, rebuild value directly\n\t\t\t\tif (node.flags) {\n\t\t\t\t\tconst relink = node.flags & FLAG_RELINK\n\t\t\t\t\tnode.value = untrack(buildValue)\n\t\t\t\t\tif (relink) {\n\t\t\t\t\t\t// Structural mutation added/removed child signals —\n\t\t\t\t\t\t// tracked recompute so link() adds new edges and\n\t\t\t\t\t\t// trimSources() removes stale ones without orphaning.\n\t\t\t\t\t\tnode.flags = FLAG_DIRTY\n\t\t\t\t\t\trefresh(node as unknown as SinkNode)\n\t\t\t\t\t\tif (node.error) throw node.error\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnode.flags = FLAG_CLEAN\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// First access: use refresh() to establish child → list edges\n\t\t\t\trefresh(node as unknown as SinkNode)\n\t\t\t\tif (node.error) throw node.error\n\t\t\t}\n\t\t\treturn node.value\n\t\t},\n\n\t\tset(next: T[]) {\n\t\t\tconst prev = node.flags & FLAG_DIRTY ? buildValue() : node.value\n\t\t\tconst changes = diffArrays(\n\t\t\t\tprev,\n\t\t\t\tnext,\n\t\t\t\tkeys,\n\t\t\t\tgenerateKey,\n\t\t\t\tcontentBased,\n\t\t\t)\n\t\t\tif (changes.changed) {\n\t\t\t\tkeys = changes.newKeys\n\t\t\t\tapplyChanges(changes)\n\t\t\t\tnode.flags |= FLAG_DIRTY\n\t\t\t\tfor (let e = node.sinks; e; e = e.nextSink) propagate(e.sink)\n\t\t\t\tif (batchDepth === 0) flush()\n\t\t\t}\n\t\t},\n\n\t\tupdate(fn: (prev: T[]) => T[]) {\n\t\t\tlist.set(fn(list.get()))\n\t\t},\n\n\t\tat(index: number) {\n\t\t\treturn signals.get(keys[index])\n\t\t},\n\n\t\tkeys() {\n\t\t\tsubscribe()\n\t\t\treturn keys.values()\n\t\t},\n\n\t\tbyKey(key: string) {\n\t\t\treturn signals.get(key)\n\t\t},\n\n\t\tkeyAt(index: number) {\n\t\t\treturn keys[index]\n\t\t},\n\n\t\tindexOfKey(key: string) {\n\t\t\treturn keys.indexOf(key)\n\t\t},\n\n\t\tadd(value: T) {\n\t\t\tconst key = generateKey(value)\n\t\t\tif (signals.has(key))\n\t\t\t\tthrow new DuplicateKeyError(TYPE_LIST, key, value)\n\t\t\tif (!keys.includes(key)) keys.push(key)\n\t\t\tvalidateSignalValue(`${TYPE_LIST} item for key \"${key}\"`, value)\n\t\t\tsignals.set(key, createState(value))\n\t\t\tnode.flags |= FLAG_DIRTY | FLAG_RELINK\n\t\t\tfor (let e = node.sinks; e; e = e.nextSink) propagate(e.sink)\n\t\t\tif (batchDepth === 0) flush()\n\t\t\treturn key\n\t\t},\n\n\t\tremove(keyOrIndex: string | number) {\n\t\t\tconst key =\n\t\t\t\ttypeof keyOrIndex === 'number' ? keys[keyOrIndex] : keyOrIndex\n\t\t\tconst ok = signals.delete(key)\n\t\t\tif (ok) {\n\t\t\t\tconst index =\n\t\t\t\t\ttypeof keyOrIndex === 'number'\n\t\t\t\t\t\t? keyOrIndex\n\t\t\t\t\t\t: keys.indexOf(key)\n\t\t\t\tif (index >= 0) keys.splice(index, 1)\n\t\t\t\tnode.flags |= FLAG_DIRTY | FLAG_RELINK\n\t\t\t\tfor (let e = node.sinks; e; e = e.nextSink) propagate(e.sink)\n\t\t\t\tif (batchDepth === 0) flush()\n\t\t\t}\n\t\t},\n\n\t\tsort(compareFn?: (a: T, b: T) => number) {\n\t\t\tconst entries = keys\n\t\t\t\t.map(key => [key, signals.get(key)?.get()] as [string, T])\n\t\t\t\t.sort(\n\t\t\t\t\tisFunction(compareFn)\n\t\t\t\t\t\t? (a, b) => compareFn(a[1], b[1])\n\t\t\t\t\t\t: (a, b) => String(a[1]).localeCompare(String(b[1])),\n\t\t\t\t)\n\t\t\tconst newOrder = entries.map(([key]) => key)\n\n\t\t\tif (!keysEqual(keys, newOrder)) {\n\t\t\t\tkeys = newOrder\n\t\t\t\tnode.flags |= FLAG_DIRTY\n\t\t\t\tfor (let e = node.sinks; e; e = e.nextSink) propagate(e.sink)\n\t\t\t\tif (batchDepth === 0) flush()\n\t\t\t}\n\t\t},\n\n\t\tsplice(start: number, deleteCount?: number, ...items: T[]) {\n\t\t\tconst length = keys.length\n\t\t\tconst actualStart =\n\t\t\t\tstart < 0\n\t\t\t\t\t? Math.max(0, length + start)\n\t\t\t\t\t: Math.min(start, length)\n\t\t\tconst actualDeleteCount = Math.max(\n\t\t\t\t0,\n\t\t\t\tMath.min(\n\t\t\t\t\tdeleteCount ??\n\t\t\t\t\t\tMath.max(0, length - Math.max(0, actualStart)),\n\t\t\t\t\tlength - actualStart,\n\t\t\t\t),\n\t\t\t)\n\n\t\t\tconst add = {} as Record<string, T>\n\t\t\tconst remove = {} as Record<string, T>\n\n\t\t\t// Collect items to delete\n\t\t\tfor (let i = 0; i < actualDeleteCount; i++) {\n\t\t\t\tconst index = actualStart + i\n\t\t\t\tconst key = keys[index]\n\t\t\t\tif (key) {\n\t\t\t\t\tconst signal = signals.get(key)\n\t\t\t\t\tif (signal) remove[key] = signal.get() as T\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Build new key order\n\t\t\tconst newOrder = keys.slice(0, actualStart)\n\n\t\t\tfor (const item of items) {\n\t\t\t\tconst key = generateKey(item)\n\t\t\t\tif (signals.has(key) && !(key in remove))\n\t\t\t\t\tthrow new DuplicateKeyError(TYPE_LIST, key, item)\n\t\t\t\tnewOrder.push(key)\n\t\t\t\tadd[key] = item\n\t\t\t}\n\n\t\t\tnewOrder.push(...keys.slice(actualStart + actualDeleteCount))\n\n\t\t\tconst changed = !!(\n\t\t\t\tObject.keys(add).length || Object.keys(remove).length\n\t\t\t)\n\n\t\t\tif (changed) {\n\t\t\t\tapplyChanges({\n\t\t\t\t\tadd,\n\t\t\t\t\tchange: {},\n\t\t\t\t\tremove,\n\t\t\t\t\tchanged,\n\t\t\t\t})\n\t\t\t\tkeys = newOrder\n\t\t\t\tnode.flags |= FLAG_DIRTY\n\t\t\t\tfor (let e = node.sinks; e; e = e.nextSink) propagate(e.sink)\n\t\t\t\tif (batchDepth === 0) flush()\n\t\t\t}\n\n\t\t\treturn Object.values(remove)\n\t\t},\n\n\t\tderiveCollection<R extends {}>(\n\t\t\tcb: DeriveCollectionCallback<R, T>,\n\t\t): Collection<R> {\n\t\t\treturn (\n\t\t\t\tderiveCollection as <T2 extends {}, U2 extends {}>(\n\t\t\t\t\tsource: CollectionSource<U2>,\n\t\t\t\t\tcallback: DeriveCollectionCallback<T2, U2>,\n\t\t\t\t) => Collection<T2>\n\t\t\t)(list, cb)\n\t\t},\n\t}\n\n\treturn list\n}\n\n/**\n * Checks if a value is a List signal.\n *\n * @since 0.15.0\n * @param value - The value to check\n * @returns True if the value is a List\n */\nfunction isList<T extends {}>(value: unknown): value is List<T> {\n\treturn isObjectOfType(value, TYPE_LIST)\n}\n\n/* === Exports === */\n\nexport {\n\ttype DiffResult,\n\ttype KeyConfig,\n\ttype List,\n\ttype ListOptions,\n\ttype UnknownRecord,\n\tcreateList,\n\tisEqual,\n\tisList,\n\tgetKeyGenerator,\n\tkeysEqual,\n\tTYPE_LIST,\n}\n",
    "import {\n\tvalidateCallback,\n\tvalidateReadValue,\n\tvalidateSignalValue,\n} from '../errors'\nimport {\n\tactiveSink,\n\tbatchDepth,\n\ttype ComputedOptions,\n\tDEFAULT_EQUALITY,\n\tFLAG_DIRTY,\n\tflush,\n\tlink,\n\ttype MemoCallback,\n\ttype MemoNode,\n\tpropagate,\n\trefresh,\n\ttype SinkNode,\n\tTYPE_MEMO,\n} from '../graph'\nimport { isObjectOfType, isSyncFunction } from '../util'\n\n/* === Types === */\n\n/**\n * A derived reactive computation that caches its result.\n * Automatically tracks dependencies and recomputes when they change.\n *\n * @template T - The type of value computed by the memo\n */\ntype Memo<T extends {}> = {\n\treadonly [Symbol.toStringTag]: 'Memo'\n\n\t/**\n\t * Gets the current value of the memo.\n\t * Recomputes if dependencies have changed since last access.\n\t * When called inside another reactive context, creates a dependency.\n\t * @returns The computed value\n\t * @throws UnsetSignalValueError If the memo value is still unset when read.\n\t */\n\tget(): T\n}\n\n/* === Exported Functions === */\n\n/**\n * Creates a derived reactive computation that caches its result.\n * The computation automatically tracks dependencies and recomputes when they change.\n * Uses lazy evaluation - only computes when the value is accessed.\n *\n * @since 0.18.0\n * @template T - The type of value computed by the memo\n * @param fn - The computation function that receives the previous value\n * @param options - Optional configuration for the memo\n * @param options.value - Optional initial value for reducer patterns\n * @param options.equals - Optional equality function. Defaults to strict equality (`===`)\n * @param options.guard - Optional type guard to validate values\n * @param options.watched - Optional callback invoked when the memo is first watched by an effect.\n *   Receives an `invalidate` function to mark the memo dirty and trigger recomputation.\n *   Must return a cleanup function called when no effects are watching.\n * @returns A Memo object with a get() method\n *\n * @example\n * ```ts\n * const count = createState(0);\n * const doubled = createMemo(() => count.get() * 2);\n * console.log(doubled.get()); // 0\n * count.set(5);\n * console.log(doubled.get()); // 10\n * ```\n *\n * @example\n * ```ts\n * // Using previous value\n * const sum = createMemo((prev) => prev + count.get(), { value: 0, equals: Object.is });\n * ```\n */\nfunction createMemo<T extends {}>(\n\tfn: (prev: T) => T,\n\toptions: ComputedOptions<T> & { value: T },\n): Memo<T>\nfunction createMemo<T extends {}>(\n\tfn: MemoCallback<T>,\n\toptions?: ComputedOptions<T>,\n): Memo<T>\nfunction createMemo<T extends {}>(\n\tfn: MemoCallback<T>,\n\toptions?: ComputedOptions<T>,\n): Memo<T> {\n\tvalidateCallback(TYPE_MEMO, fn, isSyncFunction)\n\tif (options?.value !== undefined)\n\t\tvalidateSignalValue(TYPE_MEMO, options.value, options?.guard)\n\n\tconst node: MemoNode<T> = {\n\t\tfn,\n\t\tvalue: options?.value as T,\n\t\tflags: FLAG_DIRTY,\n\t\tsources: null,\n\t\tsourcesTail: null,\n\t\tsinks: null,\n\t\tsinksTail: null,\n\t\tequals: options?.equals ?? DEFAULT_EQUALITY,\n\t\terror: undefined,\n\t\tstop: undefined,\n\t}\n\n\tconst watched = options?.watched\n\tconst subscribe = watched\n\t\t? () => {\n\t\t\t\tif (activeSink) {\n\t\t\t\t\tif (!node.sinks)\n\t\t\t\t\t\tnode.stop = watched(() => {\n\t\t\t\t\t\t\tnode.flags |= FLAG_DIRTY\n\t\t\t\t\t\t\tfor (let e = node.sinks; e; e = e.nextSink)\n\t\t\t\t\t\t\t\tpropagate(e.sink)\n\t\t\t\t\t\t\tif (batchDepth === 0) flush()\n\t\t\t\t\t\t})\n\t\t\t\t\tlink(node, activeSink)\n\t\t\t\t}\n\t\t\t}\n\t\t: () => {\n\t\t\t\tif (activeSink) link(node, activeSink)\n\t\t\t}\n\n\treturn {\n\t\t[Symbol.toStringTag]: TYPE_MEMO,\n\t\tget() {\n\t\t\tsubscribe()\n\t\t\trefresh(node as unknown as SinkNode)\n\t\t\tif (node.error) throw node.error\n\t\t\tvalidateReadValue(TYPE_MEMO, node.value)\n\t\t\treturn node.value\n\t\t},\n\t}\n}\n\n/**\n * Checks if a value is a Memo signal.\n *\n * @since 0.18.0\n * @param value - The value to check\n * @returns True if the value is a Memo\n */\nfunction isMemo<T extends {} = unknown & {}>(value: unknown): value is Memo<T> {\n\treturn isObjectOfType(value, TYPE_MEMO)\n}\n\nexport { createMemo, isMemo, type Memo }\n",
    "import {\n\tvalidateCallback,\n\tvalidateReadValue,\n\tvalidateSignalValue,\n} from '../errors'\nimport {\n\tactiveSink,\n\tbatchDepth,\n\ttype ComputedOptions,\n\tDEFAULT_EQUALITY,\n\tFLAG_DIRTY,\n\tflush,\n\tlink,\n\tpropagate,\n\trefresh,\n\ttype SinkNode,\n\ttype TaskCallback,\n\ttype TaskNode,\n\tTYPE_TASK,\n} from '../graph'\nimport { isAsyncFunction, isObjectOfType } from '../util'\n\n/* === Types === */\n\n/**\n * An asynchronous reactive computation (colorless async).\n * Automatically tracks dependencies and re-executes when they change.\n * Provides abort semantics and pending state tracking.\n *\n * @template T - The type of value resolved by the task\n */\ntype Task<T extends {}> = {\n\treadonly [Symbol.toStringTag]: 'Task'\n\n\t/**\n\t * Gets the current value of the task.\n\t * Returns the last resolved value, even while a new computation is pending.\n\t * When called inside another reactive context, creates a dependency.\n\t * @returns The current value\n\t * @throws UnsetSignalValueError If the task value is still unset when read.\n\t */\n\tget(): T\n\n\t/**\n\t * Checks if the task is currently executing.\n\t * @returns True if a computation is in progress\n\t */\n\tisPending(): boolean\n\n\t/**\n\t * Aborts the current computation if one is running.\n\t * The task's AbortSignal will be triggered.\n\t */\n\tabort(): void\n}\n\n/* === Exported Functions === */\n\n/**\n * Creates an asynchronous reactive computation (colorless async).\n * The computation automatically tracks dependencies and re-executes when they change.\n * Provides abort semantics - in-flight computations are aborted when dependencies change.\n *\n * @since 0.18.0\n * @template T - The type of value resolved by the task\n * @param fn - The async computation function that receives the previous value and an AbortSignal\n * @param options - Optional configuration for the task\n * @param options.value - Optional initial value for reducer patterns\n * @param options.equals - Optional equality function. Defaults to strict equality (`===`)\n * @param options.guard - Optional type guard to validate values\n * @param options.watched - Optional callback invoked when the task is first watched by an effect.\n *   Receives an `invalidate` function to mark the task dirty and trigger re-execution.\n *   Must return a cleanup function called when no effects are watching.\n * @returns A Task object with get(), isPending(), and abort() methods\n *\n * @example\n * ```ts\n * const userId = createState(1);\n * const user = createTask(async (prev, signal) => {\n *   const response = await fetch(`/api/users/${userId.get()}`, { signal });\n *   return response.json();\n * });\n *\n * // When userId changes, the previous fetch is aborted\n * userId.set(2);\n * ```\n *\n * @example\n * ```ts\n * // Check pending state\n * if (user.isPending()) {\n *   console.log('Loading...');\n * }\n * ```\n */\nfunction createTask<T extends {}>(\n\tfn: (prev: T, signal: AbortSignal) => Promise<T>,\n\toptions: ComputedOptions<T> & { value: T },\n): Task<T>\nfunction createTask<T extends {}>(\n\tfn: TaskCallback<T>,\n\toptions?: ComputedOptions<T>,\n): Task<T>\nfunction createTask<T extends {}>(\n\tfn: TaskCallback<T>,\n\toptions?: ComputedOptions<T>,\n): Task<T> {\n\tvalidateCallback(TYPE_TASK, fn, isAsyncFunction)\n\tif (options?.value !== undefined)\n\t\tvalidateSignalValue(TYPE_TASK, options.value, options?.guard)\n\n\tconst node: TaskNode<T> = {\n\t\tfn,\n\t\tvalue: options?.value as T,\n\t\tsources: null,\n\t\tsourcesTail: null,\n\t\tsinks: null,\n\t\tsinksTail: null,\n\t\tflags: FLAG_DIRTY,\n\t\tequals: options?.equals ?? DEFAULT_EQUALITY,\n\t\tcontroller: undefined,\n\t\terror: undefined,\n\t\tstop: undefined,\n\t}\n\n\tconst watched = options?.watched\n\tconst subscribe = watched\n\t\t? () => {\n\t\t\t\tif (activeSink) {\n\t\t\t\t\tif (!node.sinks)\n\t\t\t\t\t\tnode.stop = watched(() => {\n\t\t\t\t\t\t\tnode.flags |= FLAG_DIRTY\n\t\t\t\t\t\t\tfor (let e = node.sinks; e; e = e.nextSink)\n\t\t\t\t\t\t\t\tpropagate(e.sink)\n\t\t\t\t\t\t\tif (batchDepth === 0) flush()\n\t\t\t\t\t\t})\n\t\t\t\t\tlink(node, activeSink)\n\t\t\t\t}\n\t\t\t}\n\t\t: () => {\n\t\t\t\tif (activeSink) link(node, activeSink)\n\t\t\t}\n\n\treturn {\n\t\t[Symbol.toStringTag]: TYPE_TASK,\n\t\tget(): T {\n\t\t\tsubscribe()\n\t\t\trefresh(node as unknown as SinkNode)\n\t\t\tif (node.error) throw node.error\n\t\t\tvalidateReadValue(TYPE_TASK, node.value)\n\t\t\treturn node.value\n\t\t},\n\t\tisPending(): boolean {\n\t\t\treturn !!node.controller\n\t\t},\n\t\tabort(): void {\n\t\t\tnode.controller?.abort()\n\t\t\tnode.controller = undefined\n\t\t},\n\t}\n}\n\n/**\n * Checks if a value is a Task signal.\n *\n * @since 0.18.0\n * @param value - The value to check\n * @returns True if the value is a Task\n */\nfunction isTask<T extends {} = unknown & {}>(value: unknown): value is Task<T> {\n\treturn isObjectOfType(value, TYPE_TASK)\n}\n\nexport { createTask, isTask, type Task }\n",
    "import {\n\tUnsetSignalValueError,\n\tvalidateCallback,\n\tvalidateSignalValue,\n} from '../errors'\nimport {\n\tactiveSink,\n\tbatch,\n\ttype Cleanup,\n\tFLAG_CLEAN,\n\tFLAG_DIRTY,\n\tFLAG_RELINK,\n\tlink,\n\ttype MemoNode,\n\tpropagate,\n\trefresh,\n\ttype Signal,\n\ttype SinkNode,\n\tSKIP_EQUALITY,\n\tTYPE_COLLECTION,\n\tuntrack,\n} from '../graph'\nimport { isAsyncFunction, isObjectOfType, isSyncFunction } from '../util'\nimport {\n\tgetKeyGenerator,\n\tisList,\n\ttype KeyConfig,\n\tkeysEqual,\n\ttype List,\n} from './list'\nimport { createMemo, type Memo } from './memo'\nimport { createState, isState } from './state'\nimport { createTask } from './task'\n\n/* === Types === */\n\ntype CollectionSource<T extends {}> = List<T> | Collection<T>\n\ntype DeriveCollectionCallback<T extends {}, U extends {}> =\n\t| ((sourceValue: U) => T)\n\t| ((sourceValue: U, abort: AbortSignal) => Promise<T>)\n\ntype Collection<T extends {}> = {\n\treadonly [Symbol.toStringTag]: 'Collection'\n\treadonly [Symbol.isConcatSpreadable]: true\n\t[Symbol.iterator](): IterableIterator<Signal<T>>\n\tkeys(): IterableIterator<string>\n\tget(): T[]\n\tat(index: number): Signal<T> | undefined\n\tbyKey(key: string): Signal<T> | undefined\n\tkeyAt(index: number): string | undefined\n\tindexOfKey(key: string): number\n\tderiveCollection<R extends {}>(\n\t\tcallback: (sourceValue: T) => R,\n\t): Collection<R>\n\tderiveCollection<R extends {}>(\n\t\tcallback: (sourceValue: T, abort: AbortSignal) => Promise<R>,\n\t): Collection<R>\n\treadonly length: number\n}\n\ntype CollectionChanges<T> = {\n\tadd?: T[]\n\tchange?: T[]\n\tremove?: T[]\n}\n\ntype CollectionOptions<T extends {}> = {\n\tvalue?: T[]\n\tkeyConfig?: KeyConfig<T>\n\tcreateItem?: (value: T) => Signal<T>\n}\n\ntype CollectionCallback<T extends {}> = (\n\tapply: (changes: CollectionChanges<T>) => void,\n) => Cleanup\n\n/* === Functions === */\n\n/**\n * Creates a derived Collection from a List or another Collection with item-level memoization.\n * Sync callbacks use createMemo, async callbacks use createTask.\n * Structural changes are tracked reactively via the source's keys.\n *\n * @since 0.18.0\n * @param source - The source List or Collection to derive from\n * @param callback - Transformation function applied to each item\n * @returns A Collection signal\n */\nfunction deriveCollection<T extends {}, U extends {}>(\n\tsource: CollectionSource<U>,\n\tcallback: (sourceValue: U) => T,\n): Collection<T>\nfunction deriveCollection<T extends {}, U extends {}>(\n\tsource: CollectionSource<U>,\n\tcallback: (sourceValue: U, abort: AbortSignal) => Promise<T>,\n): Collection<T>\nfunction deriveCollection<T extends {}, U extends {}>(\n\tsource: CollectionSource<U>,\n\tcallback: DeriveCollectionCallback<T, U>,\n): Collection<T> {\n\tvalidateCallback(TYPE_COLLECTION, callback)\n\n\tconst isAsync = isAsyncFunction(callback)\n\tconst signals = new Map<string, Memo<T>>()\n\tlet keys: string[] = []\n\n\tconst addSignal = (key: string): void => {\n\t\tconst signal = isAsync\n\t\t\t? createTask(async (prev: T | undefined, abort: AbortSignal) => {\n\t\t\t\t\tconst sourceValue = source.byKey(key)?.get() as U\n\t\t\t\t\tif (sourceValue == null) return prev as T\n\t\t\t\t\treturn (\n\t\t\t\t\t\tcallback as (\n\t\t\t\t\t\t\tsourceValue: U,\n\t\t\t\t\t\t\tabort: AbortSignal,\n\t\t\t\t\t\t) => Promise<T>\n\t\t\t\t\t)(sourceValue, abort)\n\t\t\t\t})\n\t\t\t: createMemo(() => {\n\t\t\t\t\tconst sourceValue = source.byKey(key)?.get() as U\n\t\t\t\t\tif (sourceValue == null) return undefined as unknown as T\n\t\t\t\t\treturn (callback as (sourceValue: U) => T)(sourceValue)\n\t\t\t\t})\n\n\t\tsignals.set(key, signal as Memo<T>)\n\t}\n\n\t// Sync signals map with the given keys.\n\t// Intentionally side-effectful: mutates the private signals map and keys\n\t// array. Sets FLAG_RELINK on the node if keys changed.\n\tfunction syncKeys(nextKeys: string[]): void {\n\t\tif (!keysEqual(keys, nextKeys)) {\n\t\t\tconst a = new Set(keys)\n\t\t\tconst b = new Set(nextKeys)\n\n\t\t\tfor (const key of keys) if (!b.has(key)) signals.delete(key)\n\t\t\tfor (const key of nextKeys) if (!a.has(key)) addSignal(key)\n\t\t\tkeys = nextKeys\n\t\t\tnode.flags |= FLAG_RELINK\n\t\t}\n\t}\n\n\t// Build current value from child signals.\n\t// Reads source.keys() to sync the signals map and — during refresh() —\n\t// to establish a graph edge from source → this node.\n\tfunction buildValue(): T[] {\n\t\tsyncKeys(Array.from(source.keys()))\n\t\tconst result: T[] = []\n\t\tfor (const key of keys) {\n\t\t\ttry {\n\t\t\t\tconst v = signals.get(key)?.get()\n\t\t\t\tif (v != null) result.push(v)\n\t\t\t} catch (e) {\n\t\t\t\t// Skip pending async items; rethrow real errors\n\t\t\t\tif (!(e instanceof UnsetSignalValueError)) throw e\n\t\t\t}\n\t\t}\n\t\treturn result\n\t}\n\n\t// Shallow reference equality for value arrays — prevents unnecessary\n\t// downstream propagation when re-evaluation produces the same item references\n\tconst valuesEqual = (a: T[], b: T[]): boolean => {\n\t\tif (a.length !== b.length) return false\n\t\tfor (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return false\n\t\treturn true\n\t}\n\n\t// Structural tracking node — mirrors the List/Store/createCollection pattern.\n\t// fn (buildValue) syncs keys then reads child signals to produce T[].\n\t// Keys are tracked separately in a local variable.\n\tconst node: MemoNode<T[]> = {\n\t\tfn: buildValue,\n\t\tvalue: [],\n\t\tflags: FLAG_DIRTY,\n\t\tsources: null,\n\t\tsourcesTail: null,\n\t\tsinks: null,\n\t\tsinksTail: null,\n\t\tequals: valuesEqual,\n\t\terror: undefined,\n\t}\n\n\tfunction ensureFresh(): void {\n\t\tif (node.sources) {\n\t\t\tif (node.flags) {\n\t\t\t\tnode.value = untrack(buildValue)\n\t\t\t\tif (node.flags & FLAG_RELINK) {\n\t\t\t\t\t// Keys changed — new child signals need graph edges.\n\t\t\t\t\t// Tracked recompute so link() adds new edges and\n\t\t\t\t\t// trimSources() removes stale ones without orphaning.\n\t\t\t\t\tnode.flags = FLAG_DIRTY\n\t\t\t\t\trefresh(node as unknown as SinkNode)\n\t\t\t\t\tif (node.error) throw node.error\n\t\t\t\t} else {\n\t\t\t\t\tnode.flags = FLAG_CLEAN\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (node.sinks) {\n\t\t\t// First access with a downstream subscriber — use refresh()\n\t\t\t// to establish graph edges via recomputeMemo\n\t\t\trefresh(node as unknown as SinkNode)\n\t\t\tif (node.error) throw node.error\n\t\t} else {\n\t\t\t// No subscribers yet (e.g., chained deriveCollection init) —\n\t\t\t// compute value without establishing graph edges to prevent\n\t\t\t// premature watched activation on upstream sources.\n\t\t\t// Keep FLAG_DIRTY so the first refresh() with a real subscriber\n\t\t\t// will establish proper graph edges.\n\t\t\tnode.value = untrack(buildValue)\n\t\t}\n\t}\n\n\t// Initialize signals for current source keys — untrack to prevent\n\t// triggering watched callbacks on upstream sources during construction.\n\t// The first refresh() (triggered by an effect) will establish proper\n\t// graph edges; this just populates the signals map for direct access.\n\tconst initialKeys = Array.from(untrack(() => source.keys()))\n\tfor (const key of initialKeys) addSignal(key)\n\tkeys = initialKeys\n\t// Keep FLAG_DIRTY so the first refresh() establishes edges.\n\n\tconst collection: Collection<T> = {\n\t\t[Symbol.toStringTag]: TYPE_COLLECTION,\n\t\t[Symbol.isConcatSpreadable]: true as const,\n\n\t\t*[Symbol.iterator]() {\n\t\t\tfor (const key of keys) {\n\t\t\t\tconst signal = signals.get(key)\n\t\t\t\tif (signal) yield signal\n\t\t\t}\n\t\t},\n\n\t\tget length() {\n\t\t\tif (activeSink) link(node, activeSink)\n\t\t\tensureFresh()\n\t\t\treturn keys.length\n\t\t},\n\n\t\tkeys() {\n\t\t\tif (activeSink) link(node, activeSink)\n\t\t\tensureFresh()\n\t\t\treturn keys.values()\n\t\t},\n\n\t\tget() {\n\t\t\tif (activeSink) link(node, activeSink)\n\t\t\tensureFresh()\n\t\t\treturn node.value\n\t\t},\n\n\t\tat(index: number) {\n\t\t\treturn signals.get(keys[index])\n\t\t},\n\n\t\tbyKey(key: string) {\n\t\t\treturn signals.get(key)\n\t\t},\n\n\t\tkeyAt(index: number) {\n\t\t\treturn keys[index]\n\t\t},\n\n\t\tindexOfKey(key: string) {\n\t\t\treturn keys.indexOf(key)\n\t\t},\n\n\t\tderiveCollection<R extends {}>(\n\t\t\tcb: DeriveCollectionCallback<R, T>,\n\t\t): Collection<R> {\n\t\t\treturn (\n\t\t\t\tderiveCollection as <T2 extends {}, U2 extends {}>(\n\t\t\t\t\tsource: CollectionSource<U2>,\n\t\t\t\t\tcallback: DeriveCollectionCallback<T2, U2>,\n\t\t\t\t) => Collection<T2>\n\t\t\t)(collection, cb)\n\t\t},\n\t}\n\n\treturn collection\n}\n\n/**\n * Creates an externally-driven Collection with a watched lifecycle.\n * Items are managed via the `applyChanges(changes)` helper passed to the watched callback.\n * The collection activates when first accessed by an effect and deactivates when no longer watched.\n *\n * @since 0.18.0\n * @param watched - Callback invoked when the collection starts being watched, receives applyChanges helper\n * @param options - Optional configuration including initial value, key generation, and item signal creation\n * @returns A read-only Collection signal\n */\nfunction createCollection<T extends {}>(\n\twatched: CollectionCallback<T>,\n\toptions?: CollectionOptions<T>,\n): Collection<T> {\n\tconst value = options?.value ?? []\n\tif (value.length) validateSignalValue(TYPE_COLLECTION, value, Array.isArray)\n\tvalidateCallback(TYPE_COLLECTION, watched, isSyncFunction)\n\n\tconst signals = new Map<string, Signal<T>>()\n\tconst keys: string[] = []\n\tconst itemToKey = new Map<T, string>()\n\n\tconst [generateKey, contentBased] = getKeyGenerator(options?.keyConfig)\n\n\tconst resolveKey = (item: T): string | undefined =>\n\t\titemToKey.get(item) ?? (contentBased ? generateKey(item) : undefined)\n\n\tconst itemFactory = options?.createItem ?? createState\n\n\t// Build current value from child signals\n\tfunction buildValue(): T[] {\n\t\tconst result: T[] = []\n\t\tfor (const key of keys) {\n\t\t\ttry {\n\t\t\t\tconst v = signals.get(key)?.get()\n\t\t\t\tif (v != null) result.push(v)\n\t\t\t} catch (e) {\n\t\t\t\t// Skip pending async items; rethrow real errors\n\t\t\t\tif (!(e instanceof UnsetSignalValueError)) throw e\n\t\t\t}\n\t\t}\n\t\treturn result\n\t}\n\n\tconst node: MemoNode<T[]> = {\n\t\tfn: buildValue,\n\t\tvalue,\n\t\tflags: FLAG_DIRTY,\n\t\tsources: null,\n\t\tsourcesTail: null,\n\t\tsinks: null,\n\t\tsinksTail: null,\n\t\tequals: SKIP_EQUALITY, // Always rebuild — structural changes are managed externally\n\t\terror: undefined,\n\t}\n\n\t// Initialize signals for initial value\n\tfor (const item of value) {\n\t\tconst key = generateKey(item)\n\t\tsignals.set(key, itemFactory(item))\n\t\titemToKey.set(item, key)\n\t\tkeys.push(key)\n\t}\n\tnode.value = value\n\tnode.flags = FLAG_DIRTY // First refresh() will establish child edges\n\n\tfunction subscribe(): void {\n\t\tif (activeSink) {\n\t\t\tif (!node.sinks)\n\t\t\t\tnode.stop = watched((changes: CollectionChanges<T>): void => {\n\t\t\t\t\tconst { add, change, remove } = changes\n\t\t\t\t\tif (!add?.length && !change?.length && !remove?.length)\n\t\t\t\t\t\treturn\n\t\t\t\t\tlet structural = false\n\n\t\t\t\t\tbatch(() => {\n\t\t\t\t\t\t// Additions\n\t\t\t\t\t\tif (add) {\n\t\t\t\t\t\t\tfor (const item of add) {\n\t\t\t\t\t\t\t\tconst key = generateKey(item)\n\t\t\t\t\t\t\t\tsignals.set(key, itemFactory(item))\n\t\t\t\t\t\t\t\titemToKey.set(item, key)\n\t\t\t\t\t\t\t\tif (!keys.includes(key)) keys.push(key)\n\t\t\t\t\t\t\t\tstructural = true\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Changes — only for State signals\n\t\t\t\t\t\tif (change) {\n\t\t\t\t\t\t\tfor (const item of change) {\n\t\t\t\t\t\t\t\tconst key = resolveKey(item)\n\t\t\t\t\t\t\t\tif (!key) continue\n\t\t\t\t\t\t\t\tconst signal = signals.get(key)\n\t\t\t\t\t\t\t\tif (signal && isState(signal)) {\n\t\t\t\t\t\t\t\t\t// Update reverse map: remove old reference, add new\n\t\t\t\t\t\t\t\t\titemToKey.delete(signal.get())\n\t\t\t\t\t\t\t\t\tsignal.set(item)\n\t\t\t\t\t\t\t\t\titemToKey.set(item, key)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Removals\n\t\t\t\t\t\tif (remove) {\n\t\t\t\t\t\t\tfor (const item of remove) {\n\t\t\t\t\t\t\t\tconst key = resolveKey(item)\n\t\t\t\t\t\t\t\tif (!key) continue\n\t\t\t\t\t\t\t\titemToKey.delete(item)\n\t\t\t\t\t\t\t\tsignals.delete(key)\n\t\t\t\t\t\t\t\tconst index = keys.indexOf(key)\n\t\t\t\t\t\t\t\tif (index !== -1) keys.splice(index, 1)\n\t\t\t\t\t\t\t\tstructural = true\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Mark DIRTY so next get() rebuilds; propagate to sinks\n\t\t\t\t\t\tnode.flags = FLAG_DIRTY | (structural ? FLAG_RELINK : 0)\n\t\t\t\t\t\tfor (let e = node.sinks; e; e = e.nextSink)\n\t\t\t\t\t\t\tpropagate(e.sink)\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\tlink(node, activeSink)\n\t\t}\n\t}\n\n\tconst collection: Collection<T> = {\n\t\t[Symbol.toStringTag]: TYPE_COLLECTION,\n\t\t[Symbol.isConcatSpreadable]: true as const,\n\n\t\t*[Symbol.iterator]() {\n\t\t\tfor (const key of keys) {\n\t\t\t\tconst signal = signals.get(key)\n\t\t\t\tif (signal) yield signal\n\t\t\t}\n\t\t},\n\n\t\tget length() {\n\t\t\tsubscribe()\n\t\t\treturn keys.length\n\t\t},\n\n\t\tkeys() {\n\t\t\tsubscribe()\n\t\t\treturn keys.values()\n\t\t},\n\n\t\tget() {\n\t\t\tsubscribe()\n\t\t\tif (node.sources) {\n\t\t\t\tif (node.flags) {\n\t\t\t\t\tconst relink = node.flags & FLAG_RELINK\n\t\t\t\t\tnode.value = untrack(buildValue)\n\t\t\t\t\tif (relink) {\n\t\t\t\t\t\t// Structural mutation added/removed child signals —\n\t\t\t\t\t\t// tracked recompute so link() adds new edges and\n\t\t\t\t\t\t// trimSources() removes stale ones without orphaning.\n\t\t\t\t\t\tnode.flags = FLAG_DIRTY\n\t\t\t\t\t\trefresh(node as unknown as SinkNode)\n\t\t\t\t\t\tif (node.error) throw node.error\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnode.flags = FLAG_CLEAN\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trefresh(node as unknown as SinkNode)\n\t\t\t\tif (node.error) throw node.error\n\t\t\t}\n\t\t\treturn node.value\n\t\t},\n\n\t\tat(index: number) {\n\t\t\treturn signals.get(keys[index])\n\t\t},\n\n\t\tbyKey(key: string) {\n\t\t\treturn signals.get(key)\n\t\t},\n\n\t\tkeyAt(index: number) {\n\t\t\treturn keys[index]\n\t\t},\n\n\t\tindexOfKey(key: string) {\n\t\t\treturn keys.indexOf(key)\n\t\t},\n\n\t\tderiveCollection<R extends {}>(\n\t\t\tcb: DeriveCollectionCallback<R, T>,\n\t\t): Collection<R> {\n\t\t\treturn (\n\t\t\t\tderiveCollection as <T2 extends {}, U2 extends {}>(\n\t\t\t\t\tsource: CollectionSource<U2>,\n\t\t\t\t\tcallback: DeriveCollectionCallback<T2, U2>,\n\t\t\t\t) => Collection<T2>\n\t\t\t)(collection, cb)\n\t\t},\n\t}\n\n\treturn collection\n}\n\n/**\n * Checks if a value is a Collection signal.\n *\n * @since 0.17.2\n * @param value - The value to check\n * @returns True if the value is a Collection\n */\nfunction isCollection<T extends {}>(value: unknown): value is Collection<T> {\n\treturn isObjectOfType(value, TYPE_COLLECTION)\n}\n\n/**\n * Checks if a value is a valid Collection source (List or Collection).\n *\n * @since 0.17.2\n * @param value - The value to check\n * @returns True if the value is a List or Collection\n */\nfunction isCollectionSource<T extends {}>(\n\tvalue: unknown,\n): value is CollectionSource<T> {\n\treturn isList(value) || isCollection(value)\n}\n\n/* === Exports === */\n\nexport {\n\tcreateCollection,\n\tderiveCollection,\n\tisCollection,\n\tisCollectionSource,\n\ttype Collection,\n\ttype CollectionCallback,\n\ttype CollectionChanges,\n\ttype CollectionOptions,\n\ttype CollectionSource,\n\ttype DeriveCollectionCallback,\n}\n",
    "import {\n\tRequiredOwnerError,\n\tUnsetSignalValueError,\n\tvalidateCallback,\n} from '../errors'\nimport {\n\tactiveOwner,\n\ttype Cleanup,\n\ttype EffectCallback,\n\ttype EffectNode,\n\tFLAG_CLEAN,\n\tFLAG_DIRTY,\n\ttype MaybeCleanup,\n\tregisterCleanup,\n\trunCleanup,\n\trunEffect,\n\ttype Signal,\n\ttrimSources,\n} from '../graph'\n\n/* === Types === */\n\ntype MaybePromise<T> = T | Promise<T>\n\ntype MatchHandlers<T extends readonly Signal<unknown & {}>[]> = {\n\tok: (values: {\n\t\t[K in keyof T]: T[K] extends Signal<infer V> ? V : never\n\t}) => MaybePromise<MaybeCleanup>\n\terr?: (errors: readonly Error[]) => MaybePromise<MaybeCleanup>\n\tnil?: () => MaybePromise<MaybeCleanup>\n}\n\n/* === Exported Functions === */\n\n/**\n * Creates a reactive effect that automatically runs when its dependencies change.\n * Effects run immediately upon creation and re-run when any tracked signal changes.\n * Effects are executed during the flush phase, after all updates have been batched.\n *\n * @since 0.1.0\n * @param fn - The effect function that can track dependencies and register cleanup callbacks\n * @returns A cleanup function that can be called to dispose of the effect\n *\n * @example\n * ```ts\n * const count = createState(0);\n * const dispose = createEffect(() => {\n *   console.log('Count is:', count.get());\n * });\n *\n * count.set(1); // Logs: \"Count is: 1\"\n * dispose(); // Stop the effect\n * ```\n *\n * @example\n * ```ts\n * // With cleanup\n * createEffect(() => {\n *   const timer = setInterval(() => console.log(count.get()), 1000);\n *   return () => clearInterval(timer);\n * });\n * ```\n */\nfunction createEffect(fn: EffectCallback): Cleanup {\n\tvalidateCallback('Effect', fn)\n\n\tconst node: EffectNode = {\n\t\tfn,\n\t\tflags: FLAG_DIRTY,\n\t\tsources: null,\n\t\tsourcesTail: null,\n\t\tcleanup: null,\n\t}\n\n\tconst dispose = () => {\n\t\trunCleanup(node)\n\t\tnode.fn = undefined as unknown as EffectCallback\n\t\tnode.flags = FLAG_CLEAN\n\t\tnode.sourcesTail = null\n\t\ttrimSources(node)\n\t}\n\n\tif (activeOwner) registerCleanup(activeOwner, dispose)\n\n\trunEffect(node)\n\n\treturn dispose\n}\n\n/**\n * Runs handlers based on the current values of signals.\n * Must be called within an active owner (effect or scope) so async cleanup can be registered.\n *\n * @since 0.15.0\n * @throws RequiredOwnerError If called without an active owner.\n */\nfunction match<T extends readonly Signal<unknown & {}>[]>(\n\tsignals: readonly [...T],\n\thandlers: MatchHandlers<T>,\n): MaybeCleanup {\n\tif (!activeOwner) throw new RequiredOwnerError('match')\n\tconst { ok, err = console.error, nil } = handlers\n\tlet errors: Error[] | undefined\n\tlet pending = false\n\tconst values = new Array(signals.length)\n\n\tfor (let i = 0; i < signals.length; i++) {\n\t\ttry {\n\t\t\tvalues[i] = signals[i].get()\n\t\t} catch (e) {\n\t\t\tif (e instanceof UnsetSignalValueError) {\n\t\t\t\tpending = true\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif (!errors) errors = []\n\t\t\terrors.push(e instanceof Error ? e : new Error(String(e)))\n\t\t}\n\t}\n\n\tlet out: MaybePromise<MaybeCleanup>\n\ttry {\n\t\tif (pending) out = nil?.()\n\t\telse if (errors) out = err(errors)\n\t\telse\n\t\t\tout = ok(\n\t\t\t\tvalues as {\n\t\t\t\t\t[K in keyof T]: T[K] extends Signal<infer V> ? V : never\n\t\t\t\t},\n\t\t\t)\n\t} catch (e) {\n\t\terr([e instanceof Error ? e : new Error(String(e))])\n\t}\n\n\tif (typeof out === 'function') return out\n\n\tif (out instanceof Promise) {\n\t\tconst owner = activeOwner\n\t\tconst controller = new AbortController()\n\t\tregisterCleanup(owner, () => controller.abort())\n\t\tout.then(cleanup => {\n\t\t\tif (!controller.signal.aborted && typeof cleanup === 'function')\n\t\t\t\tregisterCleanup(owner, cleanup)\n\t\t}).catch(e => {\n\t\t\terr([e instanceof Error ? e : new Error(String(e))])\n\t\t})\n\t}\n}\n\nexport { type MaybePromise, type MatchHandlers, createEffect, match }\n",
    "import {\n\tvalidateCallback,\n\tvalidateReadValue,\n\tvalidateSignalValue,\n} from '../errors'\nimport {\n\tactiveSink,\n\ttype Cleanup,\n\tDEFAULT_EQUALITY,\n\tlink,\n\ttype SignalOptions,\n\ttype StateNode,\n\tsetState,\n\tTYPE_SENSOR,\n} from '../graph'\nimport { isObjectOfType, isSyncFunction } from '../util'\n\n/* === Types === */\n\n/**\n * A read-only signal that tracks external input and updates a state value as long as it is active.\n *\n * @template T - The type of value produced by the sensor\n */\ntype Sensor<T extends {}> = {\n\treadonly [Symbol.toStringTag]: 'Sensor'\n\n\t/**\n\t * Gets the current value of the sensor.\n\t * When called inside another reactive context, creates a dependency.\n\t * @returns The sensor value\n\t * @throws UnsetSignalValueError If the sensor value is still unset when read.\n\t */\n\tget(): T\n}\n\n/**\n * A callback function for sensors when the sensor starts being watched.\n *\n * @template T - The type of value observed\n * @param set - A function to set the observed value\n * @returns A cleanup function when the sensor stops being watched\n */\ntype SensorOptions<T extends {}> = SignalOptions<T> & {\n\t/**\n\t * Optional initial value. Avoids `UnsetSignalValueError` on first read\n\t * before the watched callback fires.\n\t */\n\tvalue?: T\n}\n\ntype SensorCallback<T extends {}> = (set: (next: T) => void) => Cleanup\n\n/* === Exported Functions === */\n\n/**\n * Creates a sensor that tracks external input and updates a state value as long as it is active.\n * Sensors get activated when they are first accessed by an effect and deactivated when they are\n * no longer watched. This lazy activation pattern ensures resources are only consumed when needed.\n *\n * @since 0.18.0\n * @template T - The type of value produced by the sensor\n * @param watched - The callback invoked when the sensor starts being watched, receives a `set` function and returns a cleanup function.\n * @param options - Optional configuration for the sensor.\n * @param options.value - Optional initial value. Avoids `UnsetSignalValueError` on first read\n *   before the watched callback fires. Essential for the mutable-object observation pattern.\n * @param options.equals - Optional equality function. Defaults to strict equality (`===`). Use `SKIP_EQUALITY`\n *   for mutable objects where the reference stays the same but internal state changes.\n * @param options.guard - Optional type guard to validate values.\n * @returns A read-only sensor signal.\n *\n * @example Tracking external values\n * ```ts\n * const mousePos = createSensor<{ x: number; y: number }>((set) => {\n *   const handler = (e: MouseEvent) => {\n *     set({ x: e.clientX, y: e.clientY });\n *   };\n *   window.addEventListener('mousemove', handler);\n *   return () => window.removeEventListener('mousemove', handler);\n * });\n * ```\n *\n * @example Observing a mutable object\n * ```ts\n * import { createSensor, SKIP_EQUALITY } from 'cause-effect';\n *\n * const el = createSensor<HTMLElement>((set) => {\n *   const node = document.getElementById('box')!;\n *   set(node);\n *   const obs = new MutationObserver(() => set(node));\n *   obs.observe(node, { attributes: true });\n *   return () => obs.disconnect();\n * }, { value: node, equals: SKIP_EQUALITY });\n * ```\n */\nfunction createSensor<T extends {}>(\n\twatched: SensorCallback<T>,\n\toptions?: SensorOptions<T>,\n): Sensor<T> {\n\tvalidateCallback(TYPE_SENSOR, watched, isSyncFunction)\n\tif (options?.value !== undefined)\n\t\tvalidateSignalValue(TYPE_SENSOR, options.value, options?.guard)\n\n\tconst node: StateNode<T> = {\n\t\tvalue: options?.value as T,\n\t\tsinks: null,\n\t\tsinksTail: null,\n\t\tequals: options?.equals ?? DEFAULT_EQUALITY,\n\t\tguard: options?.guard,\n\t\tstop: undefined,\n\t}\n\n\treturn {\n\t\t[Symbol.toStringTag]: TYPE_SENSOR,\n\t\tget(): T {\n\t\t\tif (activeSink) {\n\t\t\t\tif (!node.sinks)\n\t\t\t\t\tnode.stop = watched((next: T): void => {\n\t\t\t\t\t\tvalidateSignalValue(TYPE_SENSOR, next, node.guard)\n\t\t\t\t\t\tsetState(node, next)\n\t\t\t\t\t})\n\t\t\t\tlink(node, activeSink)\n\t\t\t}\n\t\t\tvalidateReadValue(TYPE_SENSOR, node.value)\n\t\t\treturn node.value\n\t\t},\n\t}\n}\n\n/**\n * Checks if a value is a Sensor signal.\n *\n * @since 0.18.0\n * @param value - The value to check\n * @returns True if the value is a Sensor\n */\nfunction isSensor<T extends {} = unknown & {}>(\n\tvalue: unknown,\n): value is Sensor<T> {\n\treturn isObjectOfType(value, TYPE_SENSOR)\n}\n\nexport {\n\tcreateSensor,\n\tisSensor,\n\ttype Sensor,\n\ttype SensorCallback,\n\ttype SensorOptions,\n}\n",
    "import { DuplicateKeyError, validateSignalValue } from '../errors'\nimport {\n\tactiveSink,\n\tbatch,\n\tbatchDepth,\n\ttype Cleanup,\n\tFLAG_CLEAN,\n\tFLAG_DIRTY,\n\tFLAG_RELINK,\n\tflush,\n\tlink,\n\ttype MemoNode,\n\tpropagate,\n\trefresh,\n\ttype SinkNode,\n\tTYPE_STORE,\n\tuntrack,\n} from '../graph'\nimport { isObjectOfType, isRecord } from '../util'\nimport {\n\tcreateList,\n\ttype DiffResult,\n\tisEqual,\n\ttype List,\n\ttype UnknownRecord,\n} from './list'\nimport { createState, type State } from './state'\n\n/* === Types === */\n\ntype StoreOptions = {\n\twatched?: () => Cleanup\n}\n\ntype BaseStore<T extends UnknownRecord> = {\n\treadonly [Symbol.toStringTag]: 'Store'\n\treadonly [Symbol.isConcatSpreadable]: false\n\t[Symbol.iterator](): IterableIterator<\n\t\t[\n\t\t\tstring,\n\t\t\tState<T[keyof T] & {}> | Store<UnknownRecord> | List<unknown & {}>,\n\t\t]\n\t>\n\tkeys(): IterableIterator<string>\n\tbyKey<K extends keyof T & string>(\n\t\tkey: K,\n\t): T[K] extends readonly (infer U extends {})[]\n\t\t? List<U>\n\t\t: T[K] extends UnknownRecord\n\t\t\t? Store<T[K]>\n\t\t\t: T[K] extends unknown & {}\n\t\t\t\t? State<T[K] & {}>\n\t\t\t\t: State<T[K] & {}> | undefined\n\tget(): T\n\tset(next: T): void\n\tupdate(fn: (prev: T) => T): void\n\tadd<K extends keyof T & string>(key: K, value: T[K]): K\n\tremove(key: string): void\n}\n\ntype Store<T extends UnknownRecord> = BaseStore<T> & {\n\t[K in keyof T]: T[K] extends readonly (infer U extends {})[]\n\t\t? List<U>\n\t\t: T[K] extends UnknownRecord\n\t\t\t? Store<T[K]>\n\t\t\t: T[K] extends unknown & {}\n\t\t\t\t? State<T[K] & {}>\n\t\t\t\t: State<T[K] & {}> | undefined\n}\n\n/* === Functions === */\n\n/** Diff two records and return granular changes */\nfunction diffRecords<T extends UnknownRecord>(prev: T, next: T): DiffResult {\n\t// Guard against non-objects that can't be diffed properly with Object.keys and 'in' operator\n\tconst prevValid = isRecord(prev) || Array.isArray(prev)\n\tconst nextValid = isRecord(next) || Array.isArray(next)\n\tif (!prevValid || !nextValid) {\n\t\t// For non-objects or non-plain objects, treat as complete change if different\n\t\tconst changed = !Object.is(prev, next)\n\t\treturn {\n\t\t\tchanged,\n\t\t\tadd: changed && nextValid ? next : {},\n\t\t\tchange: {},\n\t\t\tremove: changed && prevValid ? prev : {},\n\t\t}\n\t}\n\n\tconst visited = new WeakSet()\n\n\tconst add = {} as UnknownRecord\n\tconst change = {} as UnknownRecord\n\tconst remove = {} as UnknownRecord\n\tlet changed = false\n\n\tconst prevKeys = Object.keys(prev)\n\tconst nextKeys = Object.keys(next)\n\n\t// Pass 1: iterate new keys — find additions and changes\n\tfor (const key of nextKeys) {\n\t\tif (key in prev) {\n\t\t\tif (!isEqual(prev[key], next[key], visited)) {\n\t\t\t\tchange[key] = next[key]\n\t\t\t\tchanged = true\n\t\t\t}\n\t\t} else {\n\t\t\tadd[key] = next[key]\n\t\t\tchanged = true\n\t\t}\n\t}\n\n\t// Pass 2: iterate old keys — find removals\n\tfor (const key of prevKeys) {\n\t\tif (!(key in next)) {\n\t\t\tremove[key] = undefined\n\t\t\tchanged = true\n\t\t}\n\t}\n\n\treturn { add, change, remove, changed }\n}\n\n/**\n * Creates a reactive store with deeply nested reactive properties.\n * Each property becomes its own signal (State for primitives, nested Store for objects, List for arrays).\n * Properties are accessible directly via proxy.\n *\n * @since 0.15.0\n * @param value - Initial object value of the store\n * @param options - Optional configuration for watch lifecycle\n * @returns A Store with reactive properties\n *\n * @example\n * ```ts\n * const user = createStore({ name: 'Alice', age: 30 });\n * user.name.set('Bob'); // Only name subscribers react\n * console.log(user.get()); // { name: 'Bob', age: 30 }\n * ```\n */\nfunction createStore<T extends UnknownRecord>(\n\tvalue: T,\n\toptions?: StoreOptions,\n): Store<T> {\n\tvalidateSignalValue(TYPE_STORE, value, isRecord)\n\n\tconst signals = new Map<\n\t\tstring,\n\t\tState<unknown & {}> | Store<UnknownRecord> | List<unknown & {}>\n\t>()\n\n\t// --- Internal helpers ---\n\n\tconst addSignal = (key: string, val: unknown): void => {\n\t\tvalidateSignalValue(`${TYPE_STORE} for key \"${key}\"`, val)\n\t\tif (Array.isArray(val)) signals.set(key, createList(val))\n\t\telse if (isRecord(val)) signals.set(key, createStore(val))\n\t\telse signals.set(key, createState(val as unknown & {}))\n\t}\n\n\t// Build current value from child signals\n\tconst buildValue = (): T => {\n\t\tconst record = {} as UnknownRecord\n\t\tsignals.forEach((signal, key) => {\n\t\t\trecord[key] = signal.get()\n\t\t})\n\t\treturn record as T\n\t}\n\n\t// Structural tracking node — not a general-purpose Memo.\n\t// On first get(): refresh() establishes edges from child signals.\n\t// On subsequent get(): untrack(buildValue) rebuilds without re-linking.\n\t// Mutation methods set FLAG_RELINK to force re-establishment on next read.\n\tconst node: MemoNode<T> = {\n\t\tfn: buildValue,\n\t\tvalue,\n\t\tflags: FLAG_DIRTY,\n\t\tsources: null,\n\t\tsourcesTail: null,\n\t\tsinks: null,\n\t\tsinksTail: null,\n\t\tequals: isEqual,\n\t\terror: undefined,\n\t}\n\n\tconst applyChanges = (changes: DiffResult): boolean => {\n\t\tlet structural = false\n\n\t\t// Additions\n\t\tfor (const key in changes.add) {\n\t\t\taddSignal(key, changes.add[key])\n\t\t\tstructural = true\n\t\t}\n\n\t\t// Changes\n\t\tif (Object.keys(changes.change).length) {\n\t\t\tbatch(() => {\n\t\t\t\tfor (const key in changes.change) {\n\t\t\t\t\tconst val = changes.change[key]\n\t\t\t\t\tvalidateSignalValue(`${TYPE_STORE} for key \"${key}\"`, val)\n\t\t\t\t\tconst signal = signals.get(key)\n\t\t\t\t\tif (signal) {\n\t\t\t\t\t\t// Type changed (e.g. primitive → object or vice versa): replace signal\n\t\t\t\t\t\tif (isRecord(val) !== isStore(signal)) {\n\t\t\t\t\t\t\taddSignal(key, val)\n\t\t\t\t\t\t\tstructural = true\n\t\t\t\t\t\t} else signal.set(val as never)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t\t// Removals\n\t\tfor (const key in changes.remove) {\n\t\t\tsignals.delete(key)\n\t\t\tstructural = true\n\t\t}\n\n\t\tif (structural) node.flags |= FLAG_RELINK\n\n\t\treturn changes.changed\n\t}\n\n\tconst watched = options?.watched\n\tconst subscribe = watched\n\t\t? () => {\n\t\t\t\tif (activeSink) {\n\t\t\t\t\tif (!node.sinks) node.stop = watched()\n\t\t\t\t\tlink(node, activeSink)\n\t\t\t\t}\n\t\t\t}\n\t\t: () => {\n\t\t\t\tif (activeSink) link(node, activeSink)\n\t\t\t}\n\n\t// --- Initialize ---\n\tfor (const key of Object.keys(value)) addSignal(key, value[key])\n\n\t// --- Store object ---\n\tconst store: BaseStore<T> = {\n\t\t[Symbol.toStringTag]: TYPE_STORE,\n\t\t[Symbol.isConcatSpreadable]: false as const,\n\n\t\t*[Symbol.iterator]() {\n\t\t\tfor (const key of Array.from(signals.keys())) {\n\t\t\t\tconst signal = signals.get(key)\n\t\t\t\tif (signal)\n\t\t\t\t\tyield [key, signal] as [\n\t\t\t\t\t\tstring,\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\t| State<T[keyof T] & {}>\n\t\t\t\t\t\t\t| Store<UnknownRecord>\n\t\t\t\t\t\t\t| List<unknown & {}>\n\t\t\t\t\t\t),\n\t\t\t\t\t]\n\t\t\t}\n\t\t},\n\n\t\tkeys() {\n\t\t\tsubscribe()\n\t\t\treturn signals.keys()\n\t\t},\n\n\t\tbyKey<K extends keyof T & string>(key: K) {\n\t\t\treturn signals.get(key) as T[K] extends readonly (infer U extends\n\t\t\t\t{})[]\n\t\t\t\t? List<U>\n\t\t\t\t: T[K] extends UnknownRecord\n\t\t\t\t\t? Store<T[K]>\n\t\t\t\t\t: T[K] extends unknown & {}\n\t\t\t\t\t\t? State<T[K] & {}>\n\t\t\t\t\t\t: State<T[K] & {}> | undefined\n\t\t},\n\n\t\tget() {\n\t\t\tsubscribe()\n\t\t\tif (node.sources) {\n\t\t\t\t// Fast path: edges already established, rebuild value directly\n\t\t\t\t// from child signals using untrack to avoid creating spurious\n\t\t\t\t// edges to the current effect/memo consumer\n\t\t\t\tif (node.flags) {\n\t\t\t\t\tconst relink = node.flags & FLAG_RELINK\n\t\t\t\t\tnode.value = untrack(buildValue)\n\t\t\t\t\tif (relink) {\n\t\t\t\t\t\t// Structural mutation added/removed child signals —\n\t\t\t\t\t\t// tracked recompute so link() adds new edges and\n\t\t\t\t\t\t// trimSources() removes stale ones without orphaning.\n\t\t\t\t\t\tnode.flags = FLAG_DIRTY\n\t\t\t\t\t\trefresh(node as unknown as SinkNode)\n\t\t\t\t\t\tif (node.error) throw node.error\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnode.flags = FLAG_CLEAN\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// First access: use refresh() to establish child → store edges\n\t\t\t\trefresh(node as unknown as SinkNode)\n\t\t\t\tif (node.error) throw node.error\n\t\t\t}\n\t\t\treturn node.value\n\t\t},\n\n\t\tset(next: T) {\n\t\t\t// Use cached value if clean, recompute if dirty\n\t\t\tconst prev = node.flags & FLAG_DIRTY ? buildValue() : node.value\n\n\t\t\tconst changes = diffRecords(prev, next)\n\t\t\tif (applyChanges(changes)) {\n\t\t\t\tnode.flags |= FLAG_DIRTY\n\t\t\t\tfor (let e = node.sinks; e; e = e.nextSink) propagate(e.sink)\n\t\t\t\tif (batchDepth === 0) flush()\n\t\t\t}\n\t\t},\n\n\t\tupdate(fn: (prev: T) => T) {\n\t\t\tstore.set(fn(store.get()))\n\t\t},\n\n\t\tadd<K extends keyof T & string>(key: K, value: T[K]) {\n\t\t\tif (signals.has(key))\n\t\t\t\tthrow new DuplicateKeyError(TYPE_STORE, key, value)\n\t\t\taddSignal(key, value)\n\t\t\tnode.flags |= FLAG_DIRTY | FLAG_RELINK\n\t\t\tfor (let e = node.sinks; e; e = e.nextSink) propagate(e.sink)\n\t\t\tif (batchDepth === 0) flush()\n\t\t\treturn key\n\t\t},\n\n\t\tremove(key: string) {\n\t\t\tconst ok = signals.delete(key)\n\t\t\tif (ok) {\n\t\t\t\tnode.flags |= FLAG_DIRTY | FLAG_RELINK\n\t\t\t\tfor (let e = node.sinks; e; e = e.nextSink) propagate(e.sink)\n\t\t\t\tif (batchDepth === 0) flush()\n\t\t\t}\n\t\t},\n\t}\n\n\t// --- Proxy ---\n\treturn new Proxy(store, {\n\t\tget(target, prop) {\n\t\t\tif (prop in target) return Reflect.get(target, prop)\n\t\t\tif (typeof prop !== 'symbol')\n\t\t\t\treturn target.byKey(prop as keyof T & string)\n\t\t},\n\t\thas(target, prop) {\n\t\t\tif (prop in target) return true\n\t\t\treturn target.byKey(String(prop) as keyof T & string) !== undefined\n\t\t},\n\t\townKeys(target) {\n\t\t\treturn Array.from(target.keys())\n\t\t},\n\t\tgetOwnPropertyDescriptor(target, prop) {\n\t\t\tif (prop in target)\n\t\t\t\treturn Reflect.getOwnPropertyDescriptor(target, prop)\n\t\t\tif (typeof prop === 'symbol') return undefined\n\t\t\tconst signal = target.byKey(String(prop) as keyof T & string)\n\t\t\treturn signal\n\t\t\t\t? {\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\twritable: true,\n\t\t\t\t\t\tvalue: signal,\n\t\t\t\t\t}\n\t\t\t\t: undefined\n\t\t},\n\t}) as Store<T>\n}\n\n/**\n * Checks if a value is a Store signal.\n *\n * @since 0.15.0\n * @param value - The value to check\n * @returns True if the value is a Store\n */\nfunction isStore<T extends UnknownRecord>(value: unknown): value is Store<T> {\n\treturn isObjectOfType(value, TYPE_STORE)\n}\n\n/* === Exports === */\n\nexport { createStore, isStore, type Store, type StoreOptions, TYPE_STORE }\n",
    "import { InvalidSignalValueError } from './errors'\nimport {\n\ttype ComputedOptions,\n\ttype MemoCallback,\n\ttype Signal,\n\ttype TaskCallback,\n\tTYPE_COLLECTION,\n\tTYPE_LIST,\n\tTYPE_MEMO,\n\tTYPE_SENSOR,\n\tTYPE_SLOT,\n\tTYPE_STATE,\n\tTYPE_STORE,\n\tTYPE_TASK,\n} from './graph'\nimport { createList, isList, type List, type UnknownRecord } from './nodes/list'\nimport { createMemo, isMemo, type Memo } from './nodes/memo'\nimport { createState, isState, type State } from './nodes/state'\nimport { createStore, isStore, type Store } from './nodes/store'\nimport { createTask, isTask, type Task } from './nodes/task'\nimport { isAsyncFunction, isFunction, isRecord, isUniformArray } from './util'\n\n/* === Types === */\n\ntype MutableSignal<T extends {}> = {\n\tget(): T\n\tset(value: T): void\n\tupdate(callback: (value: T) => T): void\n}\n\n/* === Factory Functions === */\n\n/**\n * Create a derived signal from existing signals\n *\n * @since 0.9.0\n * @param callback - Computation callback function\n * @param options - Optional configuration\n */\nfunction createComputed<T extends {}>(\n\tcallback: TaskCallback<T>,\n\toptions?: ComputedOptions<T>,\n): Task<T>\nfunction createComputed<T extends {}>(\n\tcallback: MemoCallback<T>,\n\toptions?: ComputedOptions<T>,\n): Memo<T>\nfunction createComputed<T extends {}>(\n\tcallback: TaskCallback<T> | MemoCallback<T>,\n\toptions?: ComputedOptions<T>,\n): Memo<T> | Task<T> {\n\treturn isAsyncFunction(callback)\n\t\t? createTask(callback as TaskCallback<T>, options)\n\t\t: createMemo(callback as MemoCallback<T>, options)\n}\n\n/**\n * Convert a value to a Signal.\n *\n * @since 0.9.6\n */\nfunction createSignal<T extends {}>(value: Signal<T>): Signal<T>\nfunction createSignal<T extends {}>(value: readonly T[]): List<T>\nfunction createSignal<T extends UnknownRecord>(value: T): Store<T>\nfunction createSignal<T extends {}>(value: TaskCallback<T>): Task<T>\nfunction createSignal<T extends {}>(value: MemoCallback<T>): Memo<T>\nfunction createSignal<T extends {}>(value: T): State<T>\nfunction createSignal(value: unknown): unknown {\n\tif (isSignal(value)) return value\n\tif (value == null) throw new InvalidSignalValueError('createSignal', value)\n\tif (isAsyncFunction(value))\n\t\treturn createTask(value as TaskCallback<unknown & {}>)\n\tif (isFunction(value))\n\t\treturn createMemo(value as MemoCallback<unknown & {}>)\n\tif (isUniformArray<unknown & {}>(value)) return createList(value)\n\tif (isRecord(value)) return createStore(value)\n\treturn createState(value as unknown & {})\n}\n\n/**\n * Convert a value to a MutableSignal.\n *\n * @since 0.17.0\n */\nfunction createMutableSignal<T extends {}>(\n\tvalue: MutableSignal<T>,\n): MutableSignal<T>\nfunction createMutableSignal<T extends {}>(value: readonly T[]): List<T>\nfunction createMutableSignal<T extends UnknownRecord>(value: T): Store<T>\nfunction createMutableSignal<T extends {}>(value: T): State<T>\nfunction createMutableSignal(value: unknown): unknown {\n\tif (isMutableSignal(value)) return value\n\tif (value == null || isFunction(value) || isSignal(value))\n\t\tthrow new InvalidSignalValueError('createMutableSignal', value)\n\tif (isUniformArray<unknown & {}>(value)) return createList(value)\n\tif (isRecord(value)) return createStore(value)\n\treturn createState(value as unknown & {})\n}\n\n/* === Guards === */\n\n/**\n * Check if a value is a computed signal\n *\n * @since 0.9.0\n * @param value - Value to check\n * @returns True if value is a computed signal, false otherwise\n */\nfunction isComputed<T extends {}>(value: unknown): value is Memo<T> {\n\treturn isMemo(value) || isTask(value)\n}\n\n/**\n * Check whether a value is a Signal\n *\n * @since 0.9.0\n * @param value - Value to check\n * @returns True if value is a Signal, false otherwise\n */\nfunction isSignal<T extends {}>(value: unknown): value is Signal<T> {\n\tconst signalsTypes = [\n\t\tTYPE_STATE,\n\t\tTYPE_MEMO,\n\t\tTYPE_TASK,\n\t\tTYPE_SENSOR,\n\t\tTYPE_SLOT,\n\t\tTYPE_LIST,\n\t\tTYPE_COLLECTION,\n\t\tTYPE_STORE,\n\t]\n\tconst typeStyle = Object.prototype.toString.call(value).slice(8, -1)\n\treturn signalsTypes.includes(typeStyle)\n}\n\n/**\n * Check whether a value is a State, Store, or List\n *\n * @since 0.15.2\n * @param value - Value to check\n * @returns True if value is a State, Store, or List, false otherwise\n */\nfunction isMutableSignal(value: unknown): value is MutableSignal<unknown & {}> {\n\treturn isState(value) || isStore(value) || isList(value)\n}\n\nexport {\n\ttype MutableSignal,\n\tcreateComputed,\n\tcreateSignal,\n\tcreateMutableSignal,\n\tisComputed,\n\tisSignal,\n\tisMutableSignal,\n}\n",
    "import { ReadonlySignalError, validateSignalValue } from '../errors'\nimport {\n\tactiveSink,\n\tbatchDepth,\n\tDEFAULT_EQUALITY,\n\tFLAG_DIRTY,\n\tflush,\n\tlink,\n\ttype MemoNode,\n\tpropagate,\n\trefresh,\n\ttype Signal,\n\ttype SignalOptions,\n\ttype SinkNode,\n\tTYPE_SLOT,\n} from '../graph'\nimport { isMutableSignal, isSignal } from '../signal'\nimport { isObjectOfType } from '../util'\n\n/* === Types === */\n\n/**\n * A signal that delegates its value to a swappable backing signal.\n *\n * Slots provide a stable reactive source at a fixed position (e.g. an object property)\n * while allowing the backing signal to be replaced without breaking subscribers.\n * The object shape is compatible with `Object.defineProperty()` descriptors:\n * `get`, `set`, `configurable`, and `enumerable` are used by the property definition;\n * `replace()` and `current()` are kept on the slot object for integration-layer control.\n *\n * @template T - The type of value held by the delegated signal.\n */\ntype Slot<T extends {}> = {\n\treadonly [Symbol.toStringTag]: 'Slot'\n\t/** Descriptor field: allows the property to be redefined or deleted. */\n\tconfigurable: true\n\t/** Descriptor field: the property shows up during enumeration. */\n\tenumerable: true\n\t/** Reads the current value from the delegated signal, tracking dependencies. */\n\tget(): T\n\t/** Writes a value to the delegated signal. Throws `ReadonlySignalError` if the delegated signal is read-only. */\n\tset(next: T): void\n\t/** Swaps the backing signal, invalidating all downstream subscribers. Narrowing (`U extends T`) is allowed. */\n\treplace<U extends T>(next: Signal<U>): void\n\t/** Returns the currently delegated signal. */\n\tcurrent(): Signal<T>\n}\n\n/* === Exported Functions === */\n\n/**\n * Creates a slot signal that delegates its value to a swappable backing signal.\n *\n * A slot acts as a stable reactive source that can be used as a property descriptor\n * via `Object.defineProperty(target, key, slot)`. Subscribers link to the slot itself,\n * so replacing the backing signal with `replace()` invalidates them without breaking\n * existing edges. Setter calls forward to the current backing signal when it is writable.\n *\n * @since 0.18.3\n * @template T - The type of value held by the delegated signal.\n * @param initialSignal - The initial signal to delegate to.\n * @param options - Optional configuration for the slot.\n * @param options.equals - Custom equality function. Defaults to strict equality (`===`).\n * @param options.guard - Type guard to validate values passed to `set()`.\n * @returns A `Slot<T>` object usable both as a property descriptor and as a reactive signal.\n */\nfunction createSlot<T extends {}>(\n\tinitialSignal: Signal<T>,\n\toptions?: SignalOptions<T>,\n): Slot<T> {\n\tvalidateSignalValue(TYPE_SLOT, initialSignal, isSignal)\n\n\tlet delegated = initialSignal as Signal<T>\n\tconst guard = options?.guard\n\n\tconst node: MemoNode<T> = {\n\t\tfn: () => delegated.get(),\n\t\tvalue: undefined as unknown as T,\n\t\tflags: FLAG_DIRTY,\n\t\tsources: null,\n\t\tsourcesTail: null,\n\t\tsinks: null,\n\t\tsinksTail: null,\n\t\tequals: options?.equals ?? DEFAULT_EQUALITY,\n\t\terror: undefined,\n\t}\n\n\tconst get = (): T => {\n\t\tif (activeSink) link(node, activeSink)\n\t\trefresh(node as unknown as SinkNode)\n\t\tif (node.error) throw node.error\n\t\treturn node.value\n\t}\n\n\tconst set = (next: T): void => {\n\t\tif (!isMutableSignal(delegated))\n\t\t\tthrow new ReadonlySignalError(TYPE_SLOT)\n\t\tvalidateSignalValue(TYPE_SLOT, next, guard)\n\n\t\tdelegated.set(next)\n\t}\n\n\tconst replace = <U extends T>(next: Signal<U>): void => {\n\t\tvalidateSignalValue(TYPE_SLOT, next, isSignal)\n\n\t\tdelegated = next\n\t\tnode.flags |= FLAG_DIRTY\n\t\tfor (let e = node.sinks; e; e = e.nextSink) propagate(e.sink)\n\t\tif (batchDepth === 0) flush()\n\t}\n\n\treturn {\n\t\t[Symbol.toStringTag]: TYPE_SLOT,\n\t\tconfigurable: true,\n\t\tenumerable: true,\n\t\tget,\n\t\tset,\n\t\treplace,\n\t\tcurrent: () => delegated,\n\t}\n}\n\n/**\n * Checks if a value is a Slot signal.\n *\n * @since 0.18.3\n * @param value - The value to check\n * @returns True if the value is a Slot\n */\nfunction isSlot<T extends {} = unknown & {}>(value: unknown): value is Slot<T> {\n\treturn isObjectOfType(value, TYPE_SLOT)\n}\n\nexport { createSlot, isSlot, type Slot }\n",
    "import { isFunction } from '@zeix/cause-effect'\n\n/* === Types === */\n\ntype LogLevel = 'debug' | 'info' | 'warn' | 'error'\n\n/* === Constants === */\n\nconst DEV_MODE = process.env.DEV_MODE\n\nconst LOG_DEBUG: LogLevel = 'debug'\nconst LOG_INFO: LogLevel = 'info'\nconst LOG_WARN: LogLevel = 'warn'\nconst LOG_ERROR: LogLevel = 'error'\n\n// Reserved words that should never be used as property names\n// These are fundamental JavaScript/Object properties that cause serious issues\nconst RESERVED_WORDS = new Set([\n\t'constructor',\n\t'prototype',\n\t// Expand this list based on user feedback for other reserved words like:\n\t// '__proto__', 'toString', 'valueOf', 'hasOwnProperty', etc.\n])\n\n// HTMLElement properties that commonly cause conflicts\n// These are properties that exist on HTMLElement and cause confusion when overridden\n// in our reactive components because we use the same name for both attributes and properties\nconst HTML_ELEMENT_PROPS = new Set([\n\t'id', // DOM selector conflicts\n\t'class', // CSS class management conflicts (note: property is 'className')\n\t'className', // CSS class management conflicts (note: HTML attribute is 'class')\n\t'title', // Conflicts with tooltip behavior\n\t'role', // ARIA/accessibility conflicts\n\t'style', // Conflicts with style object\n\t'dataset', // Conflicts with data-* attribute access\n\t'lang', // Language/i18n conflicts\n\t'dir', // Text direction conflicts\n\t'hidden', // Visibility control conflicts\n\t'children', // DOM manipulation conflicts\n\t'innerHTML', // DOM manipulation conflicts\n\t'outerHTML', // Full element HTML conflicts\n\t'textContent', // Text manipulation conflicts\n\t'innerText', // Text manipulation conflicts\n\t// TO EXPAND: Add properties based on user feedback and common mistakes\n\t// 'tabindex', 'tabIndex', 'slot', 'part', etc.\n])\n\n/* === Internal Functions === */\n\n/**\n * Return selector string for the id of the element\n *\n * @since 0.7.0\n * @param {string | undefined | null} id\n * @returns {string} - id string for the element with '#' prefix\n */\nconst idString = (id: string | undefined | null): string => (id ? `#${id}` : '')\n\n/**\n * Return a selector string for classes of the element\n *\n * @since 0.7.0\n * @param {DOMTokenList | undefined | null} classList - DOMTokenList to convert to a string\n * @returns {string} - class string for the DOMTokenList with '.' prefix if any\n */\nconst classString = (classList: DOMTokenList | undefined | null): string =>\n\tclassList?.length ? `.${Array.from(classList).join('.')}` : ''\n\n/* === Exported Functions === */\n\nconst hasMethod = /*#__PURE__*/ <T extends object, K extends PropertyKey, R>(\n\tobj: T,\n\tmethodName: K,\n): obj is T & Record<K, (...args: any[]) => R> =>\n\ttypeof methodName === 'string' &&\n\tmethodName in obj &&\n\tisFunction<R>((obj as any)[methodName])\n\n/**\n * Check if a node is an Element\n *\n * @param {Node} node - node to check\n * @returns {boolean} - `true` if node is an element node, otherwise `false`\n */\nconst isElement = /*#__PURE__*/ (node: Node): node is Element =>\n\tnode.nodeType === Node.ELEMENT_NODE\n\n/**\n * Check whether an element is a custom element\n *\n * @param {E} element - Element to check\n * @returns {boolean} - True if the element is a custom element\n */\nconst isCustomElement = /*#__PURE__*/ <E extends Element>(\n\telement: E,\n): boolean => element.localName.includes('-')\n\n/**\n * Check whether a custom element is not yet defined\n *\n * @param {Element} element - Element to check\n * @returns {boolean} - True if the element is a custom element and not yet defined\n */\nconst isNotYetDefinedComponent = /*#__PURE__*/ (element: Element): boolean =>\n\tisCustomElement(element) && element.matches(':not(:defined)')\n\n/**\n * Return a string representation of the Element instance\n *\n * @since 0.7.0\n * @param {Element | undefined | null} el\n * @returns {string}\n */\nconst elementName = /*#__PURE__*/ (el: Element | undefined | null): string =>\n\tel\n\t\t? `<${el.localName}${idString(el.id)}${classString(el.classList)}>`\n\t\t: '<unknown>'\n\n/**\n * Return a detailed type of a JavaScript variable\n *\n * @since 0.11.0\n * @param {unknown} value\n * @returns {string}\n */\nconst typeString = /*#__PURE__*/ (value: unknown): string => {\n\tif (value === null) return 'null'\n\tif (typeof value !== 'object') return typeof value\n\tif (Array.isArray(value)) return 'Array'\n\n\t// Check for Symbol.toStringTag\n\tif (Symbol.toStringTag in Object(value)) {\n\t\treturn (value as any)[Symbol.toStringTag]\n\t}\n\n\t// For other objects, return the constructor name if available\n\treturn value.constructor?.name || 'Object'\n}\n\n/**\n * Log a message to the console with the specified level\n *\n * @since 0.7.0\n * @param {T} value - value to inspect\n * @param {string} msg - message to log\n * @param {LogLevel} level - log level\n * @returns {T} - value passed through\n */\nconst log = <T>(value: T, msg: string, level: LogLevel = LOG_DEBUG): T => {\n\tif (DEV_MODE || ([LOG_ERROR, LOG_WARN] as LogLevel[]).includes(level))\n\t\tconsole[level](msg, value)\n\treturn value\n}\n\n/**\n * Simple fail-fast validation that checks for specific problematic cases\n *\n * This validation prevents common mistakes where developers accidentally\n * use property names that conflict with native HTMLElement functionality.\n *\n * @param {string} prop - Property name to validate\n * @returns {string | null} - Error message or null if valid\n */\nconst validatePropertyName = (prop: string): string | null => {\n\tif (RESERVED_WORDS.has(prop))\n\t\treturn `Property name \"${prop}\" is a reserved word`\n\tif (HTML_ELEMENT_PROPS.has(prop))\n\t\treturn `Property name \"${prop}\" conflicts with inherited HTMLElement property`\n\treturn null\n}\n\nexport {\n\ttype LogLevel,\n\thasMethod,\n\tisElement,\n\tisCustomElement,\n\tisNotYetDefinedComponent,\n\tlog,\n\telementName,\n\ttypeString,\n\tvalidatePropertyName,\n\tDEV_MODE,\n\tLOG_DEBUG,\n\tLOG_INFO,\n\tLOG_WARN,\n\tLOG_ERROR,\n}\n",
    "import { valueString } from '@zeix/cause-effect'\nimport { elementName } from './util'\n\n/* === Error Classes === */\n\n/**\n * Error thrown when component name violates rules for custom element names\n *\n * @since 0.14.0\n */\nclass InvalidComponentNameError extends TypeError {\n\t/**\n\t * @param {string} component - Component name\n\t */\n\tconstructor(component: string) {\n\t\tsuper(\n\t\t\t`Invalid component name \"${component}\". Custom element names must contain a hyphen, start with a lowercase letter, and contain only lowercase letters, numbers, and hyphens.`,\n\t\t)\n\t\tthis.name = 'InvalidComponentNameError'\n\t}\n}\n\n/**\n * Error thrown when trying to assign a property name that conflicts with reserved words or inherited HTMLElement properties\n *\n * @since 0.14.0\n */\nclass InvalidPropertyNameError extends TypeError {\n\t/**\n\t * @param {string} component - Component name\n\t * @param {string} prop - Property name\n\t * @param {string} reason - Explanation why the property is invalid\n\t */\n\tconstructor(component: string, prop: string, reason: string) {\n\t\tsuper(\n\t\t\t`Invalid property name \"${prop}\" for component <${component}>. ${reason}`,\n\t\t)\n\t\tthis.name = 'InvalidPropertyNameError'\n\t}\n}\n\n/**\n * Error thrown when setup function does not return effects\n *\n * @since 0.14.0\n */\nclass InvalidEffectsError extends TypeError {\n\t/**\n\t * @param {HTMLElement} host - Host component\n\t * @param {Error} cause - Error that caused the invalid effects\n\t */\n\tconstructor(host: HTMLElement, cause?: Error) {\n\t\tsuper(\n\t\t\t`Invalid effects in component ${elementName(host)}. Effects must be a record of effects for UI elements or the component, or a Promise that resolves to effects.`,\n\t\t)\n\t\tthis.name = 'InvalidEffectsError'\n\t\tif (cause) this.cause = cause\n\t}\n}\n\n/**\n * Error thrown when a required desacendent element does not exist in a component's DOM subtree\n *\n * @since 0.14.0\n */\nclass MissingElementError extends Error {\n\t/**\n\t * @param {HTMLElement} host - Host component\n\t * @param {string} selector - Selector used to find the elements\n\t * @param {string} required - Explanation why the element is required\n\t */\n\tconstructor(host: HTMLElement, selector: string, required: string) {\n\t\tsuper(\n\t\t\t`Missing required element <${selector}> in component ${elementName(host)}. ${required}`,\n\t\t)\n\t\tthis.name = 'MissingElementError'\n\t}\n}\n\n/**\n * Error when a component's dependencies are not met within a specified timeout\n *\n * @since 0.14.0\n */\nclass DependencyTimeoutError extends Error {\n\t/**\n\t * @param {HTMLElement} host - Host component\n\t * @param {string[]} missing - List of missing dependencies\n\t */\n\tconstructor(host: HTMLElement, missing: string[]) {\n\t\tsuper(\n\t\t\t`Timeout waiting for: [${missing.join(', ')}] in component ${elementName(host)}.`,\n\t\t)\n\t\tthis.name = 'DependencyTimeoutError'\n\t}\n}\n\n/**\n * Error thrown when reactives passed to a component are invalid\n *\n * @since 0.15.0\n */\nclass InvalidReactivesError extends TypeError {\n\t/**\n\t * @param {HTMLElement} host - Host component\n\t * @param {HTMLElement} target - Target component\n\t * @param {unknown} reactives - Reactives passed to the component\n\t */\n\tconstructor(host: HTMLElement, target: HTMLElement, reactives: unknown) {\n\t\tsuper(\n\t\t\t`Expected reactives passed from ${elementName(host)} to ${elementName(target)} to be a record of signals, reactive property names or functions. Got ${valueString(reactives)}.`,\n\t\t)\n\t\tthis.name = 'InvalidReactivesError'\n\t}\n}\n\n/**\n * Error thrown when target element is not a custom element as expected\n *\n * @since 0.15.0\n */\nclass InvalidCustomElementError extends TypeError {\n\t/**\n\t * @param {HTMLElement} target - Target component\n\t * @param {string} where - Location where the error occurred\n\t */\n\tconstructor(target: HTMLElement, where: string) {\n\t\tsuper(`Target ${elementName(target)} is not a custom element in ${where}.`)\n\t\tthis.name = 'InvalidCustomElementError'\n\t}\n}\n\nexport {\n\tDependencyTimeoutError,\n\tInvalidComponentNameError,\n\tInvalidCustomElementError,\n\tInvalidPropertyNameError,\n\tInvalidEffectsError,\n\tInvalidReactivesError,\n\tMissingElementError,\n}\n",
    "import {\n\ttype Cleanup,\n\tcreateEffect,\n\tisFunction,\n\tisMemo,\n\tisRecord,\n\tisSignal,\n\ttype MaybeCleanup,\n\ttype Memo,\n\ttype Signal,\n\tvalueString,\n} from '@zeix/cause-effect'\nimport type { Component, ComponentProps } from './component'\nimport { InvalidEffectsError } from './errors'\nimport type { ElementFromKey, UI } from './ui'\nimport { DEV_MODE, elementName, LOG_ERROR, log } from './util'\n\n/* === Types === */\n\ntype Effect<P extends ComponentProps, E extends Element> = (\n\thost: Component<P>,\n\ttarget: E,\n) => MaybeCleanup\n\ntype ElementEffects<P extends ComponentProps, E extends Element> =\n\t| Effect<P, E>\n\t| Effect<P, E>[]\n\ntype Effects<\n\tP extends ComponentProps,\n\tU extends UI & { host: Component<P> },\n> = {\n\t[K in keyof U]?: ElementEffects<P, ElementFromKey<U, K>>\n}\n\ntype Reactive<T, P extends ComponentProps, E extends Element> =\n\t| keyof P\n\t| Signal<T & {}>\n\t| ((target: E) => T | null | undefined)\n\ntype UpdateOperation = 'a' | 'c' | 'd' | 'h' | 'm' | 'p' | 's' | 't'\n\ntype ElementUpdater<E extends Element, T> = {\n\top: UpdateOperation\n\tname?: string\n\tread: (element: E) => T | null\n\tupdate: (element: E, value: T) => void\n\tdelete?: (element: E) => void\n\tresolve?: (element: E) => void\n\treject?: (error: unknown) => void\n}\n\n/* === Constants === */\n\n// Special value explicitly marked as any so it can be used as signal value of any type\nconst RESET: any = Symbol('RESET')\n\n/* === Internal Functions === */\n\nconst getUpdateDescription = (\n\top: UpdateOperation,\n\tname: string = '',\n): string => {\n\tconst ops: Record<UpdateOperation, string> = {\n\t\ta: 'attribute ',\n\t\tc: 'class ',\n\t\td: 'dataset ',\n\t\th: 'inner HTML',\n\t\tm: 'method call ',\n\t\tp: 'property ',\n\t\ts: 'style property ',\n\t\tt: 'text content',\n\t}\n\treturn ops[op] + name\n}\n\n/* === Exported Functions === */\n\n/**\n * Run element effects\n *\n * @since 0.15.0\n * @param {U} host - Host component\n * @param {E} target - Target element\n * @param {ElementEffects<P, E>} effects - Effect functions to run\n * @returns {MaybeCleanup} - Cleanup function that runs collected cleanup functions\n * @throws {InvalidEffectsError} - If the effects are invalid\n */\nconst runElementEffects = <P extends ComponentProps, E extends Element>(\n\thost: Component<P>,\n\ttarget: E,\n\teffects: ElementEffects<P, E>,\n): MaybeCleanup => {\n\tconst cleanups: Cleanup[] = []\n\n\tconst run = (fn: Effect<P, E>) => {\n\t\tconst cleanup = fn(host, target)\n\t\tif (cleanup) cleanups.push(cleanup)\n\t}\n\n\tif (Array.isArray(effects)) for (const fn of effects) run(fn)\n\telse run(effects)\n\n\treturn () => {\n\t\tcleanups.forEach(cleanup => cleanup())\n\t\tcleanups.length = 0\n\t}\n}\n\n/**\n * Run effects for dynamic collection of elements matching a selector\n *\n * @since 0.16.0\n * @param {Component<P>} host - Host component\n * @param {Memo<E[]>} elements - Elements for selector\n * @param {ElementEffects<P, E>} effects - Element effects\n * @returns {Cleanup} - Cleanup function that runs collected cleanup functions\n * @throws {InvalidEffectsError} - If the effects are invalid\n */\nconst runElementsEffects = <P extends ComponentProps, E extends Element>(\n\thost: Component<P>,\n\telements: Memo<E[]>,\n\teffects: ElementEffects<P, E>,\n): Cleanup => {\n\tconst cleanups: Map<E, Cleanup> = new Map()\n\n\tconst attach = (targets: readonly E[]) => {\n\t\tfor (const target of targets) {\n\t\t\tconst cleanup = runElementEffects(host, target, effects)\n\t\t\tif (cleanup) cleanups.set(target, cleanup)\n\t\t}\n\t}\n\tconst detach = (targets: readonly E[]) => {\n\t\tfor (const target of targets) {\n\t\t\tcleanups.get(target)?.()\n\t\t\tcleanups.delete(target)\n\t\t}\n\t}\n\n\tconst dispose = createEffect(() => {\n\t\tconst next = new Set(elements.get())\n\t\tconst added: E[] = []\n\t\tconst removed: E[] = []\n\n\t\tfor (const target of next) if (!cleanups.has(target)) added.push(target)\n\t\tfor (const target of cleanups.keys())\n\t\t\tif (!next.has(target)) removed.push(target)\n\n\t\tattach(added)\n\t\tdetach(removed)\n\t})\n\treturn () => {\n\t\tfor (const cleanup of cleanups.values()) cleanup()\n\t\tcleanups.clear()\n\t\tdispose()\n\t}\n}\n\n/**\n * Run component effects\n *\n * @since 0.15.0\n * @param {ComponentUI<P, U>} ui - Component UI\n * @param {Effects<P, U>} effects - Effect functions to run\n * @returns {Cleanup} - Cleanup function that runs collected cleanup functions\n * @throws {InvalidEffectsError} - If the effects are invalid\n */\nconst runEffects = <\n\tP extends ComponentProps,\n\tU extends UI & { host: Component<P> },\n>(\n\tui: U,\n\teffects: Effects<P, U>,\n): Cleanup => {\n\tif (!isRecord(effects)) throw new InvalidEffectsError(ui.host)\n\n\tconst cleanups: Cleanup[] = []\n\tconst keys = Object.keys(effects)\n\tfor (const key of keys) {\n\t\tconst k = key as keyof U\n\t\tif (!effects[k]) continue\n\n\t\tconst elementEffects = Array.isArray(effects[k]) ? effects[k] : [effects[k]]\n\t\tif (isMemo<ElementFromKey<U, typeof k>[]>(ui[k])) {\n\t\t\tcleanups.push(runElementsEffects(ui.host, ui[k], elementEffects))\n\t\t} else if (ui[k]) {\n\t\t\tconst cleanup = runElementEffects(\n\t\t\t\tui.host,\n\t\t\t\tui[k] as ElementFromKey<U, typeof k>,\n\t\t\t\telementEffects,\n\t\t\t)\n\t\t\tif (cleanup) cleanups.push(cleanup)\n\t\t}\n\t}\n\treturn () => {\n\t\tfor (const cleanup of cleanups) cleanup()\n\t\tcleanups.length = 0\n\t}\n}\n\n/**\n * Resolve reactive property name, reader function or signal\n *\n * @param {Reactive<T, P, E>} reactive - Reactive property name, reader function or signal\n * @param {Component<P, U>} host - Component host element\n * @param {E} target - Element to resolve reactive value for\n * @param {string} [context] - Context for error logging\n * @returns {T} - Resolved reactive value\n */\nconst resolveReactive = <\n\tT extends {},\n\tP extends ComponentProps,\n\tE extends Element,\n>(\n\treactive: Reactive<T, P, E>,\n\thost: Component<P>,\n\ttarget: E,\n\tcontext?: string,\n): T => {\n\ttry {\n\t\treturn typeof reactive === 'string'\n\t\t\t? (host[reactive] as unknown as T)\n\t\t\t: isSignal(reactive)\n\t\t\t\t? reactive.get()\n\t\t\t\t: isFunction(reactive)\n\t\t\t\t\t? (reactive(target) as unknown as T)\n\t\t\t\t\t: RESET\n\t} catch (error) {\n\t\tif (context) {\n\t\t\tlog(\n\t\t\t\terror,\n\t\t\t\t`Failed to resolve value of ${valueString(reactive)}${\n\t\t\t\t\tcontext ? ` for ${context}` : ''\n\t\t\t\t} in ${elementName(target)}${\n\t\t\t\t\t(host as unknown as E) !== target ? ` in ${elementName(host)}` : ''\n\t\t\t\t}`,\n\t\t\t\tLOG_ERROR,\n\t\t\t)\n\t\t}\n\t\treturn RESET\n\t}\n}\n\n/**\n * Core effect function for updating element properties based on reactive values.\n * This function handles the lifecycle of reading, updating, and deleting element properties\n * while providing proper error handling and debugging support.\n *\n * @since 0.9.0\n * @param {Reactive<T, P, E>} reactive - The reactive value that drives the element updates\n * @param {ElementUpdater<E, T>} updater - Configuration object defining how to read, update, and delete the element property\n * @returns {Effect<P, E>} Effect function that manages the element property updates\n */\nconst updateElement =\n\t<T extends {}, P extends ComponentProps, E extends Element>(\n\t\treactive: Reactive<T, P, E>,\n\t\tupdater: ElementUpdater<E, T>,\n\t): Effect<P, E> =>\n\t(host, target): Cleanup => {\n\t\tconst { op, name = '', read, update } = updater\n\t\tconst operationDesc = getUpdateDescription(op, name)\n\n\t\tconst ok = (verb: string) => () => {\n\t\t\tif (DEV_MODE && host.debug) {\n\t\t\t\tlog(\n\t\t\t\t\ttarget,\n\t\t\t\t\t`${verb} ${operationDesc} of ${elementName(target)} in ${elementName(host)}`,\n\t\t\t\t)\n\t\t\t}\n\t\t\tupdater.resolve?.(target)\n\t\t}\n\n\t\tconst err = (verb: string) => (error: unknown) => {\n\t\t\tlog(\n\t\t\t\terror,\n\t\t\t\t`Failed to ${verb} ${operationDesc} of ${elementName(target)} in ${elementName(host)}`,\n\t\t\t\tLOG_ERROR,\n\t\t\t)\n\t\t\tupdater.reject?.(error)\n\t\t}\n\n\t\tconst fallback = read(target)\n\n\t\treturn createEffect(() => {\n\t\t\tconst value = resolveReactive(reactive, host, target, operationDesc)\n\t\t\tconst resolvedValue =\n\t\t\t\tvalue === RESET\n\t\t\t\t\t? fallback\n\t\t\t\t\t: value === null\n\t\t\t\t\t\t? updater.delete\n\t\t\t\t\t\t\t? null\n\t\t\t\t\t\t\t: fallback\n\t\t\t\t\t\t: value\n\n\t\t\tif (updater.delete && resolvedValue === null) {\n\t\t\t\ttry {\n\t\t\t\t\tupdater.delete!(target)\n\t\t\t\t\tok('delete')()\n\t\t\t\t} catch (error) {\n\t\t\t\t\terr('delete')(error)\n\t\t\t\t}\n\t\t\t} else if (resolvedValue != null) {\n\t\t\t\tconst current = read(target)\n\t\t\t\tif (Object.is(resolvedValue, current)) return\n\t\t\t\ttry {\n\t\t\t\t\tupdate(target, resolvedValue)\n\t\t\t\t\tok('update')()\n\t\t\t\t} catch (error) {\n\t\t\t\t\terr('update')(error)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\nexport {\n\ttype Effect,\n\ttype Effects,\n\ttype ElementEffects,\n\ttype ElementUpdater,\n\ttype Reactive,\n\ttype UpdateOperation,\n\trunEffects,\n\trunElementEffects,\n\tresolveReactive,\n\tupdateElement,\n\tRESET,\n}\n",
    "import type { Signal } from '@zeix/cause-effect'\n\n/* === Internal Shared State === */\n\n/** Module-internal map from component instances to their signal records. */\nconst componentSignals = new WeakMap<HTMLElement, Record<string, Signal<any>>>()\n\n/** Get the signals map for a component, creating it if needed. */\nconst getSignals = (el: HTMLElement): Record<string, Signal<any>> => {\n\tlet signals = componentSignals.get(el)\n\tif (!signals) {\n\t\tsignals = {}\n\t\tcomponentSignals.set(el, signals)\n\t}\n\treturn signals\n}\n\nexport { getSignals }\n",
    "import { isFunction } from '@zeix/cause-effect'\nimport type { UI } from './ui'\n\n/* === Types === */\n\ntype Parser<T extends {}, U extends UI> = (\n\tui: U,\n\tvalue: string | null | undefined,\n\told?: string | null,\n) => T\n\ntype LooseReader<T extends {}, U extends UI> = (\n\tui: U,\n) => T | string | null | undefined\ntype Reader<T extends {}, U extends UI> = (ui: U) => T\n\ntype Fallback<T extends {}, U extends UI> = T | Reader<T, U>\n\ntype ParserOrFallback<T extends {}, U extends UI> =\n\t| Parser<T, U>\n\t| Fallback<T, U>\n\n/* === Exported Functions === */\n\n/**\n * Check if a value is a parser\n *\n * @since 0.14.0\n * @param {unknown} value - Value to check if it is a parser\n * @returns {boolean} True if the value is a parser, false otherwise\n */\nconst isParser = <T extends {}, U extends UI>(\n\tvalue: unknown,\n): value is Parser<T, U> => isFunction<T>(value) && value.length >= 2\n\n/**\n * Check if a value is a reader\n *\n * @since 0.15.0\n * @param {unknown} value - Value to check if it is a reader\n * @returns {boolean} True if the value is a reader, false otherwise\n */\nconst isReader = <T extends {}, U extends UI>(\n\tvalue: unknown,\n): value is Reader<T, U> => isFunction<T>(value)\n\n/**\n * Get a fallback value for an element\n *\n * @since 0.14.0\n * @param {U} ui - Component UI\n * @param {ParserOrFallback<T, U>} fallback - Fallback value or parser function\n * @returns {T} Fallback value or parsed value\n */\nconst getFallback = <T extends {}, U extends UI>(\n\tui: U,\n\tfallback: ParserOrFallback<T, U>,\n): T => (isReader<T, U>(fallback) ? fallback(ui) : (fallback as T))\n\n/**\n * Read a value from a UI element\n *\n * @since 0.15.0\n * @param {LooseReader<T, U>} reader - Reader function returning T | string | null | undefined\n * @param {ParserOrFallback<T, U>} fallback - Fallback value or parser function\n * @returns {Reader<T, U>} Parsed value or fallback value\n */\nconst read =\n\t<T extends {}, U extends UI>(\n\t\treader: LooseReader<T, U>,\n\t\tfallback: ParserOrFallback<T, U>,\n\t): Reader<T, U> =>\n\t(ui: U): T => {\n\t\tconst value = reader(ui)\n\t\treturn typeof value === 'string' && isParser<T, U>(fallback)\n\t\t\t? fallback(ui, value)\n\t\t\t: ((value as T) ?? getFallback(ui, fallback))\n\t}\n\nexport {\n\ttype Parser,\n\ttype LooseReader,\n\ttype Reader,\n\ttype Fallback,\n\ttype ParserOrFallback,\n\tisParser,\n\tisReader,\n\tgetFallback,\n\tread,\n}\n",
    "import { createMemo, type Memo } from '@zeix/cause-effect'\nimport { DependencyTimeoutError, MissingElementError } from './errors'\nimport { DEV_MODE, isNotYetDefinedComponent, LOG_WARN } from './util'\n\n/* === Types === */\n\n// Split a comma-separated selector into individual selectors\ntype SplitByComma<S extends string> = S extends `${infer First},${infer Rest}`\n\t? [TrimWhitespace<First>, ...SplitByComma<Rest>]\n\t: [TrimWhitespace<S>]\n\n// Trim leading/trailing whitespace from a string\ntype TrimWhitespace<S extends string> = S extends ` ${infer Rest}`\n\t? TrimWhitespace<Rest>\n\t: S extends `${infer Rest} `\n\t\t? TrimWhitespace<Rest>\n\t\t: S\n\n// Extract the rightmost selector part from combinator selectors (space, >, +, ~)\ntype ExtractRightmostSelector<S extends string> =\n\tS extends `${string} ${infer Rest}`\n\t\t? ExtractRightmostSelector<Rest>\n\t\t: S extends `${string}>${infer Rest}`\n\t\t\t? ExtractRightmostSelector<Rest>\n\t\t\t: S extends `${string}+${infer Rest}`\n\t\t\t\t? ExtractRightmostSelector<Rest>\n\t\t\t\t: S extends `${string}~${infer Rest}`\n\t\t\t\t\t? ExtractRightmostSelector<Rest>\n\t\t\t\t\t: S\n\n// Extract tag name from a simple selector (without combinators)\ntype ExtractTagFromSimpleSelector<S extends string> =\n\tS extends `${infer T}.${string}`\n\t\t? T\n\t\t: S extends `${infer T}#${string}`\n\t\t\t? T\n\t\t\t: S extends `${infer T}:${string}`\n\t\t\t\t? T\n\t\t\t\t: S extends `${infer T}[${string}`\n\t\t\t\t\t? T\n\t\t\t\t\t: S\n\n// Main extraction logic for a single selector\ntype ExtractTag<S extends string> = ExtractTagFromSimpleSelector<\n\tExtractRightmostSelector<S>\n>\n\n// Normalize to lowercase and ensure it's a known HTML tag\ntype KnownTag<S extends string> =\n\tLowercase<ExtractTag<S>> extends\n\t\t| keyof HTMLElementTagNameMap\n\t\t| keyof SVGElementTagNameMap\n\t\t| keyof MathMLElementTagNameMap\n\t\t? Lowercase<ExtractTag<S>>\n\t\t: never\n\n// Get element type from a single selector\ntype ElementFromSingleSelector<S extends string> =\n\tKnownTag<S> extends never\n\t\t? HTMLElement\n\t\t: KnownTag<S> extends keyof HTMLElementTagNameMap\n\t\t\t? HTMLElementTagNameMap[KnownTag<S>]\n\t\t\t: KnownTag<S> extends keyof SVGElementTagNameMap\n\t\t\t\t? SVGElementTagNameMap[KnownTag<S>]\n\t\t\t\t: KnownTag<S> extends keyof MathMLElementTagNameMap\n\t\t\t\t\t? MathMLElementTagNameMap[KnownTag<S>]\n\t\t\t\t\t: HTMLElement\n\n// Map a tuple of selectors to a union of their element types\ntype ElementsFromSelectorArray<Selectors extends readonly string[]> = {\n\t[K in keyof Selectors]: Selectors[K] extends string\n\t\t? ElementFromSingleSelector<Selectors[K]>\n\t\t: never\n}[number]\n\n// Main type: handle both single selectors and comma-separated selectors\ntype ElementFromSelector<S extends string> = S extends `${string},${string}`\n\t? ElementsFromSelectorArray<SplitByComma<S>>\n\t: ElementFromSingleSelector<S>\n\ntype FirstElement = {\n\t<S extends string>(selector: S, required: string): ElementFromSelector<S>\n\t<S extends string>(selector: S): ElementFromSelector<S> | undefined\n\t<E extends Element>(selector: string, required: string): E\n\t<E extends Element>(selector: string): E | undefined\n}\n\ntype AllElements = {\n\t<S extends string>(\n\t\tselector: S,\n\t\trequired?: string,\n\t): Memo<ElementFromSelector<S>[]>\n\t<E extends Element>(selector: string, required?: string): Memo<E[]>\n}\n\ntype ElementQueries = {\n\tfirst: FirstElement\n\tall: AllElements\n}\n\ntype UI = Record<string, Element | Memo<Element[]>>\n\ntype ElementFromKey<U extends UI, K extends keyof U> = NonNullable<\n\tU[K] extends Memo<infer E extends Element[]>\n\t\t? E[number]\n\t\t: U[K] extends Element\n\t\t\t? U[K]\n\t\t\t: never\n>\n\n/* === Constants === */\n\nconst DEPENDENCY_TIMEOUT = 200\n\n/* === Internal Functions === */\n\n/**\n * Extract attribute names from a CSS selector\n * Handles various attribute selector formats: .class, #id, [attr], [attr=value], [attr^=value], etc.\n *\n * @param {string} selector - CSS selector to parse\n * @returns {string[]} - Array of attribute names found in the selector\n */\nconst extractAttributes = (selector: string): string[] => {\n\tconst attributes = new Set<string>()\n\tif (selector.includes('.')) attributes.add('class')\n\tif (selector.includes('#')) attributes.add('id')\n\tif (selector.includes('[')) {\n\t\tconst parts = selector.split('[')\n\t\tfor (let i = 1; i < parts.length; i++) {\n\t\t\tconst part = parts[i]\n\t\t\tif (!part.includes(']')) continue\n\t\t\tconst attrName = part\n\t\t\t\t.split('=')[0]\n\t\t\t\t.trim()\n\t\t\t\t.replace(/[^a-zA-Z0-9_-]/g, '')\n\t\t\tif (attrName) attributes.add(attrName)\n\t\t}\n\t}\n\treturn [...attributes]\n}\n\n/* === Exported Functions === */\n\n/**\n * Create a memo of elements matching a CSS selector.\n * The MutationObserver is lazily activated when an effect first reads\n * the memo, and disconnected when no effects are watching.\n *\n * @since 0.16.0\n * @param parent - The parent node to search within\n * @param selector - The CSS selector to match elements\n * @returns A Memo of current matching elements\n */\nfunction createElementsMemo<S extends string>(\n\tparent: ParentNode,\n\tselector: S,\n): Memo<ElementFromSelector<S>[]>\nfunction createElementsMemo<E extends Element>(\n\tparent: ParentNode,\n\tselector: string,\n): Memo<E[]>\nfunction createElementsMemo<S extends string>(\n\tparent: ParentNode,\n\tselector: S,\n): Memo<ElementFromSelector<S>[]> {\n\ttype E = ElementFromSelector<S>\n\n\treturn createMemo(() => Array.from(parent.querySelectorAll<E>(selector)), {\n\t\tvalue: [],\n\t\twatched: invalidate => {\n\t\t\tconst observerConfig: MutationObserverInit = {\n\t\t\t\tchildList: true,\n\t\t\t\tsubtree: true,\n\t\t\t}\n\t\t\tconst observedAttributes = extractAttributes(selector)\n\t\t\tif (observedAttributes.length) {\n\t\t\t\tobserverConfig.attributes = true\n\t\t\t\tobserverConfig.attributeFilter = observedAttributes\n\t\t\t}\n\t\t\tconst observer = new MutationObserver(() => invalidate())\n\t\t\tobserver.observe(parent, observerConfig)\n\t\t\treturn () => observer.disconnect()\n\t\t},\n\t})\n}\n\n/**\n * Create partially applied helper functions to get descendants and run effects on them\n *\n * @since 0.14.0\n * @param {HTMLElement} host - Host component\n * @returns {ElementSelectors<P>} - Helper functions for selecting descendants\n */\nconst getHelpers = (\n\thost: HTMLElement,\n): [ElementQueries, (run: () => void) => void] => {\n\tconst root = host.shadowRoot ?? host\n\tconst dependencies: Set<string> = new Set()\n\n\t/**\n\t * Get the first descendant element matching a selector\n\t * If the element is a custom elements it will be added to dependencies\n\t *\n\t * @since 0.15.0\n\t * @param {S} selector - Selector for element to check for\n\t * @param {string} [required] - Optional reason for the assertion; if provided, throws on missing element\n\t * @returns {ElementFromSelector<S> | undefined} First matching descendant element, or void if not found and not required\n\t * @throws {MissingElementError} - Thrown when the element is required but not found\n\t */\n\tfunction first<S extends string>(\n\t\tselector: S,\n\t\trequired: string,\n\t): ElementFromSelector<S>\n\tfunction first<S extends string>(\n\t\tselector: S,\n\t): ElementFromSelector<S> | undefined\n\tfunction first<E extends Element>(selector: string, required: string): E\n\tfunction first<E extends Element>(selector: string): E | undefined\n\tfunction first<S extends string>(\n\t\tselector: S,\n\t\trequired?: string,\n\t): ElementFromSelector<S> | undefined {\n\t\tconst target = root.querySelector<ElementFromSelector<S>>(selector)\n\t\tif (required != null && !target)\n\t\t\tthrow new MissingElementError(host, selector, required)\n\n\t\t// Only add to dependencies if element is a custom element that's not yet defined\n\t\tif (target && isNotYetDefinedComponent(target))\n\t\t\tdependencies.add(target.localName)\n\t\treturn target ?? undefined\n\t}\n\n\t/**\n\t * Get all descendant elements matching a selector\n\t * If any element is a custom element it will be added to dependencies\n\t *\n\t * @since 0.15.0\n\t * @param {S} selector - Selector for elements to check for\n\t * @param {string} [required] - Optional reason for the assertion; if provided, throws on missing elements\n\t * @returns {ElementFromSelector<S>[]} All matching descendant elements\n\t * @throws {MissingElementError} - Thrown when elements are required but not found\n\t */\n\tfunction all<S extends string>(\n\t\tselector: S,\n\t\trequired?: string,\n\t): Memo<ElementFromSelector<S>[]>\n\tfunction all<E extends Element>(\n\t\tselector: string,\n\t\trequired?: string,\n\t): Memo<E[]>\n\tfunction all<S extends string>(\n\t\tselector: S,\n\t\trequired?: string,\n\t): Memo<ElementFromSelector<S>[]> {\n\t\tconst targets = createElementsMemo(root, selector)\n\t\tconst current = targets.get()\n\t\tif (required != null && !current.length)\n\t\t\tthrow new MissingElementError(host, selector, required)\n\t\tif (current.length)\n\t\t\tfor (const target of current) {\n\t\t\t\t// Only add to dependencies if element is a custom element that's not yet defined\n\t\t\t\tif (isNotYetDefinedComponent(target)) dependencies.add(target.localName)\n\t\t\t}\n\t\treturn targets\n\t}\n\n\t/**\n\t * Resolve dependencies and thereafter run the provided function\n\t *\n\t * @param {() => void} callback - Function to run after resolving dependencies\n\t */\n\tconst resolveDependencies = (callback: () => void) => {\n\t\tif (dependencies.size) {\n\t\t\t// Defer to microtask to filter out components that get defined\n\t\t\t// synchronously after queries ran (e.g. co-bundled components\n\t\t\t// whose define() calls execute later in the same script).\n\t\t\tqueueMicrotask(() => {\n\t\t\t\tconst deps = Array.from(dependencies).filter(\n\t\t\t\t\tdep => !customElements.get(dep),\n\t\t\t\t)\n\t\t\t\tif (!deps.length) {\n\t\t\t\t\tcallback()\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tPromise.race([\n\t\t\t\t\tPromise.all(deps.map(dep => customElements.whenDefined(dep))),\n\t\t\t\t\tnew Promise((_, reject) => {\n\t\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\t\treject(\n\t\t\t\t\t\t\t\tnew DependencyTimeoutError(\n\t\t\t\t\t\t\t\t\thost,\n\t\t\t\t\t\t\t\t\tdeps.filter(dep => !customElements.get(dep)),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}, DEPENDENCY_TIMEOUT)\n\t\t\t\t\t}),\n\t\t\t\t])\n\t\t\t\t\t.then(callback)\n\t\t\t\t\t.catch((error: unknown) => {\n\t\t\t\t\t\tif (DEV_MODE) console[LOG_WARN](error)\n\t\t\t\t\t\tcallback()\n\t\t\t\t\t})\n\t\t\t})\n\t\t} else {\n\t\t\tcallback()\n\t\t}\n\t}\n\n\treturn [{ first, all }, resolveDependencies]\n}\n\nexport {\n\ttype AllElements,\n\ttype ElementFromKey,\n\ttype ElementFromSelector,\n\ttype ElementsFromSelectorArray,\n\ttype ElementFromSingleSelector,\n\ttype ElementQueries,\n\ttype ExtractRightmostSelector,\n\ttype ExtractTag,\n\ttype ExtractTagFromSimpleSelector,\n\ttype FirstElement,\n\ttype KnownTag,\n\tcreateElementsMemo,\n\tgetHelpers,\n\ttype SplitByComma,\n\ttype TrimWhitespace,\n\ttype UI,\n}\n",
    "import {\n\tcreateComputed,\n\tcreateSlot,\n\tcreateState,\n\tisComputed,\n\tisFunction,\n\tisMutableSignal,\n\tisSignal,\n\tisSlot,\n\ttype MaybeCleanup,\n\ttype MemoCallback,\n\ttype Signal,\n\ttype State,\n\ttype TaskCallback,\n} from '@zeix/cause-effect'\n\nimport { type Effects, runEffects } from './effects'\nimport { InvalidComponentNameError, InvalidPropertyNameError } from './errors'\nimport { getSignals } from './internal'\nimport { isParser, type Parser, type Reader } from './parsers'\nimport { type ElementQueries, getHelpers, type UI } from './ui'\nimport { validatePropertyName } from './util'\n\n/* === Types === */\n\ntype ReservedWords =\n\t| 'constructor'\n\t| 'prototype'\n\t| '__proto__'\n\t| 'toString'\n\t| 'valueOf'\n\t| 'hasOwnProperty'\n\t| 'isPrototypeOf'\n\t| 'propertyIsEnumerable'\n\t| 'toLocaleString'\n\ntype ComponentProp = Exclude<string, keyof HTMLElement | ReservedWords>\ntype ComponentProps = Record<ComponentProp, NonNullable<unknown>>\n\ntype Component<P extends ComponentProps> = HTMLElement & P\ntype ComponentUI<P extends ComponentProps, U extends UI> = U & {\n\thost: Component<P>\n}\n\ntype ComponentSetup<P extends ComponentProps, U extends UI> = (\n\tui: ComponentUI<P, U>,\n) => Effects<P, ComponentUI<P, U>>\n\ntype MethodProducer<P extends ComponentProps, U extends UI> = (\n\tui: U & { host: Component<P> },\n) => void\n\ntype Initializers<P extends ComponentProps, U extends UI> = {\n\t[K in keyof P]?:\n\t\t| P[K]\n\t\t| Signal<P[K]>\n\t\t| Parser<P[K], ComponentUI<P, U>>\n\t\t| Reader<MaybeSignal<P[K]>, ComponentUI<P, U>>\n\t\t| MethodProducer<P, ComponentUI<P, U>>\n}\n\ntype MaybeSignal<T extends {}> =\n\t| T\n\t| Signal<T>\n\t| MemoCallback<T>\n\t| TaskCallback<T>\n\n/* === Exported Functions === */\n\n/**\n * Define a component with dependency resolution and setup function (connectedCallback)\n *\n * @since 0.15.0\n * @param {string} name - Custom element name\n * @param {object} props - Component properties\n * @param {function} select - Function to select UI elements\n * @param {function} setup - Setup function\n * @throws {InvalidComponentNameError} If component name is invalid\n * @throws {InvalidPropertyNameError} If property name is invalid\n */\nfunction defineComponent<P extends ComponentProps, U extends UI = {}>(\n\tname: string,\n\tprops: Initializers<P, U> = {} as Initializers<P, U>,\n\tselect: (elementQueries: ElementQueries) => U = () => ({}) as U,\n\tsetup: (ui: ComponentUI<P, U>) => Effects<P, ComponentUI<P, U>> = () => ({}),\n): Component<P> {\n\tif (!name.includes('-') || !name.match(/^[a-z][a-z0-9-]*$/))\n\t\tthrow new InvalidComponentNameError(name)\n\tfor (const prop of Object.keys(props)) {\n\t\tconst error = validatePropertyName(prop)\n\t\tif (error) throw new InvalidPropertyNameError(name, prop, error)\n\t}\n\n\tclass Truc extends HTMLElement {\n\t\tdebug?: boolean\n\t\t#ui: ComponentUI<P, U> | undefined\n\t\t#cleanup: MaybeCleanup\n\n\t\tstatic observedAttributes =\n\t\t\tObject.entries(props)\n\t\t\t\t?.filter(([, initializer]) => isParser(initializer))\n\t\t\t\t.map(([prop]) => prop) ?? []\n\n\t\t/**\n\t\t * Native callback when the custom element is first connected to the document\n\t\t */\n\t\tconnectedCallback() {\n\t\t\t// Initialize UI\n\t\t\tconst [elementQueries, resolveDependencies] = getHelpers(this)\n\t\t\tconst ui = {\n\t\t\t\t...select(elementQueries),\n\t\t\t\thost: this as unknown as Component<P>,\n\t\t\t}\n\t\t\tthis.#ui = ui\n\t\t\tObject.freeze(this.#ui)\n\n\t\t\t// Initialize signals\n\t\t\tconst isReaderOrMethodProducer = <K extends keyof P & string>(\n\t\t\t\tvalue: unknown,\n\t\t\t): value is\n\t\t\t\t| Reader<P[K], ComponentUI<P, U>>\n\t\t\t\t| MethodProducer<P, ComponentUI<P, U>> => {\n\t\t\t\treturn isFunction(value)\n\t\t\t}\n\t\t\tconst createSignal = <K extends keyof P & string>(\n\t\t\t\tkey: K,\n\t\t\t\tinitializer: Initializers<P, U>[K],\n\t\t\t) => {\n\t\t\t\tconst result = isParser<P[K], ComponentUI<P, U>>(initializer)\n\t\t\t\t\t? initializer(ui, this.getAttribute(key))\n\t\t\t\t\t: isReaderOrMethodProducer<K>(initializer)\n\t\t\t\t\t\t? initializer(ui)\n\t\t\t\t\t\t: (initializer as MaybeSignal<P[K]>)\n\t\t\t\tif (result != null) this.#setAccessor(key, result)\n\t\t\t}\n\t\t\tfor (const [prop, initializer] of Object.entries(props)) {\n\t\t\t\tif (initializer == null || prop in this) continue\n\t\t\t\tcreateSignal(prop, initializer)\n\t\t\t}\n\n\t\t\t// Resolve dependencies and run setup function\n\t\t\tresolveDependencies(() => {\n\t\t\t\tthis.#cleanup = runEffects(ui, setup(ui))\n\t\t\t})\n\t\t}\n\n\t\t/**\n\t\t * Native callback when the custom element is disconnected from the document\n\t\t */\n\t\tdisconnectedCallback() {\n\t\t\tif (isFunction(this.#cleanup)) this.#cleanup()\n\t\t}\n\n\t\t/**\n\t\t * Native callback when an observed attribute of the custom element changes\n\t\t *\n\t\t * @param {K} name - Name of the modified attribute\n\t\t * @param {string | null} oldValue - Old value of the modified attribute\n\t\t * @param {string | null} newValue - New value of the modified attribute\n\t\t */\n\t\tattributeChangedCallback<K extends keyof P>(\n\t\t\tname: K,\n\t\t\toldValue: string | null,\n\t\t\tnewValue: string | null,\n\t\t) {\n\t\t\t// Not connected yet, unchanged value or controlled by computed\n\t\t\tif (\n\t\t\t\t!this.#ui ||\n\t\t\t\tnewValue === oldValue ||\n\t\t\t\tisComputed(getSignals(this)[name as string])\n\t\t\t)\n\t\t\t\treturn\n\n\t\t\t// Check whether we have a parser for the attribute\n\t\t\tconst parser = props[name]\n\t\t\tif (!isParser<P[K], ComponentUI<P, U>>(parser)) return\n\n\t\t\tconst parsed = parser(this.#ui, newValue, oldValue)\n\t\t\tif (name in this) (this as unknown as P)[name] = parsed\n\t\t\telse this.#setAccessor(name, parsed)\n\t\t}\n\n\t\t/**\n\t\t * Set the signal for a given key\n\t\t *\n\t\t * @since 0.15.0\n\t\t * @param {K} key - Key to set accessor for\n\t\t * @param {MaybeSignal<P[K]>} value - Initial value, signal or computed callback to create signal\n\t\t */\n\t\t#setAccessor<K extends keyof P>(key: K, value: MaybeSignal<P[K]>): void {\n\t\t\tconst signal = isSignal(value)\n\t\t\t\t? value\n\t\t\t\t: isFunction<P[K]>(value)\n\t\t\t\t\t? createComputed(value)\n\t\t\t\t\t: (createState(value) as State<P[K]>)\n\t\t\tconst signals = getSignals(this)\n\t\t\tconst k = key as string\n\t\t\tconst prev = signals[k]\n\t\t\tif (isSlot(prev)) {\n\t\t\t\tprev.replace(signal)\n\t\t\t} else if (isMutableSignal(signal)) {\n\t\t\t\tconst slot = createSlot<P[K]>(signal)\n\t\t\t\tsignals[k] = slot\n\t\t\t\tObject.defineProperty(this, key, slot)\n\t\t\t} else {\n\t\t\t\tsignals[k] = signal\n\t\t\t\tObject.defineProperty(this, key, {\n\t\t\t\t\tget: signal.get,\n\t\t\t\t\tenumerable: true,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\n\tcustomElements.define(name, Truc)\n\treturn customElements.get(name) as unknown as Component<P>\n}\n\nexport {\n\tdefineComponent,\n\ttype Component,\n\ttype ComponentProp,\n\ttype ComponentProps,\n\ttype ComponentSetup,\n\ttype ComponentUI,\n\ttype Initializers,\n\ttype MethodProducer,\n\ttype MaybeSignal,\n\ttype ReservedWords,\n}\n",
    "import {\n\ttype Cleanup,\n\tcreateMemo,\n\tisFunction,\n\ttype Memo,\n} from '@zeix/cause-effect'\n\nimport type { Component, ComponentProps } from './component'\nimport { type Fallback, getFallback, type Reader } from './parsers'\nimport type { UI } from './ui'\n\n/** @see https://github.com/webcomponents-cg/community-protocols/blob/main/proposals/context.md */\n\n/* === Types === */\n\n/**\n * A context key.\n *\n * A context key can be any type of object, including strings and symbols. The\n *  Context type brands the key type with the `__context__` property that\n * carries the type of the value the context references.\n */\ntype Context<K, V> = K & { __context__: V }\n\n/**\n * An unknown context type\n */\ntype UnknownContext = Context<unknown, unknown>\n\n/**\n * A helper type which can extract a Context value type from a Context type\n */\ntype ContextType<T extends UnknownContext> =\n\tT extends Context<infer _, infer V> ? V : never\n\n/**\n * A callback which is provided by a context requester and is called with the value satisfying the request.\n * This callback can be called multiple times by context providers as the requested value is changed.\n */\ntype ContextCallback<V> = (value: V, unsubscribe?: () => void) => void\n\ndeclare global {\n\tinterface HTMLElementEventMap {\n\t\t/**\n\t\t * A 'context-request' event can be emitted by any element which desires\n\t\t * a context value to be injected by an external provider.\n\t\t */\n\t\t'context-request': ContextRequestEvent<UnknownContext>\n\t}\n}\n\n/* === Constants === */\n\nconst CONTEXT_REQUEST = 'context-request'\n\n/* === Exported class === */\n\n/**\n * Class for context-request events\n *\n * An event fired by a context requester to signal it desires a named context.\n *\n * A provider should inspect the `context` property of the event to determine if it has a value that can\n * satisfy the request, calling the `callback` with the requested value if so.\n *\n * If the requested context event contains a truthy `subscribe` value, then a provider can call the callback\n * multiple times if the value is changed, if this is the case the provider should pass an `unsubscribe`\n * function to the callback which requesters can invoke to indicate they no longer wish to receive these updates.\n *\n * @class ContextRequestEvent\n * @extends {Event}\n *\n * @property {T} context - context key\n * @property {ContextCallback<ContextType<T>>} callback - callback function for value getter and unsubscribe function\n * @property {boolean} [subscribe=false] - whether to subscribe to context changes\n */\nclass ContextRequestEvent<T extends UnknownContext> extends Event {\n\treadonly context: T\n\treadonly callback: ContextCallback<ContextType<T>>\n\treadonly subscribe: boolean\n\n\tconstructor(\n\t\tcontext: T,\n\t\tcallback: ContextCallback<ContextType<T>>,\n\t\tsubscribe: boolean = false,\n\t) {\n\t\tsuper(CONTEXT_REQUEST, {\n\t\t\tbubbles: true,\n\t\t\tcomposed: true,\n\t\t})\n\t\tthis.context = context\n\t\tthis.callback = callback\n\t\tthis.subscribe = subscribe\n\t}\n}\n\n/**\n * Provide a context for descendant component consumers\n *\n * @since 0.13.3\n * @param {Context<string, P[K]>[]} contexts - Array of contexts to provide\n * @returns {(host: Component<P>) => Cleanup} Function to add an event listener for ContextRequestEvent returning a cleanup function to remove the event listener\n */\nconst provideContexts =\n\t<P extends ComponentProps>(\n\t\tcontexts: Array<keyof P>,\n\t): ((host: Component<P>) => Cleanup) =>\n\t(host: Component<P>) => {\n\t\tconst listener = (e: ContextRequestEvent<UnknownContext>) => {\n\t\t\tconst { context, callback } = e\n\t\t\tif (\n\t\t\t\ttypeof context === 'string' &&\n\t\t\t\tcontexts.includes(context as unknown as Extract<keyof P, string>) &&\n\t\t\t\tisFunction(callback)\n\t\t\t) {\n\t\t\t\te.stopImmediatePropagation()\n\t\t\t\tcallback(() => host[context])\n\t\t\t}\n\t\t}\n\t\thost.addEventListener(CONTEXT_REQUEST, listener)\n\t\treturn () => host.removeEventListener(CONTEXT_REQUEST, listener)\n\t}\n\n/**\n * Consume a context value for a component\n *\n * @since 0.15.0\n * @param {Context<string, () => T>} context - Context key to consume\n * @param {Fallback<T, U>} fallback - Fallback value or reader function for fallback\n * @returns {Reader<Memo<T>, U>} Computed signal that returns the consumed context the fallback value\n */\nconst requestContext =\n\t<T extends {}, P extends ComponentProps, U extends UI>(\n\t\tcontext: Context<string, () => T>,\n\t\tfallback: Fallback<T, U & { host: Component<P> }>,\n\t): Reader<Memo<T>, U & { host: Component<P> }> =>\n\t(ui: U & { host: Component<P> }) => {\n\t\tlet consumed = () => getFallback(ui, fallback)\n\t\tui.host.dispatchEvent(\n\t\t\tnew ContextRequestEvent(context, (getter: () => T) => {\n\t\t\t\tconsumed = getter\n\t\t\t}),\n\t\t)\n\t\treturn createMemo(consumed)\n\t}\n\nexport {\n\ttype Context,\n\ttype ContextCallback,\n\ttype UnknownContext,\n\ttype ContextType,\n\tCONTEXT_REQUEST,\n\tContextRequestEvent,\n\tprovideContexts,\n\trequestContext,\n}\n",
    "import type { ComponentProps } from '../component'\nimport { type Effect, type Reactive, updateElement } from '../effects'\n\n/* === Internal Functions === */\n\nconst isSafeURL = (value: string): boolean => {\n\tif (/^(mailto|tel):/i.test(value)) return true\n\tif (value.includes('://')) {\n\t\ttry {\n\t\t\tconst url = new URL(value, window.location.origin)\n\t\t\treturn ['http:', 'https:', 'ftp:'].includes(url.protocol)\n\t\t} catch {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nconst safeSetAttribute = (\n\telement: Element,\n\tattr: string,\n\tvalue: string,\n): void => {\n\tif (/^on/i.test(attr)) throw new Error(`Unsafe attribute: ${attr}`)\n\tvalue = String(value).trim()\n\tif (!isSafeURL(value)) throw new Error(`Unsafe URL for ${attr}: ${value}`)\n\telement.setAttribute(attr, value)\n}\n\n/* === Exported Functions === */\n\n/**\n * Effect for setting an attribute on an element.\n * Sets the specified attribute with security validation for unsafe values.\n *\n * @since 0.8.0\n * @param {string} name - Name of the attribute to set\n * @param {Reactive<string, P, E>} reactive - Reactive value bound to the attribute value (defaults to attribute name)\n * @returns {Effect<P, E>} Effect function that sets the attribute on the element\n */\nconst setAttribute = <P extends ComponentProps, E extends Element>(\n\tname: string,\n\treactive: Reactive<string, P, E> = name as Reactive<string, P, E>,\n): Effect<P, E> =>\n\tupdateElement(reactive, {\n\t\top: 'a',\n\t\tname,\n\t\tread: el => el.getAttribute(name),\n\t\tupdate: (el, value) => {\n\t\t\tsafeSetAttribute(el, name, value)\n\t\t},\n\t\tdelete: el => {\n\t\t\tel.removeAttribute(name)\n\t\t},\n\t})\n\n/**\n * Effect for toggling a boolean attribute on an element.\n * When the reactive value is true, the attribute is present; when false, it's absent.\n *\n * @since 0.8.0\n * @param {string} name - Name of the attribute to toggle\n * @param {Reactive<boolean, P, E>} reactive - Reactive value bound to the attribute presence (defaults to attribute name)\n * @returns {Effect<P, E>} Effect function that toggles the attribute on the element\n */\nconst toggleAttribute = <\n\tP extends ComponentProps,\n\tE extends Element = HTMLElement,\n>(\n\tname: string,\n\treactive: Reactive<boolean, P, E> = name as Reactive<boolean, P, E>,\n): Effect<P, E> =>\n\tupdateElement(reactive, {\n\t\top: 'a',\n\t\tname,\n\t\tread: el => el.hasAttribute(name),\n\t\tupdate: (el, value) => {\n\t\t\tel.toggleAttribute(name, value)\n\t\t},\n\t})\n\nexport { setAttribute, toggleAttribute }\n",
    "import type { ComponentProps } from '../component'\nimport { type Effect, type Reactive, updateElement } from '../effects'\n\n/* === Exported Function === */\n\n/**\n * Effect for toggling a CSS class token on an element.\n * When the reactive value is true, the class is added; when false, it's removed.\n *\n * @since 0.8.0\n * @param {string} token - CSS class token to toggle\n * @param {Reactive<boolean, P, E>} reactive - Reactive value bound to the class presence (defaults to class name)\n * @returns {Effect<P, U, E>} Effect function that toggles the class on the element\n */\nconst toggleClass = <P extends ComponentProps, E extends Element>(\n\ttoken: string,\n\treactive: Reactive<boolean, P, E> = token as Reactive<boolean, P, E>,\n): Effect<P, E> =>\n\tupdateElement(reactive, {\n\t\top: 'c',\n\t\tname: token,\n\t\tread: el => el.classList.contains(token),\n\t\tupdate: (el, value) => {\n\t\t\tel.classList.toggle(token, value)\n\t\t},\n\t})\n\nexport { toggleClass }\n",
    "/* === Constants === */\n\n// High-frequency events that are passive by default and should be scheduled\nconst PASSIVE_EVENTS = new Set([\n\t'scroll',\n\t'resize',\n\t'mousewheel',\n\t'touchstart',\n\t'touchmove',\n\t'wheel',\n])\n\n/* === Internal === */\n\nconst pendingElements = new Set<Element>()\nconst tasks = new WeakMap<Element, () => void>()\nlet requestId: number | undefined\n\nconst runTasks = () => {\n\trequestId = undefined\n\tconst elements = Array.from(pendingElements)\n\tpendingElements.clear()\n\tfor (const element of elements) tasks.get(element)?.()\n}\n\nconst requestTick = () => {\n\tif (requestId) cancelAnimationFrame(requestId)\n\trequestId = requestAnimationFrame(runTasks)\n}\n\n/* === Exported Function === */\n\n/**\n * Schedule a task to be executed on the next animation frame, with automatic\n * deduplication per component. If the same component schedules multiple tasks\n * before the next frame, only the latest task will be executed.\n *\n * @param element - Element for deduplication\n * @param task - Function to execute (typically calls batch() or sets a signal)\n */\nconst schedule = (element: Element, task: () => void) => {\n\ttasks.set(element, task)\n\tpendingElements.add(element)\n\trequestTick()\n}\n\nexport { PASSIVE_EVENTS, schedule }\n",
    "import { batch, type Cleanup, isRecord } from '@zeix/cause-effect'\nimport type { ComponentProps } from '../component'\nimport type { Effect } from '../effects'\nimport type { EventType } from '../events'\nimport { PASSIVE_EVENTS, schedule } from '../scheduler'\nimport { elementName, LOG_ERROR, log } from '../util'\n\n/* === Types === */\n\ntype EventHandler<P extends ComponentProps, Evt extends Event> = (\n\tevent: Evt,\n) => { [K in keyof P]?: P[K] } | void | Promise<void>\n\n/* === Exported Function === */\n\n/**\n * Effect for attaching an event listener to an element.\n * Provides proper cleanup when the effect is disposed.\n *\n * @since 0.14.0\n * @param {K} type - Event type\n * @param {EventHandler<P, E, EventType<K>>} handler - Event handler function\n * @param {AddEventListenerOptions | boolean} options - Event listener options\n * @returns {Effect<ComponentProps, E>} Effect function that manages the event listener\n */\nconst on =\n\t<\n\t\tK extends keyof HTMLElementEventMap | string,\n\t\tP extends ComponentProps,\n\t\tE extends Element = HTMLElement,\n\t>(\n\t\ttype: K,\n\t\thandler: EventHandler<P, EventType<K>>,\n\t\toptions: AddEventListenerOptions = {},\n\t): Effect<P, E> =>\n\t(host, target): Cleanup => {\n\t\tif (!('passive' in options))\n\t\t\toptions = { ...options, passive: PASSIVE_EVENTS.has(type) }\n\t\tconst listener = (e: Event) => {\n\t\t\tconst task = () => {\n\t\t\t\tconst result = handler(e as EventType<K>)\n\t\t\t\tif (!isRecord(result)) return\n\t\t\t\tbatch(() => {\n\t\t\t\t\tfor (const [key, value] of Object.entries(result)) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\thost[key as keyof P] = value\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\tlog(\n\t\t\t\t\t\t\t\terror,\n\t\t\t\t\t\t\t\t`Reactive property \"${key}\" on ${elementName(host)} from event ${type} on ${elementName(target)} could not be set, because it is read-only.`,\n\t\t\t\t\t\t\t\tLOG_ERROR,\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t\tif (options.passive) schedule(target, task)\n\t\t\telse task()\n\t\t}\n\t\ttarget.addEventListener(type, listener, options)\n\t\treturn () => target.removeEventListener(type, listener)\n\t}\n\nexport { type EventHandler, type EventType, on }\n",
    "import type { ComponentProps } from '../component'\nimport { type Effect, type Reactive, updateElement } from '../effects'\nimport { schedule } from '../scheduler'\n\n/* === Types === */\n\ntype DangerouslySetInnerHTMLOptions = {\n\tshadowRootMode?: ShadowRootMode\n\tallowScripts?: boolean\n}\n\n/* === Exported Function === */\n\n/**\n * Effect for setting the inner HTML of an element with optional Shadow DOM support.\n * Provides security options for script execution and shadow root creation.\n *\n * @since 0.11.0\n * @param {Reactive<string, P, E>} reactive - Reactive value bound to the inner HTML content\n * @param {DangerouslySetInnerHTMLOptions} options - Configuration options: shadowRootMode, allowScripts\n * @returns {Effect<P, E>} Effect function that sets the inner HTML of the element\n */\nconst dangerouslySetInnerHTML = <P extends ComponentProps, E extends Element>(\n\treactive: Reactive<string, P, E>,\n\toptions: DangerouslySetInnerHTMLOptions = {},\n): Effect<P, E> =>\n\tupdateElement(reactive, {\n\t\top: 'h',\n\t\tread: el =>\n\t\t\t(el.shadowRoot || !options.shadowRootMode ? el : null)?.innerHTML ?? '',\n\t\tupdate: (el, html) => {\n\t\t\tconst { shadowRootMode, allowScripts } = options\n\t\t\tif (!html) {\n\t\t\t\tif (el.shadowRoot) el.shadowRoot.innerHTML = '<slot></slot>'\n\t\t\t\treturn ''\n\t\t\t}\n\t\t\tif (shadowRootMode && !el.shadowRoot)\n\t\t\t\tel.attachShadow({ mode: shadowRootMode })\n\t\t\tconst target = el.shadowRoot || el\n\t\t\tschedule(el, () => {\n\t\t\t\ttarget.innerHTML = html\n\t\t\t\tif (allowScripts) {\n\t\t\t\t\t// allowScripts is the security gate; once opted in, scripts should\n\t\t\t\t\t// work correctly. Copy functional and security-hardening attributes\n\t\t\t\t\t// but not event handler attributes (e.g. onerror).\n\t\t\t\t\tconst SCRIPT_ATTRS = [\n\t\t\t\t\t\t'type',\n\t\t\t\t\t\t'src',\n\t\t\t\t\t\t'async',\n\t\t\t\t\t\t'defer',\n\t\t\t\t\t\t'nomodule',\n\t\t\t\t\t\t'crossorigin',\n\t\t\t\t\t\t'integrity',\n\t\t\t\t\t\t'referrerpolicy',\n\t\t\t\t\t\t'fetchpriority',\n\t\t\t\t\t]\n\t\t\t\t\ttarget.querySelectorAll('script').forEach(script => {\n\t\t\t\t\t\tconst newScript = document.createElement('script')\n\t\t\t\t\t\tfor (const attr of SCRIPT_ATTRS) {\n\t\t\t\t\t\t\tif (script.hasAttribute(attr))\n\t\t\t\t\t\t\t\tnewScript.setAttribute(attr, script.getAttribute(attr)!)\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Only set text content for inline scripts (no src attribute)\n\t\t\t\t\t\tif (!script.hasAttribute('src'))\n\t\t\t\t\t\t\tnewScript.appendChild(\n\t\t\t\t\t\t\t\tdocument.createTextNode(script.textContent ?? ''),\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\ttarget.appendChild(newScript)\n\t\t\t\t\t\tscript.remove()\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t})\n\t\t\treturn allowScripts ? ' with scripts' : ''\n\t\t},\n\t})\n\nexport { type DangerouslySetInnerHTMLOptions, dangerouslySetInnerHTML }\n",
    "import {\n\tcreateComputed,\n\tisFunction,\n\tisRecord,\n\tisSignal,\n\tisSlot,\n\ttype MaybeCleanup,\n\ttype Signal,\n} from '@zeix/cause-effect'\nimport type { Component, ComponentProps } from '../component'\nimport type { Effect, Reactive } from '../effects'\nimport { InvalidCustomElementError, InvalidReactivesError } from '../errors'\nimport { getSignals } from '../internal'\nimport { DEV_MODE, elementName, isCustomElement, LOG_WARN } from '../util'\n\n/* === Types === */\n\ntype PassedProp<T, P extends ComponentProps, E extends HTMLElement> =\n\t| Reactive<T, P, E>\n\t| [Reactive<T, P, E>, (value: T) => void]\n\ntype PassedProps<P extends ComponentProps, Q extends ComponentProps> = {\n\t[K in keyof Q & string]?: PassedProp<Q[K], P, Component<Q>>\n}\n\n/* === Exported Function === */\n\n/**\n * Effect for passing reactive values to a descendant Le Truc component\n * by replacing the backing signal of the target's Slot.\n *\n * No cleanup/restore is needed: when the parent unmounts, the child\n * is torn down as well. For re-parenting scenarios, use context instead.\n *\n * @since 0.15.0\n * @param {PassedProps<P, Q>} props - Reactive values to pass\n * @returns {Effect<P, Component<Q>>} Effect function that passes reactive values to the descendant component\n * @throws {InvalidCustomElementError} When the target element is not a valid custom element\n * @throws {InvalidReactivesError} When the provided reactives is not a record of signals, reactive property names or functions\n */\nconst pass =\n\t<P extends ComponentProps, Q extends ComponentProps>(\n\t\tprops: PassedProps<P, Q> | ((target: Component<Q>) => PassedProps<P, Q>),\n\t): Effect<P, Component<Q>> =>\n\t(host, target): MaybeCleanup => {\n\t\tif (!isCustomElement(target))\n\t\t\tthrow new InvalidCustomElementError(\n\t\t\t\ttarget,\n\t\t\t\t`pass from ${elementName(host)}`,\n\t\t\t)\n\t\tconst reactives = isFunction(props) ? props(target) : props\n\t\tif (!isRecord(reactives))\n\t\t\tthrow new InvalidReactivesError(host, target, reactives)\n\n\t\t// Resolve a reactive value to a Signal\n\t\tconst toSignal = (value: unknown): Signal<any> | undefined => {\n\t\t\tif (isSignal(value)) return value\n\t\t\tconst fn =\n\t\t\t\ttypeof value === 'string' && value in host\n\t\t\t\t\t? () => host[value as keyof typeof host]\n\t\t\t\t\t: isFunction(value)\n\t\t\t\t\t\t? value\n\t\t\t\t\t\t: undefined\n\t\t\treturn fn ? createComputed(fn as () => NonNullable<unknown>) : undefined\n\t\t}\n\n\t\tconst signals = getSignals(target)\n\t\tconst targetName = elementName(target)\n\n\t\tfor (const [prop, reactive] of Object.entries(reactives)) {\n\t\t\tif (reactive == null) continue\n\t\t\tif (!(prop in target)) {\n\t\t\t\tif (DEV_MODE)\n\t\t\t\t\tconsole[LOG_WARN](\n\t\t\t\t\t\t`pass(): property '${prop}' does not exist on ${targetName}`,\n\t\t\t\t\t)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Resolve the reactive to a signal\n\t\t\tconst applied =\n\t\t\t\tisFunction(reactive) && reactive.length === 1\n\t\t\t\t\t? reactive(target)\n\t\t\t\t\t: reactive\n\t\t\tconst isArray = Array.isArray(applied) && applied.length === 2\n\t\t\tconst signal = toSignal(isArray ? applied[0] : applied)\n\t\t\tif (!signal) continue\n\n\t\t\t// Replace the backing signal of the target's Slot\n\t\t\tconst slot = signals[prop]\n\t\t\tif (isSlot(slot)) {\n\t\t\t\tslot.replace(signal)\n\t\t\t} else if (DEV_MODE) {\n\t\t\t\tconsole[LOG_WARN](\n\t\t\t\t\t`pass(): property '${prop}' on ${targetName} has no Slot — binding skipped`,\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\t}\n\nexport { type PassedProp, type PassedProps, pass }\n",
    "import type { ComponentProps } from '../component'\nimport { type Effect, type Reactive, updateElement } from '../effects'\n\n/* === Exported Functions === */\n\n/**\n * Effect for setting a property on an element.\n * Sets the specified property directly on the element object.\n *\n * @since 0.8.0\n * @param {K} key - Name of the property to set\n * @param {Reactive<E[K], P, E>} reactive - Reactive value bound to the property value (defaults to property name)\n * @returns {Effect<P, E>} Effect function that sets the property on the element\n */\nconst setProperty = <\n\tP extends ComponentProps,\n\tE extends Element,\n\tK extends keyof E & string,\n>(\n\tkey: K,\n\treactive: Reactive<E[K] & {}, P, E> = key as unknown as Reactive<\n\t\tE[K] & {},\n\t\tP,\n\t\tE\n\t>,\n): Effect<P, E> =>\n\tupdateElement<E[K] & {}, P, E>(reactive, {\n\t\top: 'p',\n\t\tname: key,\n\t\tread: el => (key in el ? (el[key] ?? null) : null),\n\t\tupdate: (el, value) => {\n\t\t\tel[key] = value\n\t\t},\n\t})\n\n/**\n * Effect for controlling element visibility by setting the 'hidden' property.\n * When the reactive value is true, the element is shown; when false, it's hidden.\n *\n * @since 0.13.1\n * @param {Reactive<boolean, P, E>} reactive - Reactive value bound to the visibility state\n * @returns {Effect<P, E>} Effect function that controls element visibility\n */\nconst show = <P extends ComponentProps, E extends HTMLElement = HTMLElement>(\n\treactive: Reactive<boolean, P, E>,\n): Effect<P, E> =>\n\tupdateElement(reactive, {\n\t\top: 'p',\n\t\tname: 'hidden',\n\t\tread: el => !el.hidden,\n\t\tupdate: (el, value) => {\n\t\t\tel.hidden = !value\n\t\t},\n\t})\n\nexport { setProperty, show }\n",
    "import type { ComponentProps } from '../component'\nimport { type Effect, type Reactive, updateElement } from '../effects'\n\n/* === Exported Function === */\n\n/**\n * Effect for setting a CSS style property on an element.\n * Sets the specified style property with support for deletion via UNSET.\n *\n * @since 0.8.0\n * @param {string} prop - Name of the CSS style property to set\n * @param {Reactive<string, P, E>} reactive - Reactive value bound to the style property value (defaults to property name)\n * @returns {Effect<P, E>} Effect function that sets the style property on the element\n */\nconst setStyle = <\n\tP extends ComponentProps,\n\tE extends HTMLElement | SVGElement | MathMLElement,\n>(\n\tprop: string,\n\treactive: Reactive<string, P, E> = prop as Reactive<string, P, E>,\n): Effect<P, E> =>\n\tupdateElement(reactive, {\n\t\top: 's',\n\t\tname: prop,\n\t\tread: el => el.style.getPropertyValue(prop),\n\t\tupdate: (el, value) => {\n\t\t\tel.style.setProperty(prop, value)\n\t\t},\n\t\tdelete: el => {\n\t\t\tel.style.removeProperty(prop)\n\t\t},\n\t})\n\nexport { setStyle }\n",
    "import type { ComponentProps } from '../component'\nimport { type Effect, type Reactive, updateElement } from '../effects'\n\n/* === Exported Function === */\n\n/**\n * Effect for setting the text content of an element.\n * Replaces all child nodes (except comments) with a single text node.\n *\n * @since 0.8.0\n * @param {Reactive<string, P, E>} reactive - Reactive value bound to the text content\n * @returns {Effect<P, E>} Effect function that sets the text content of the element\n */\nconst setText = <P extends ComponentProps, E extends Element>(\n\treactive: Reactive<string, P, E>,\n): Effect<P, E> =>\n\tupdateElement(reactive, {\n\t\top: 't',\n\t\tread: el => el.textContent,\n\t\tupdate: (el, value) => {\n\t\t\tArray.from(el.childNodes)\n\t\t\t\t.filter(node => node.nodeType !== Node.COMMENT_NODE)\n\t\t\t\t.forEach(node => node.remove())\n\t\t\tel.append(document.createTextNode(value))\n\t\t},\n\t})\n\nexport { setText }\n",
    "import { createSensor, isMemo, type Sensor } from '@zeix/cause-effect'\nimport type { Component, ComponentProps } from './component'\nimport { getFallback, type ParserOrFallback } from './parsers'\nimport { PASSIVE_EVENTS, schedule } from './scheduler'\nimport type { ElementFromKey, UI } from './ui'\n\n/* === Types === */\n\ntype EventType<K extends string> = K extends keyof HTMLElementEventMap\n\t? HTMLElementEventMap[K]\n\t: Event\n\ntype SensorEventHandler<\n\tT extends {},\n\tEvt extends Event,\n\tU extends UI,\n\tE extends Element,\n> = (context: {\n\tevent: Evt\n\tui: U\n\ttarget: E\n\tprev: T\n}) => T | void | Promise<void>\n\ntype EventHandlers<T extends {}, U extends UI, E extends Element> = {\n\t[K in keyof HTMLElementEventMap]?: SensorEventHandler<T, EventType<K>, U, E>\n}\n\n/* === Exported Functions === */\n\n/**\n * Produce an event-driven sensor from transformed event data\n *\n * @since 0.16.0\n * @param {S} key - name of UI key\n * @param {ParserOrFallback<T>} init - Initial value, reader or parser\n * @param {EventHandlers<T, ElementFromSelector<S>, C>} events - Transformation functions for events\n * @returns {Extractor<Sensor<T>, C>} Extractor function for value from event\n */\nconst createEventsSensor =\n\t<T extends {}, P extends ComponentProps, U extends UI, K extends keyof U>(\n\t\tinit: ParserOrFallback<T, U>,\n\t\tkey: K,\n\t\tevents: EventHandlers<T, U, ElementFromKey<U, K>>,\n\t): ((ui: U & { host: Component<P> }) => Sensor<T>) =>\n\t(ui: U & { host: Component<P> }) => {\n\t\tconst { host } = ui\n\t\tlet value: T = getFallback(ui, init)\n\t\tconst memo = isMemo<ElementFromKey<U, K>[]>(ui[key]) ? ui[key] : null\n\t\tconst single = memo\n\t\t\t? null\n\t\t\t: (ui[key] as ElementFromKey<U & { host: Component<P> }, K>)\n\t\tconst eventMap = new Map<string, EventListener>()\n\n\t\tconst getTarget = (eventTarget: Node): ElementFromKey<U, K> | undefined => {\n\t\t\tif (single) {\n\t\t\t\treturn single.contains(eventTarget)\n\t\t\t\t\t? (single as ElementFromKey<U, K>)\n\t\t\t\t\t: undefined\n\t\t\t}\n\t\t\tfor (const t of memo!.get())\n\t\t\t\tif (t.contains(eventTarget)) return t as ElementFromKey<U, K>\n\t\t}\n\n\t\treturn createSensor<T>(\n\t\t\tset => {\n\t\t\t\tfor (const [type, handler] of Object.entries(events)) {\n\t\t\t\t\tconst options = { passive: PASSIVE_EVENTS.has(type) }\n\t\t\t\t\tconst listener = (e: Event) => {\n\t\t\t\t\t\tconst eventTarget = e.target as Node\n\t\t\t\t\t\tif (!eventTarget) return\n\t\t\t\t\t\tconst target = getTarget(eventTarget)\n\t\t\t\t\t\tif (!target) return\n\t\t\t\t\t\te.stopPropagation()\n\n\t\t\t\t\t\tconst task = () => {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tconst next = handler({\n\t\t\t\t\t\t\t\t\tevent: e as any,\n\t\t\t\t\t\t\t\t\tui,\n\t\t\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\t\t\tprev: value,\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\tif (next == null || next instanceof Promise) return\n\t\t\t\t\t\t\t\tif (!Object.is(next, value)) {\n\t\t\t\t\t\t\t\t\tvalue = next\n\t\t\t\t\t\t\t\t\tset(next)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\t\te.stopImmediatePropagation()\n\t\t\t\t\t\t\t\tthrow error\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (options.passive) schedule(host, task)\n\t\t\t\t\t\telse task()\n\t\t\t\t\t}\n\t\t\t\t\teventMap.set(type, listener)\n\t\t\t\t\thost.addEventListener(type, listener, options)\n\t\t\t\t}\n\t\t\t\treturn () => {\n\t\t\t\t\tif (eventMap.size) {\n\t\t\t\t\t\tfor (const [type, listener] of eventMap)\n\t\t\t\t\t\t\thost.removeEventListener(type, listener)\n\t\t\t\t\t\teventMap.clear()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t{ value },\n\t\t)\n\t}\n\nexport {\n\tcreateEventsSensor,\n\ttype SensorEventHandler,\n\ttype EventHandlers,\n\ttype EventType,\n}\n",
    "import type { Parser } from '../parsers'\nimport type { UI } from '../ui'\n\n/**\n * Parse a boolean attribute as an actual boolean value\n *\n * @since 0.13.1\n * @returns {Parser<boolean, UI>}\n */\nconst asBoolean =\n\t(): Parser<boolean, UI> => (_: UI, value: string | null | undefined) =>\n\t\tvalue != null && value !== 'false'\n\nexport { asBoolean }\n",
    "import { type Fallback, getFallback, type Parser } from '../parsers'\nimport type { UI } from '../ui'\n\n/**\n * Parse a string as a JSON serialized object with a fallback\n *\n * @since 0.11.0\n * @param {Fallback<T, U>} fallback - Fallback value or reader function\n * @returns {Parser<T, U>} Parser function\n * @throws {TypeError} If the value and fallback are both null or undefined\n * @throws {SyntaxError} If value is not a valid JSON string\n */\nconst asJSON =\n\t<T extends {}, U extends UI>(fallback: Fallback<T, U>): Parser<T, U> =>\n\t(ui: U, value: string | null | undefined) => {\n\t\tif ((value ?? fallback) == null)\n\t\t\tthrow new TypeError(\n\t\t\t\t'asJSON: Value and fallback are both null or undefined',\n\t\t\t)\n\t\tif (value == null) return getFallback(ui, fallback)\n\t\tif (value === '') throw new TypeError('Empty string is not valid JSON')\n\t\tlet result: T | undefined\n\t\ttry {\n\t\t\tresult = JSON.parse(value)\n\t\t} catch (error) {\n\t\t\tthrow new SyntaxError(`Failed to parse JSON: ${String(error)}`, {\n\t\t\t\tcause: error,\n\t\t\t})\n\t\t}\n\t\treturn result ?? getFallback(ui, fallback)\n\t}\n\nexport { asJSON }\n",
    "import { type Fallback, getFallback, type Parser } from '../parsers'\nimport type { UI } from '../ui'\n\n/* === Internal Functions === */\n\nconst parseNumber = (\n\tparseFn: (v: string) => number,\n\tvalue: string | null | undefined,\n) => {\n\tif (value == null) return\n\tconst parsed = parseFn(value)\n\treturn Number.isFinite(parsed) ? parsed : undefined\n}\n\n/* === Exported Functions === */\n\n/**\n * Parse a string as a number forced to integer with a fallback\n *\n * Supports hexadecimal and scientific notation\n *\n * @since 0.11.0\n * @param {Fallback<number, U>} [fallback=0] - Fallback value or reader function\n * @returns {Parser<number, U>} Parser function\n */\nconst asInteger =\n\t<U extends UI>(fallback: Fallback<number, U> = 0): Parser<number, U> =>\n\t(ui: U, value: string | null | undefined) => {\n\t\tif (value == null) return getFallback(ui, fallback)\n\n\t\t// Handle hexadecimal notation\n\t\tconst trimmed = value.trim()\n\t\tif (trimmed.toLowerCase().startsWith('0x'))\n\t\t\treturn (\n\t\t\t\tparseNumber(v => parseInt(v, 16), trimmed) ?? getFallback(ui, fallback)\n\t\t\t)\n\n\t\t// Handle other formats (including scientific notation)\n\t\tconst parsed = parseNumber(parseFloat, value)\n\t\treturn parsed != null ? Math.trunc(parsed) : getFallback(ui, fallback)\n\t}\n\n/**\n * Parse a string as a number with a fallback\n *\n * @since 0.11.0\n * @param {Fallback<number, U>} [fallback=0] - Fallback value or reader function\n * @returns {Parser<number, U>} Parser function\n */\nconst asNumber =\n\t<U extends UI>(fallback: Fallback<number, U> = 0): Parser<number, U> =>\n\t(ui: U, value: string | null | undefined) =>\n\t\tparseNumber(parseFloat, value) ?? getFallback(ui, fallback)\n\nexport { asInteger, asNumber }\n",
    "import { type Fallback, getFallback, type Parser } from '../parsers'\nimport type { UI } from '../ui'\n\n/**\n * Pass through string with a fallback\n *\n * @since 0.11.0\n * @param {Fallback<string, U>} [fallback=''] - Fallback value or reader function\n * @returns {Parser<string, U>} Parser function\n */\nconst asString =\n\t<U extends UI>(fallback: Fallback<string, U> = ''): Parser<string, U> =>\n\t(ui: U, value: string | null | undefined) =>\n\t\tvalue ?? getFallback(ui, fallback)\n\n/**\n * Parse a string as a multi-state value (for example: ['true', 'false', 'mixed'], defaulting to the first valid option\n *\n * @since 0.9.0\n * @param {[string, ...string[]]} valid - Array of valid values\n * @returns {Parser<string, UI>} Parser function\n */\nconst asEnum =\n\t(valid: [string, ...string[]]): Parser<string, UI> =>\n\t(_: UI, value: string | null | undefined) => {\n\t\tif (value == null) return valid[0]\n\t\tconst lowerValue = value.toLowerCase()\n\t\tconst matchingValid = valid.find(v => v.toLowerCase() === lowerValue)\n\t\treturn matchingValid ? value : valid[0]\n\t}\n\nexport { asString, asEnum }\n"
  ],
  "mappings": "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",
  "debugId": "C9A6B9683A24D03B64756E2164756E21",
  "names": []
}