{
  "version": 3,
  "sources": ["node_modules/@zeix/cause-effect/src/util.ts", "node_modules/@zeix/cause-effect/src/system.ts", "node_modules/@zeix/cause-effect/src/diff.ts", "node_modules/@zeix/cause-effect/src/classes/computed.ts", "node_modules/@zeix/cause-effect/src/classes/composite.ts", "node_modules/@zeix/cause-effect/src/classes/state.ts", "node_modules/@zeix/cause-effect/src/classes/list.ts", "node_modules/@zeix/cause-effect/src/classes/store.ts", "node_modules/@zeix/cause-effect/src/signal.ts", "node_modules/@zeix/cause-effect/src/errors.ts", "node_modules/@zeix/cause-effect/src/classes/collection.ts", "node_modules/@zeix/cause-effect/src/classes/ref.ts", "node_modules/@zeix/cause-effect/src/effect.ts", "node_modules/@zeix/cause-effect/src/match.ts", "node_modules/@zeix/cause-effect/src/resolve.ts", "src/util.ts", "src/errors.ts", "src/effects.ts", "src/parsers.ts", "src/signals/collection.ts", "src/ui.ts", "src/component.ts", "src/context.ts", "src/effects/attribute.ts", "src/effects/class.ts", "src/scheduler.ts", "src/effects/event.ts", "src/effects/html.ts", "src/effects/pass.ts", "src/effects/property.ts", "src/effects/style.ts", "src/effects/text.ts", "src/parsers/boolean.ts", "src/parsers/json.ts", "src/parsers/number.ts", "src/parsers/string.ts", "src/signals/sensor.ts"],
  "sourcesContent": [
    "/* === Utility Functions === */\n\nconst isString = /*#__PURE__*/ (value: unknown): value is string =>\n\ttypeof value === 'string'\n\nconst isNumber = /*#__PURE__*/ (value: unknown): value is number =>\n\ttypeof value === 'number'\n\nconst isSymbol = /*#__PURE__*/ (value: unknown): value is symbol =>\n\ttypeof value === 'symbol'\n\nconst isFunction = /*#__PURE__*/ <T>(\n\tfn: unknown,\n): fn is (...args: unknown[]) => T => typeof fn === 'function'\n\nconst isAsyncFunction = /*#__PURE__*/ <T>(\n\tfn: unknown,\n): fn is (...args: unknown[]) => Promise<T> =>\n\tisFunction(fn) && fn.constructor.name === 'AsyncFunction'\n\nconst isSyncFunction = /*#__PURE__*/ <T extends unknown & { then?: undefined }>(\n\tfn: unknown,\n): fn is (...args: unknown[]) => T =>\n\tisFunction(fn) && fn.constructor.name !== 'AsyncFunction'\n\nconst isNonNullObject = /*#__PURE__*/ (\n\tvalue: unknown,\n): value is NonNullable<object> => value != null && typeof value === 'object'\n\nconst isObjectOfType = /*#__PURE__*/ <T>(\n\tvalue: unknown,\n\ttype: string,\n): value is T => Object.prototype.toString.call(value) === `[object ${type}]`\n\nconst isRecord = /*#__PURE__*/ <T extends Record<string, unknown>>(\n\tvalue: unknown,\n): value is T => isObjectOfType(value, 'Object')\n\nconst isRecordOrArray = /*#__PURE__*/ <\n\tT extends Record<string | number, unknown> | ReadonlyArray<unknown>,\n>(\n\tvalue: unknown,\n): value is T => isRecord(value) || Array.isArray(value)\n\nconst isUniformArray = <T>(\n\tvalue: unknown,\n\tguard = (item: T): item is T & {} => item != null,\n): value is T[] => Array.isArray(value) && value.every(guard)\n\nconst hasMethod = /*#__PURE__*/ <\n\tT extends object & Record<string, (...args: unknown[]) => unknown>,\n>(\n\tobj: T,\n\tmethodName: string,\n): obj is T & Record<string, (...args: unknown[]) => unknown> =>\n\tmethodName in obj && isFunction(obj[methodName])\n\nconst isAbortError = /*#__PURE__*/ (error: unknown): boolean =>\n\terror instanceof DOMException && error.name === 'AbortError'\n\nconst valueString = /*#__PURE__*/ (value: unknown): string =>\n\tisString(value)\n\t\t? `\"${value}\"`\n\t\t: !!value && typeof value === 'object'\n\t\t\t? JSON.stringify(value)\n\t\t\t: String(value)\n\n/* === Exports === */\n\nexport {\n\tisString,\n\tisNumber,\n\tisSymbol,\n\tisFunction,\n\tisAsyncFunction,\n\tisSyncFunction,\n\tisNonNullObject,\n\tisObjectOfType,\n\tisRecord,\n\tisRecordOrArray,\n\tisUniformArray,\n\thasMethod,\n\tisAbortError,\n\tvalueString,\n}\n",
    "/* === Types === */\n\nimport { createError, InvalidHookError } from './errors'\nimport { isFunction } from './util'\n\ntype Cleanup = () => void\n\n// biome-ignore lint/suspicious/noConfusingVoidType: optional Cleanup return type\ntype MaybeCleanup = Cleanup | undefined | void\n\ntype Hook = 'add' | 'change' | 'cleanup' | 'remove' | 'sort' | 'watch'\ntype CleanupHook = 'cleanup'\ntype WatchHook = 'watch'\n\ntype HookCallback = (payload?: readonly string[]) => MaybeCleanup\n\ntype HookCallbacks = {\n\t[K in Hook]?: Set<HookCallback>\n}\n\ntype Watcher = {\n\t(): void\n\ton(type: CleanupHook, cleanup: Cleanup): void\n\tstop(): void\n}\n\n/* === Internal === */\n\n// Currently active watcher\nlet activeWatcher: Watcher | undefined\n\n// Map of signal watchers to their cleanup functions\nconst unwatchMap = new WeakMap<Set<Watcher>, Set<Cleanup>>()\n\n// Queue of pending watcher reactions for batched change notifications\nconst pendingReactions = new Set<() => void>()\nlet batchDepth = 0\n\n/* === Constants === */\n\n// biome-ignore lint/suspicious/noExplicitAny: Deliberately using any to be used as a placeholder value in any signal\nconst UNSET: any = Symbol()\n\nconst HOOK_ADD = 'add'\nconst HOOK_CHANGE = 'change'\nconst HOOK_CLEANUP = 'cleanup'\nconst HOOK_REMOVE = 'remove'\nconst HOOK_SORT = 'sort'\nconst HOOK_WATCH = 'watch'\n\n/* === Functions === */\n\n/**\n * Create a watcher to observe changes to a signal.\n *\n * A watcher is a reaction function with onCleanup and stop methods\n *\n * @since 0.14.1\n * @param {() => void} react - Function to be called when the state changes\n * @returns {Watcher} - Watcher object with off and cleanup methods\n */\nconst createWatcher = (react: () => void): Watcher => {\n\tconst cleanups = new Set<Cleanup>()\n\tconst watcher = react as Partial<Watcher>\n\twatcher.on = (type: CleanupHook, cleanup: Cleanup) => {\n\t\tif (type === HOOK_CLEANUP) cleanups.add(cleanup)\n\t\telse throw new InvalidHookError('watcher', type)\n\t}\n\twatcher.stop = () => {\n\t\ttry {\n\t\t\tfor (const cleanup of cleanups) cleanup()\n\t\t} finally {\n\t\t\tcleanups.clear()\n\t\t}\n\t}\n\treturn watcher as Watcher\n}\n\n/**\n * Subscribe by adding active watcher to the Set of watchers of a signal.\n *\n * @param {Set<Watcher>} watchers - Watchers of the signal\n * @param {Set<HookCallback>} watchHookCallbacks - HOOK_WATCH callbacks of the signal\n */\nconst subscribeActiveWatcher = (\n\twatchers: Set<Watcher>,\n\twatchHookCallbacks?: Set<HookCallback>,\n): void => {\n\t// Check if we need to trigger HOOK_WATCH callbacks\n\tif (!watchers.size && watchHookCallbacks?.size) {\n\t\tconst unwatch = triggerHook(watchHookCallbacks)\n\t\tif (unwatch) {\n\t\t\tconst unwatchCallbacks =\n\t\t\t\tunwatchMap.get(watchers) ?? new Set<Cleanup>()\n\t\t\tunwatchCallbacks.add(unwatch)\n\t\t\tif (!unwatchMap.has(watchers))\n\t\t\t\tunwatchMap.set(watchers, unwatchCallbacks)\n\t\t}\n\t}\n\n\t// Only if active watcher is not already subscribed\n\tif (activeWatcher && !watchers.has(activeWatcher)) {\n\t\tconst watcher = activeWatcher\n\n\t\twatcher.on(HOOK_CLEANUP, () => {\n\t\t\t// Remove the watcher from the Set of watchers\n\t\t\twatchers.delete(watcher)\n\n\t\t\t// If it was the last watcher, call unwatch callbacks\n\t\t\tif (!watchers.size) {\n\t\t\t\tconst unwatchCallbacks = unwatchMap.get(watchers)\n\t\t\t\tif (unwatchCallbacks) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfor (const unwatch of unwatchCallbacks) unwatch()\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tunwatchCallbacks.clear()\n\t\t\t\t\t\tunwatchMap.delete(watchers)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\t// Here the active watcher is added to the Set of watchers\n\t\twatchers.add(watcher)\n\t}\n}\n\n/**\n * Notify watchers of a signal change.\n *\n * @param {Set<Watcher>} watchers - Watchers of the signal\n * @returns {boolean} - Whether any watchers were notified\n */\nconst notifyWatchers = (watchers: Set<Watcher>): boolean => {\n\tif (!watchers.size) return false\n\tfor (const react of watchers) {\n\t\tif (batchDepth) pendingReactions.add(react)\n\t\telse react()\n\t}\n\treturn true\n}\n\n/**\n * Flush all pending reactions of enqueued watchers.\n */\nconst flushPendingReactions = () => {\n\twhile (pendingReactions.size) {\n\t\tconst watchers = Array.from(pendingReactions)\n\t\tpendingReactions.clear()\n\t\tfor (const watcher of watchers) watcher()\n\t}\n}\n\n/**\n * Batch multiple signal writes.\n *\n * @param {() => void} callback - Function with multiple signal writes to be batched\n */\nconst batchSignalWrites = (callback: () => void) => {\n\tbatchDepth++\n\ttry {\n\t\tcallback()\n\t} finally {\n\t\tflushPendingReactions()\n\t\tbatchDepth--\n\t}\n}\n\n/**\n * Run a function with signal reads in a tracking context (or temporarily untrack).\n *\n * @param {Watcher | false} watcher - Watcher to be called when the signal changes\n *                                    or false for temporary untracking while inserting auto-hydrating DOM nodes\n *                                    that might read signals (e.g., Web Components)\n * @param {() => void} run - Function to run the computation or effect\n */\nconst trackSignalReads = (watcher: Watcher | false, run: () => void): void => {\n\tconst prev = activeWatcher\n\tactiveWatcher = watcher || undefined\n\ttry {\n\t\trun()\n\t} finally {\n\t\tactiveWatcher = prev\n\t}\n}\n\n/**\n * Trigger a hook.\n *\n * @param {Set<HookCallback> | undefined} callbacks - Callbacks to be called when the hook is triggered\n * @param {readonly string[] | undefined} payload - Payload to be sent to listeners\n * @return {Cleanup | undefined} Cleanup function to be called when the hook is unmounted\n */\nconst triggerHook = (\n\tcallbacks: Set<HookCallback> | undefined,\n\tpayload?: readonly string[],\n): Cleanup | undefined => {\n\tif (!callbacks) return\n\n\tconst cleanups: Cleanup[] = []\n\tconst errors: Error[] = []\n\n\tconst throwError = (inCleanup?: boolean) => {\n\t\tif (errors.length) {\n\t\t\tif (errors.length === 1) throw errors[0]\n\t\t\tthrow new AggregateError(\n\t\t\t\terrors,\n\t\t\t\t`Errors in hook ${inCleanup ? 'cleanup' : 'callback'}:`,\n\t\t\t)\n\t\t}\n\t}\n\n\tfor (const callback of callbacks) {\n\t\ttry {\n\t\t\tconst cleanup = callback(payload)\n\t\t\tif (isFunction(cleanup)) cleanups.push(cleanup)\n\t\t} catch (error) {\n\t\t\terrors.push(createError(error))\n\t\t}\n\t}\n\tthrowError()\n\n\tif (!cleanups.length) return\n\tif (cleanups.length === 1) return cleanups[0]\n\treturn () => {\n\t\tfor (const cleanup of cleanups) {\n\t\t\ttry {\n\t\t\t\tcleanup()\n\t\t\t} catch (error) {\n\t\t\t\terrors.push(createError(error))\n\t\t\t}\n\t\t}\n\t\tthrowError(true)\n\t}\n}\n\n/**\n * Check whether a hook type is handled in a signal.\n *\n * @param {Hook} type - Type of hook to check\n * @param {T} handled - List of handled hook types\n * @returns {type is T[number]} - Whether the hook type is handled\n */\nconst isHandledHook = <T extends readonly Hook[]>(\n\ttype: Hook,\n\thandled: T,\n): type is T[number] => handled.includes(type)\n\n/* === Exports === */\n\nexport {\n\ttype Cleanup,\n\ttype MaybeCleanup,\n\ttype Watcher,\n\ttype Hook,\n\ttype CleanupHook,\n\ttype WatchHook,\n\ttype HookCallback,\n\ttype HookCallbacks,\n\tHOOK_ADD,\n\tHOOK_CHANGE,\n\tHOOK_CLEANUP,\n\tHOOK_REMOVE,\n\tHOOK_SORT,\n\tHOOK_WATCH,\n\tUNSET,\n\tcreateWatcher,\n\tsubscribeActiveWatcher,\n\tnotifyWatchers,\n\tflushPendingReactions,\n\tbatchSignalWrites,\n\ttrackSignalReads,\n\ttriggerHook,\n\tisHandledHook,\n}\n",
    "import { CircularDependencyError } from './errors'\nimport { UNSET } from './system'\nimport { isNonNullObject, isRecord, isRecordOrArray } from './util'\n\n/* === Types === */\n\ntype UnknownRecord = Record<string, unknown>\ntype UnknownArray = ReadonlyArray<unknown & {}>\n\ntype DiffResult = {\n\tchanged: boolean\n\tadd: UnknownRecord\n\tchange: UnknownRecord\n\tremove: UnknownRecord\n}\n\n/* === Functions === */\n\n/**\n * Checks if two values are equal with cycle detection\n *\n * @since 0.15.0\n * @param {T} a - First value to compare\n * @param {T} b - Second value to compare\n * @param {WeakSet<object>} visited - Set to track visited objects for cycle detection\n * @returns {boolean} Whether the two values are equal\n */\nconst isEqual = <T>(a: T, b: T, visited?: WeakSet<object>): boolean => {\n\t// Fast paths\n\tif (Object.is(a, b)) return true\n\tif (typeof a !== typeof b) return false\n\tif (!isNonNullObject(a) || !isNonNullObject(b)) return false\n\n\t// Cycle detection\n\tif (!visited) visited = new WeakSet()\n\tif (visited.has(a as object) || visited.has(b as object))\n\t\tthrow new CircularDependencyError('isEqual')\n\tvisited.add(a)\n\tvisited.add(b)\n\n\ttry {\n\t\tif (Array.isArray(a) && Array.isArray(b)) {\n\t\t\tif (a.length !== b.length) return false\n\t\t\tfor (let i = 0; i < a.length; i++) {\n\t\t\t\tif (!isEqual(a[i], b[i], visited)) return false\n\t\t\t}\n\t\t\treturn true\n\t\t}\n\n\t\tif (Array.isArray(a) !== Array.isArray(b)) return false\n\n\t\tif (isRecord(a) && isRecord(b)) {\n\t\t\tconst aKeys = Object.keys(a)\n\t\t\tconst bKeys = Object.keys(b)\n\n\t\t\tif (aKeys.length !== bKeys.length) return false\n\t\t\tfor (const key of aKeys) {\n\t\t\t\tif (!(key in b)) return false\n\t\t\t\tif (!isEqual(a[key], b[key], visited)) return false\n\t\t\t}\n\t\t\treturn true\n\t\t}\n\n\t\t// For non-records/non-arrays, they are only equal if they are the same reference\n\t\t// (which would have been caught by Object.is at the beginning)\n\t\treturn false\n\t} finally {\n\t\tvisited.delete(a)\n\t\tvisited.delete(b)\n\t}\n}\n\n/**\n * Compares two records and returns a result object containing the differences.\n *\n * @since 0.15.0\n * @param {T} oldObj - The old record to compare\n * @param {T} newObj - The new record to compare\n * @returns {DiffResult} The result of the comparison\n */\nconst diff = <T extends UnknownRecord>(oldObj: T, newObj: T): DiffResult => {\n\t// Guard against non-objects that can't be diffed properly with Object.keys and 'in' operator\n\tconst oldValid = isRecordOrArray(oldObj)\n\tconst newValid = isRecordOrArray(newObj)\n\tif (!oldValid || !newValid) {\n\t\t// For non-objects or non-plain objects, treat as complete change if different\n\t\tconst changed = !Object.is(oldObj, newObj)\n\t\treturn {\n\t\t\tchanged,\n\t\t\tadd: changed && newValid ? newObj : {},\n\t\t\tchange: {},\n\t\t\tremove: changed && oldValid ? oldObj : {},\n\t\t}\n\t}\n\n\tconst visited = new WeakSet()\n\n\tconst add = {} as UnknownRecord\n\tconst change = {} as UnknownRecord\n\tconst remove = {} as UnknownRecord\n\n\tconst oldKeys = Object.keys(oldObj)\n\tconst newKeys = Object.keys(newObj)\n\tconst allKeys = new Set([...oldKeys, ...newKeys])\n\n\tfor (const key of allKeys) {\n\t\tconst oldHas = key in oldObj\n\t\tconst newHas = key in newObj\n\n\t\tif (!oldHas && newHas) {\n\t\t\tadd[key] = newObj[key]\n\t\t\tcontinue\n\t\t} else if (oldHas && !newHas) {\n\t\t\tremove[key] = UNSET\n\t\t\tcontinue\n\t\t}\n\n\t\tconst oldValue = oldObj[key]\n\t\tconst newValue = newObj[key]\n\n\t\tif (!isEqual(oldValue, newValue, visited)) change[key] = newValue\n\t}\n\n\treturn {\n\t\tadd,\n\t\tchange,\n\t\tremove,\n\t\tchanged: !!(\n\t\t\tObject.keys(add).length ||\n\t\t\tObject.keys(change).length ||\n\t\t\tObject.keys(remove).length\n\t\t),\n\t}\n}\n\n/* === Exports === */\n\nexport { type DiffResult, diff, isEqual, type UnknownRecord, type UnknownArray }\n",
    "import { isEqual } from '../diff'\nimport {\n\tCircularDependencyError,\n\tcreateError,\n\tInvalidHookError,\n\tvalidateCallback,\n\tvalidateSignalValue,\n} from '../errors'\nimport {\n\ttype Cleanup,\n\tcreateWatcher,\n\tflushPendingReactions,\n\tHOOK_CLEANUP,\n\tHOOK_WATCH,\n\ttype HookCallback,\n\tnotifyWatchers,\n\tsubscribeActiveWatcher,\n\ttrackSignalReads,\n\tUNSET,\n\ttype Watcher,\n\ttype WatchHook,\n} from '../system'\nimport {\n\tisAbortError,\n\tisAsyncFunction,\n\tisObjectOfType,\n\tisSyncFunction,\n} from '../util'\n\n/* === Types === */\n\ntype Computed<T extends {}> = {\n\treadonly [Symbol.toStringTag]: 'Computed'\n\tget(): T\n}\n\ntype MemoCallback<T extends {} & { then?: undefined }> = (oldValue: T) => T\n\ntype TaskCallback<T extends {} & { then?: undefined }> = (\n\toldValue: T,\n\tabort: AbortSignal,\n) => Promise<T>\n\n/* === Constants === */\n\nconst TYPE_COMPUTED = 'Computed' as const\n\n/* === Classes === */\n\n/**\n * Create a new memoized signal for a synchronous function.\n *\n * @since 0.17.0\n */\nclass Memo<T extends {}> {\n\t#watchers: Set<Watcher> = new Set()\n\t#callback: MemoCallback<T>\n\t#value: T\n\t#error: Error | undefined\n\t#dirty = true\n\t#computing = false\n\t#watcher: Watcher | undefined\n\t#watchHookCallbacks: Set<HookCallback> | undefined\n\n\t/**\n\t * Create a new memoized signal.\n\t *\n\t * @param {MemoCallback<T>} callback - Callback function to compute the memoized value\n\t * @param {T} [initialValue = UNSET] - Initial value of the signal\n\t * @throws {InvalidCallbackError} If the callback is not an sync function\n\t * @throws {InvalidSignalValueError} If the initial value is not valid\n\t */\n\tconstructor(callback: MemoCallback<T>, initialValue: T = UNSET) {\n\t\tvalidateCallback(this.constructor.name, callback, isMemoCallback)\n\t\tvalidateSignalValue(this.constructor.name, initialValue)\n\n\t\tthis.#callback = callback\n\t\tthis.#value = initialValue\n\t}\n\n\t#getWatcher(): Watcher {\n\t\tif (!this.#watcher) {\n\t\t\t// Own watcher: called by notifyWatchers() in upstream signals (push)\n\t\t\tthis.#watcher = createWatcher(() => {\n\t\t\t\tthis.#dirty = true\n\t\t\t\tif (!notifyWatchers(this.#watchers)) this.#watcher?.stop()\n\t\t\t})\n\t\t\tthis.#watcher.on(HOOK_CLEANUP, () => {\n\t\t\t\tthis.#watcher = undefined\n\t\t\t})\n\t\t}\n\t\treturn this.#watcher\n\t}\n\n\tget [Symbol.toStringTag](): 'Computed' {\n\t\treturn TYPE_COMPUTED\n\t}\n\n\t/**\n\t * Return the memoized value after computing it if necessary.\n\t *\n\t * @returns {T}\n\t * @throws {CircularDependencyError} If a circular dependency is detected\n\t * @throws {Error} If an error occurs during computation\n\t */\n\tget(): T {\n\t\tsubscribeActiveWatcher(this.#watchers, this.#watchHookCallbacks)\n\t\tflushPendingReactions()\n\n\t\tif (this.#dirty) {\n\t\t\tconst watcher = this.#getWatcher()\n\t\t\ttrackSignalReads(watcher, () => {\n\t\t\t\tif (this.#computing) throw new CircularDependencyError('memo')\n\n\t\t\t\tlet result: T\n\t\t\t\tthis.#computing = true\n\t\t\t\ttry {\n\t\t\t\t\tresult = this.#callback(this.#value)\n\t\t\t\t} catch (e) {\n\t\t\t\t\t// Err track\n\t\t\t\t\tthis.#value = UNSET\n\t\t\t\t\tthis.#error = createError(e)\n\t\t\t\t\tthis.#computing = false\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tif (null == result || UNSET === result) {\n\t\t\t\t\t// Nil track\n\t\t\t\t\tthis.#value = UNSET\n\t\t\t\t\tthis.#error = undefined\n\t\t\t\t} else {\n\t\t\t\t\t// Ok track\n\t\t\t\t\tthis.#value = result\n\t\t\t\t\tthis.#error = undefined\n\t\t\t\t\tthis.#dirty = false\n\t\t\t\t}\n\t\t\t\tthis.#computing = false\n\t\t\t})\n\t\t}\n\n\t\tif (this.#error) throw this.#error\n\t\treturn this.#value\n\t}\n\n\t/**\n\t * Register a callback to be called when HOOK_WATCH is triggered.\n\t *\n\t * @param {WatchHook} type - The type of hook to register the callback for; only HOOK_WATCH is supported\n\t * @param {HookCallback} callback - The callback to register\n\t * @returns {Cleanup} - A function to unregister the callback\n\t */\n\ton(type: WatchHook, callback: HookCallback): Cleanup {\n\t\tif (type === HOOK_WATCH) {\n\t\t\tthis.#watchHookCallbacks ||= new Set()\n\t\t\tthis.#watchHookCallbacks.add(callback)\n\t\t\treturn () => {\n\t\t\t\tthis.#watchHookCallbacks?.delete(callback)\n\t\t\t}\n\t\t}\n\t\tthrow new InvalidHookError(this.constructor.name, type)\n\t}\n}\n\n/**\n * Create a new task signals that memoizes the result of an asynchronous function.\n *\n * @since 0.17.0\n */\nclass Task<T extends {}> {\n\t#watchers: Set<Watcher> = new Set()\n\t#callback: TaskCallback<T>\n\t#value: T\n\t#error: Error | undefined\n\t#dirty = true\n\t#computing = false\n\t#changed = false\n\t#watcher: Watcher | undefined\n\t#controller: AbortController | undefined\n\t#watchHookCallbacks: Set<HookCallback> | undefined\n\n\t/**\n\t * Create a new task signal for an asynchronous function.\n\t *\n\t * @param {TaskCallback<T>} callback - The asynchronous function to compute the memoized value\n\t * @param {T} [initialValue = UNSET] - Initial value of the signal\n\t * @throws {InvalidCallbackError} If the callback is not an async function\n\t * @throws {InvalidSignalValueError} If the initial value is not valid\n\t */\n\tconstructor(callback: TaskCallback<T>, initialValue: T = UNSET) {\n\t\tvalidateCallback(this.constructor.name, callback, isTaskCallback)\n\t\tvalidateSignalValue(this.constructor.name, initialValue)\n\n\t\tthis.#callback = callback\n\t\tthis.#value = initialValue\n\t}\n\n\t#getWatcher(): Watcher {\n\t\tif (!this.#watcher) {\n\t\t\t// Own watcher: called by notifyWatchers() in upstream signals (push)\n\t\t\tthis.#watcher = createWatcher(() => {\n\t\t\t\tthis.#dirty = true\n\t\t\t\tthis.#controller?.abort()\n\t\t\t\tif (!notifyWatchers(this.#watchers)) this.#watcher?.stop()\n\t\t\t})\n\t\t\tthis.#watcher.on(HOOK_CLEANUP, () => {\n\t\t\t\tthis.#controller?.abort()\n\t\t\t\tthis.#controller = undefined\n\t\t\t\tthis.#watcher = undefined\n\t\t\t})\n\t\t}\n\t\treturn this.#watcher\n\t}\n\n\tget [Symbol.toStringTag](): 'Computed' {\n\t\treturn TYPE_COMPUTED\n\t}\n\n\t/**\n\t * Return the memoized value after executing the async function if necessary.\n\t *\n\t * @returns {T}\n\t * @throws {CircularDependencyError} If a circular dependency is detected\n\t * @throws {Error} If an error occurs during computation\n\t */\n\tget(): T {\n\t\tsubscribeActiveWatcher(this.#watchers, this.#watchHookCallbacks)\n\t\tflushPendingReactions()\n\n\t\t// Functions to update internal state\n\t\tconst ok = (v: T): undefined => {\n\t\t\tif (!isEqual(v, this.#value)) {\n\t\t\t\tthis.#value = v\n\t\t\t\tthis.#changed = true\n\t\t\t}\n\t\t\tthis.#error = undefined\n\t\t\tthis.#dirty = false\n\t\t}\n\t\tconst nil = (): undefined => {\n\t\t\tthis.#changed = UNSET !== this.#value\n\t\t\tthis.#value = UNSET\n\t\t\tthis.#error = undefined\n\t\t}\n\t\tconst err = (e: unknown): undefined => {\n\t\t\tconst newError = createError(e)\n\t\t\tthis.#changed =\n\t\t\t\t!this.#error ||\n\t\t\t\tnewError.name !== this.#error.name ||\n\t\t\t\tnewError.message !== this.#error.message\n\t\t\tthis.#value = UNSET\n\t\t\tthis.#error = newError\n\t\t}\n\t\tconst settle =\n\t\t\t<T>(fn: (arg: T) => void) =>\n\t\t\t(arg: T) => {\n\t\t\t\tthis.#computing = false\n\t\t\t\tthis.#controller = undefined\n\t\t\t\tfn(arg)\n\t\t\t\tif (this.#changed && !notifyWatchers(this.#watchers))\n\t\t\t\t\tthis.#watcher?.stop()\n\t\t\t}\n\n\t\tconst compute = () =>\n\t\t\ttrackSignalReads(this.#getWatcher(), () => {\n\t\t\t\tif (this.#computing) throw new CircularDependencyError('task')\n\t\t\t\tthis.#changed = false\n\n\t\t\t\t// Return current value until promise resolves\n\t\t\t\tif (this.#controller) return this.#value\n\n\t\t\t\tthis.#controller = new AbortController()\n\t\t\t\tthis.#controller.signal.addEventListener(\n\t\t\t\t\t'abort',\n\t\t\t\t\t() => {\n\t\t\t\t\t\tthis.#computing = false\n\t\t\t\t\t\tthis.#controller = undefined\n\n\t\t\t\t\t\t// Retry computation with updated state\n\t\t\t\t\t\tcompute()\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tonce: true,\n\t\t\t\t\t},\n\t\t\t\t)\n\t\t\t\tlet result: Promise<T>\n\t\t\t\tthis.#computing = true\n\t\t\t\ttry {\n\t\t\t\t\tresult = this.#callback(\n\t\t\t\t\t\tthis.#value,\n\t\t\t\t\t\tthis.#controller.signal,\n\t\t\t\t\t)\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (isAbortError(e)) nil()\n\t\t\t\t\telse err(e)\n\t\t\t\t\tthis.#computing = false\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tif (result instanceof Promise)\n\t\t\t\t\tresult.then(settle(ok), settle(err))\n\t\t\t\telse if (null == result || UNSET === result) nil()\n\t\t\t\telse ok(result)\n\t\t\t\tthis.#computing = false\n\t\t\t})\n\n\t\tif (this.#dirty) compute()\n\n\t\tif (this.#error) throw this.#error\n\t\treturn this.#value\n\t}\n\n\t/**\n\t * Register a callback to be called when HOOK_WATCH is triggered.\n\t *\n\t * @param {WatchHook} type - The type of hook to register the callback for; only HOOK_WATCH is supported\n\t * @param {HookCallback} callback - The callback to register\n\t * @returns {Cleanup} - A function to unregister the callback\n\t */\n\ton(type: WatchHook, callback: HookCallback): Cleanup {\n\t\tif (type === HOOK_WATCH) {\n\t\t\tthis.#watchHookCallbacks ||= new Set()\n\t\t\tthis.#watchHookCallbacks.add(callback)\n\t\t\treturn () => {\n\t\t\t\tthis.#watchHookCallbacks?.delete(callback)\n\t\t\t}\n\t\t}\n\t\tthrow new InvalidHookError(this.constructor.name, type)\n\t}\n}\n\n/* === Functions === */\n\n/**\n * Create a derived signal from existing signals\n *\n * @since 0.9.0\n * @param {MemoCallback<T> | TaskCallback<T>} callback - Computation callback function\n */\nconst createComputed = <T extends {}>(\n\tcallback: TaskCallback<T> | MemoCallback<T>,\n\tinitialValue: T = UNSET,\n) =>\n\tisAsyncFunction(callback)\n\t\t? new Task(callback as TaskCallback<T>, initialValue)\n\t\t: new Memo(callback as MemoCallback<T>, initialValue)\n\n/**\n * Check if a value is a computed signal\n *\n * @since 0.9.0\n * @param {unknown} value - Value to check\n * @returns {boolean} - True if value is a computed signal, false otherwise\n */\nconst isComputed = /*#__PURE__*/ <T extends {}>(\n\tvalue: unknown,\n): value is Memo<T> => isObjectOfType(value, TYPE_COMPUTED)\n\n/**\n * Check if the provided value is a callback that may be used as input for createSignal() to derive a computed state\n *\n * @since 0.12.0\n * @param {unknown} value - Value to check\n * @returns {boolean} - True if value is a sync callback, false otherwise\n */\nconst isMemoCallback = /*#__PURE__*/ <T extends {} & { then?: undefined }>(\n\tvalue: unknown,\n): value is MemoCallback<T> => isSyncFunction(value) && value.length < 2\n\n/**\n * Check if the provided value is a callback that may be used as input for createSignal() to derive a computed state\n *\n * @since 0.17.0\n * @param {unknown} value - Value to check\n * @returns {boolean} - True if value is an async callback, false otherwise\n */\nconst isTaskCallback = /*#__PURE__*/ <T extends {}>(\n\tvalue: unknown,\n): value is TaskCallback<T> => isAsyncFunction(value) && value.length < 3\n\n/* === Exports === */\n\nexport {\n\tTYPE_COMPUTED,\n\tcreateComputed,\n\tisComputed,\n\tisMemoCallback,\n\tisTaskCallback,\n\tMemo,\n\tTask,\n\ttype Computed,\n\ttype MemoCallback,\n\ttype TaskCallback,\n}\n",
    "import type { DiffResult, UnknownRecord } from '../diff'\nimport { guardMutableSignal, InvalidHookError } from '../errors'\nimport type { Signal } from '../signal'\nimport {\n\tbatchSignalWrites,\n\ttype Cleanup,\n\tcreateWatcher,\n\tHOOK_ADD,\n\tHOOK_CHANGE,\n\tHOOK_REMOVE,\n\ttype HookCallback,\n\ttype HookCallbacks,\n\tisHandledHook,\n\ttrackSignalReads,\n\ttriggerHook,\n\ttype Watcher,\n} from '../system'\n\n/* === Types === */\n\ntype CompositeHook = 'add' | 'change' | 'remove'\n\n/* === Class Definitions === */\n\nclass Composite<T extends UnknownRecord, S extends Signal<T[keyof T] & {}>> {\n\tsignals = new Map<string, S>()\n\t#validate: <K extends keyof T & string>(\n\t\tkey: K,\n\t\tvalue: unknown,\n\t) => value is T[K] & {}\n\t#create: <V extends T[keyof T] & {}>(value: V) => S\n\t#watchers = new Map<string, Watcher>()\n\t#hookCallbacks: HookCallbacks = {}\n\t#batching = false\n\n\tconstructor(\n\t\tvalues: T,\n\t\tvalidate: <K extends keyof T & string>(\n\t\t\tkey: K,\n\t\t\tvalue: unknown,\n\t\t) => value is T[K] & {},\n\t\tcreate: <V extends T[keyof T] & {}>(value: V) => S,\n\t) {\n\t\tthis.#validate = validate\n\t\tthis.#create = create\n\t\tthis.change(\n\t\t\t{\n\t\t\t\tadd: values,\n\t\t\t\tchange: {},\n\t\t\t\tremove: {},\n\t\t\t\tchanged: true,\n\t\t\t},\n\t\t\ttrue,\n\t\t)\n\t}\n\n\t#addWatcher(key: string): void {\n\t\tconst watcher = createWatcher(() => {\n\t\t\ttrackSignalReads(watcher, () => {\n\t\t\t\tthis.signals.get(key)?.get() // Subscribe to the signal\n\t\t\t\tif (!this.#batching)\n\t\t\t\t\ttriggerHook(this.#hookCallbacks.change, [key])\n\t\t\t})\n\t\t})\n\t\tthis.#watchers.set(key, watcher)\n\t\twatcher()\n\t}\n\n\tadd<K extends keyof T & string>(key: K, value: T[K]): boolean {\n\t\tif (!this.#validate(key, value)) return false\n\n\t\tthis.signals.set(key, this.#create(value))\n\t\tif (this.#hookCallbacks.change?.size) this.#addWatcher(key)\n\n\t\tif (!this.#batching) triggerHook(this.#hookCallbacks.add, [key])\n\t\treturn true\n\t}\n\n\tremove<K extends keyof T & string>(key: K): boolean {\n\t\tconst ok = this.signals.delete(key)\n\t\tif (!ok) return false\n\n\t\tconst watcher = this.#watchers.get(key)\n\t\tif (watcher) {\n\t\t\twatcher.stop()\n\t\t\tthis.#watchers.delete(key)\n\t\t}\n\n\t\tif (!this.#batching) triggerHook(this.#hookCallbacks.remove, [key])\n\t\treturn true\n\t}\n\n\tchange(changes: DiffResult, initialRun?: boolean): boolean {\n\t\tthis.#batching = true\n\n\t\t// Additions\n\t\tif (Object.keys(changes.add).length) {\n\t\t\tfor (const key in changes.add)\n\t\t\t\tthis.add(\n\t\t\t\t\tkey as Extract<keyof T, string>,\n\t\t\t\t\tchanges.add[key] as T[Extract<keyof T, string>] & {},\n\t\t\t\t)\n\n\t\t\t// Queue initial additions event to allow listeners to be added first\n\t\t\tconst notify = () =>\n\t\t\t\ttriggerHook(this.#hookCallbacks.add, Object.keys(changes.add))\n\t\t\tif (initialRun) setTimeout(notify, 0)\n\t\t\telse notify()\n\t\t}\n\n\t\t// Changes\n\t\tif (Object.keys(changes.change).length) {\n\t\t\tbatchSignalWrites(() => {\n\t\t\t\tfor (const key in changes.change) {\n\t\t\t\t\tconst value = changes.change[key]\n\t\t\t\t\tif (!this.#validate(key as keyof T & string, value))\n\t\t\t\t\t\tcontinue\n\n\t\t\t\t\tconst signal = this.signals.get(key)\n\t\t\t\t\tif (guardMutableSignal(`list item \"${key}\"`, value, signal))\n\t\t\t\t\t\tsignal.set(value)\n\t\t\t\t}\n\t\t\t})\n\t\t\ttriggerHook(this.#hookCallbacks.change, Object.keys(changes.change))\n\t\t}\n\n\t\t// Removals\n\t\tif (Object.keys(changes.remove).length) {\n\t\t\tfor (const key in changes.remove)\n\t\t\t\tthis.remove(key as keyof T & string)\n\t\t\ttriggerHook(this.#hookCallbacks.remove, Object.keys(changes.remove))\n\t\t}\n\n\t\tthis.#batching = false\n\t\treturn changes.changed\n\t}\n\n\tclear(): boolean {\n\t\tconst keys = Array.from(this.signals.keys())\n\t\tthis.signals.clear()\n\t\tthis.#watchers.clear()\n\t\ttriggerHook(this.#hookCallbacks.remove, keys)\n\t\treturn true\n\t}\n\n\ton(type: CompositeHook, callback: HookCallback): Cleanup {\n\t\tif (!isHandledHook(type, [HOOK_ADD, HOOK_CHANGE, HOOK_REMOVE]))\n\t\t\tthrow new InvalidHookError('Composite', type)\n\n\t\tthis.#hookCallbacks[type] ||= new Set()\n\t\tthis.#hookCallbacks[type].add(callback)\n\t\tif (type === HOOK_CHANGE && !this.#watchers.size) {\n\t\t\tthis.#batching = true\n\t\t\tfor (const key of this.signals.keys()) this.#addWatcher(key)\n\t\t\tthis.#batching = false\n\t\t}\n\n\t\treturn () => {\n\t\t\tthis.#hookCallbacks[type]?.delete(callback)\n\t\t\tif (type === HOOK_CHANGE && !this.#hookCallbacks.change?.size) {\n\t\t\t\tif (this.#watchers.size) {\n\t\t\t\t\tfor (const watcher of this.#watchers.values())\n\t\t\t\t\t\twatcher.stop()\n\t\t\t\t\tthis.#watchers.clear()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport { Composite, type CompositeHook as CompositeListeners }\n",
    "import { isEqual } from '../diff'\nimport {\n\tInvalidHookError,\n\tvalidateCallback,\n\tvalidateSignalValue,\n} from '../errors'\nimport {\n\ttype Cleanup,\n\tHOOK_WATCH,\n\ttype HookCallback,\n\tnotifyWatchers,\n\tsubscribeActiveWatcher,\n\tUNSET,\n\ttype Watcher,\n\ttype WatchHook,\n} from '../system'\nimport { isObjectOfType } from '../util'\n\n/* === Constants === */\n\nconst TYPE_STATE = 'State' as const\n\n/* === Class === */\n\n/**\n * Create a new state signal.\n *\n * @since 0.17.0\n */\nclass State<T extends {}> {\n\t#watchers = new Set<Watcher>()\n\t#value: T\n\t#watchHookCallbacks: Set<HookCallback> | undefined\n\n\t/**\n\t * Create a new state signal.\n\t *\n\t * @param {T} initialValue - Initial value of the state\n\t * @throws {NullishSignalValueError} - If the initial value is null or undefined\n\t * @throws {InvalidSignalValueError} - If the initial value is invalid\n\t */\n\tconstructor(initialValue: T) {\n\t\tvalidateSignalValue(TYPE_STATE, initialValue)\n\n\t\tthis.#value = initialValue\n\t}\n\n\tget [Symbol.toStringTag](): string {\n\t\treturn TYPE_STATE\n\t}\n\n\t/**\n\t * Get the current value of the state signal.\n\t *\n\t * @returns {T} - Current value of the state\n\t */\n\tget(): T {\n\t\tsubscribeActiveWatcher(this.#watchers, this.#watchHookCallbacks)\n\n\t\treturn this.#value\n\t}\n\n\t/**\n\t * Set the value of the state signal.\n\t *\n\t * @param {T} newValue - New value of the state\n\t * @returns {void}\n\t * @throws {NullishSignalValueError} - If the initial value is null or undefined\n\t * @throws {InvalidSignalValueError} - If the initial value is invalid\n\t */\n\tset(newValue: T): void {\n\t\tvalidateSignalValue(TYPE_STATE, newValue)\n\n\t\tif (isEqual(this.#value, newValue)) return\n\t\tthis.#value = newValue\n\t\tif (this.#watchers.size) notifyWatchers(this.#watchers)\n\n\t\t// Setting to UNSET clears the watchers so the signal can be garbage collected\n\t\tif (UNSET === this.#value) this.#watchers.clear()\n\t}\n\n\t/**\n\t * Update the value of the state signal.\n\t *\n\t * @param {Function} updater - Function that takes the current value and returns the new value\n\t * @returns {void}\n\t * @throws {InvalidCallbackError} - If the updater function is not a function\n\t * @throws {NullishSignalValueError} - If the initial value is null or undefined\n\t * @throws {InvalidSignalValueError} - If the initial value is invalid\n\t */\n\tupdate(updater: (oldValue: T) => T): void {\n\t\tvalidateCallback(`${TYPE_STATE} update`, updater)\n\n\t\tthis.set(updater(this.#value))\n\t}\n\n\t/**\n\t * Register a callback to be called when HOOK_WATCH is triggered.\n\t *\n\t * @param {WatchHook} type - The type of hook to register the callback for; only HOOK_WATCH is supported\n\t * @param {HookCallback} callback - The callback to register\n\t * @returns {Cleanup} - A function to unregister the callback\n\t */\n\ton(type: WatchHook, callback: HookCallback): Cleanup {\n\t\tif (type === HOOK_WATCH) {\n\t\t\tthis.#watchHookCallbacks ||= new Set()\n\t\t\tthis.#watchHookCallbacks.add(callback)\n\t\t\treturn () => {\n\t\t\t\tthis.#watchHookCallbacks?.delete(callback)\n\t\t\t}\n\t\t}\n\t\tthrow new InvalidHookError(this.constructor.name, type)\n\t}\n}\n\n/* === Functions === */\n\n/**\n * Check if the provided value is a State instance\n *\n * @since 0.9.0\n * @param {unknown} value - Value to check\n * @returns {boolean} - True if the value is a State instance, false otherwise\n */\nconst isState = /*#__PURE__*/ <T extends {}>(\n\tvalue: unknown,\n): value is State<T> => isObjectOfType(value, TYPE_STATE)\n\n/* === Exports === */\n\nexport { TYPE_STATE, isState, State }\n",
    "import { diff, isEqual, type UnknownArray } from '../diff'\nimport {\n\tDuplicateKeyError,\n\tInvalidHookError,\n\tvalidateSignalValue,\n} from '../errors'\nimport {\n\ttype Cleanup,\n\tHOOK_ADD,\n\tHOOK_CHANGE,\n\tHOOK_REMOVE,\n\tHOOK_SORT,\n\tHOOK_WATCH,\n\ttype Hook,\n\ttype HookCallback,\n\ttype HookCallbacks,\n\tisHandledHook,\n\tnotifyWatchers,\n\tsubscribeActiveWatcher,\n\ttriggerHook,\n\tUNSET,\n\ttype Watcher,\n} from '../system'\nimport { isFunction, isNumber, isObjectOfType, isString } from '../util'\nimport { type CollectionCallback, DerivedCollection } from './collection'\nimport { Composite } from './composite'\nimport { State } from './state'\n\n/* === Types === */\n\ntype ArrayToRecord<T extends UnknownArray> = {\n\t[key: string]: T extends Array<infer U extends {}> ? U : never\n}\n\ntype KeyConfig<T> = string | ((item: T) => string)\n\n/* === Constants === */\n\nconst TYPE_LIST = 'List' as const\n\n/* === Class === */\n\nclass List<T extends {}> {\n\t#composite: Composite<Record<string, T>, State<T>>\n\t#watchers = new Set<Watcher>()\n\t#hookCallbacks: HookCallbacks = {}\n\t#order: string[] = []\n\t#generateKey: (item: T) => string\n\n\tconstructor(initialValue: T[], keyConfig?: KeyConfig<T>) {\n\t\tvalidateSignalValue(TYPE_LIST, initialValue, Array.isArray)\n\n\t\tlet keyCounter = 0\n\t\tthis.#generateKey = isString(keyConfig)\n\t\t\t? () => `${keyConfig}${keyCounter++}`\n\t\t\t: isFunction<string>(keyConfig)\n\t\t\t\t? (item: T) => keyConfig(item)\n\t\t\t\t: () => String(keyCounter++)\n\n\t\tthis.#composite = new Composite<ArrayToRecord<T[]>, State<T>>(\n\t\t\tthis.#toRecord(initialValue),\n\t\t\t(key: string, value: unknown): value is T => {\n\t\t\t\tvalidateSignalValue(`${TYPE_LIST} for key \"${key}\"`, value)\n\t\t\t\treturn true\n\t\t\t},\n\t\t\tvalue => new State(value),\n\t\t)\n\t}\n\n\t// Convert array to record with stable keys\n\t#toRecord(array: T[]): ArrayToRecord<T[]> {\n\t\tconst record = {} as Record<string, T>\n\n\t\tfor (let i = 0; i < array.length; i++) {\n\t\t\tconst value = array[i]\n\t\t\tif (value === undefined) continue // Skip sparse array positions\n\n\t\t\tlet key = this.#order[i]\n\t\t\tif (!key) {\n\t\t\t\tkey = this.#generateKey(value)\n\t\t\t\tthis.#order[i] = key\n\t\t\t}\n\t\t\trecord[key] = value\n\t\t}\n\t\treturn record\n\t}\n\n\tget #value(): T[] {\n\t\treturn this.#order\n\t\t\t.map(key => this.#composite.signals.get(key)?.get())\n\t\t\t.filter(v => v !== undefined) as T[]\n\t}\n\n\t// Public methods\n\tget [Symbol.toStringTag](): 'List' {\n\t\treturn TYPE_LIST\n\t}\n\n\tget [Symbol.isConcatSpreadable](): true {\n\t\treturn true\n\t}\n\n\t*[Symbol.iterator](): IterableIterator<State<T>> {\n\t\tfor (const key of this.#order) {\n\t\t\tconst signal = this.#composite.signals.get(key)\n\t\t\tif (signal) yield signal as State<T>\n\t\t}\n\t}\n\n\tget length(): number {\n\t\tsubscribeActiveWatcher(this.#watchers, this.#hookCallbacks[HOOK_WATCH])\n\t\treturn this.#order.length\n\t}\n\n\tget(): T[] {\n\t\tsubscribeActiveWatcher(this.#watchers, this.#hookCallbacks[HOOK_WATCH])\n\t\treturn this.#value\n\t}\n\n\tset(newValue: T[]): void {\n\t\tif (UNSET === newValue) {\n\t\t\tthis.#composite.clear()\n\t\t\tnotifyWatchers(this.#watchers)\n\t\t\tthis.#watchers.clear()\n\t\t\treturn\n\t\t}\n\n\t\tconst oldValue = this.#value\n\t\tconst changes = diff(this.#toRecord(oldValue), this.#toRecord(newValue))\n\t\tconst removedKeys = Object.keys(changes.remove)\n\n\t\tconst changed = this.#composite.change(changes)\n\t\tif (changed) {\n\t\t\tfor (const key of removedKeys) {\n\t\t\t\tconst index = this.#order.indexOf(key)\n\t\t\t\tif (index !== -1) this.#order.splice(index, 1)\n\t\t\t}\n\t\t\tthis.#order = this.#order.filter(() => true)\n\t\t\tnotifyWatchers(this.#watchers)\n\t\t}\n\t}\n\n\tupdate(fn: (oldValue: T[]) => T[]): void {\n\t\tthis.set(fn(this.get()))\n\t}\n\n\tat(index: number): State<T> | undefined {\n\t\treturn this.#composite.signals.get(this.#order[index])\n\t}\n\n\tkeys(): IterableIterator<string> {\n\t\treturn this.#order.values()\n\t}\n\n\tbyKey(key: string): State<T> | undefined {\n\t\treturn this.#composite.signals.get(key)\n\t}\n\n\tkeyAt(index: number): string | undefined {\n\t\treturn this.#order[index]\n\t}\n\n\tindexOfKey(key: string): number {\n\t\treturn this.#order.indexOf(key)\n\t}\n\n\tadd(value: T): string {\n\t\tconst key = this.#generateKey(value)\n\t\tif (this.#composite.signals.has(key))\n\t\t\tthrow new DuplicateKeyError('store', key, value)\n\n\t\tif (!this.#order.includes(key)) this.#order.push(key)\n\t\tconst ok = this.#composite.add(key, value)\n\t\tif (ok) notifyWatchers(this.#watchers)\n\t\treturn key\n\t}\n\n\tremove(keyOrIndex: string | number): void {\n\t\tconst key = isNumber(keyOrIndex) ? this.#order[keyOrIndex] : keyOrIndex\n\t\tconst ok = this.#composite.remove(key)\n\t\tif (ok) {\n\t\t\tconst index = isNumber(keyOrIndex)\n\t\t\t\t? keyOrIndex\n\t\t\t\t: this.#order.indexOf(key)\n\t\t\tif (index >= 0) this.#order.splice(index, 1)\n\t\t\tthis.#order = this.#order.filter(() => true)\n\t\t\tnotifyWatchers(this.#watchers)\n\t\t}\n\t}\n\n\tsort(compareFn?: (a: T, b: T) => number): void {\n\t\tconst entries = this.#order\n\t\t\t.map(\n\t\t\t\tkey =>\n\t\t\t\t\t[key, this.#composite.signals.get(key)?.get()] as [\n\t\t\t\t\t\tstring,\n\t\t\t\t\t\tT,\n\t\t\t\t\t],\n\t\t\t)\n\t\t\t.sort(\n\t\t\t\tisFunction(compareFn)\n\t\t\t\t\t? (a, b) => compareFn(a[1], b[1])\n\t\t\t\t\t: (a, b) => String(a[1]).localeCompare(String(b[1])),\n\t\t\t)\n\t\tconst newOrder = entries.map(([key]) => key)\n\n\t\tif (!isEqual(this.#order, newOrder)) {\n\t\t\tthis.#order = newOrder\n\t\t\tnotifyWatchers(this.#watchers)\n\t\t\ttriggerHook(this.#hookCallbacks.sort, this.#order)\n\t\t}\n\t}\n\n\tsplice(start: number, deleteCount?: number, ...items: T[]): T[] {\n\t\tconst length = this.#order.length\n\t\tconst actualStart =\n\t\t\tstart < 0 ? Math.max(0, length + start) : Math.min(start, length)\n\t\tconst actualDeleteCount = Math.max(\n\t\t\t0,\n\t\t\tMath.min(\n\t\t\t\tdeleteCount ?? Math.max(0, length - Math.max(0, actualStart)),\n\t\t\t\tlength - actualStart,\n\t\t\t),\n\t\t)\n\n\t\tconst add = {} as Record<string, T>\n\t\tconst remove = {} as Record<string, T>\n\n\t\t// Collect items to delete and their keys\n\t\tfor (let i = 0; i < actualDeleteCount; i++) {\n\t\t\tconst index = actualStart + i\n\t\t\tconst key = this.#order[index]\n\t\t\tif (key) {\n\t\t\t\tconst signal = this.#composite.signals.get(key)\n\t\t\t\tif (signal) remove[key] = signal.get() as T\n\t\t\t}\n\t\t}\n\n\t\t// Build new order: items before splice point\n\t\tconst newOrder = this.#order.slice(0, actualStart)\n\n\t\t// Add new items\n\t\tfor (const item of items) {\n\t\t\tconst key = this.#generateKey(item)\n\t\t\tnewOrder.push(key)\n\t\t\tadd[key] = item as T\n\t\t}\n\n\t\t// Add items after splice point\n\t\tnewOrder.push(...this.#order.slice(actualStart + actualDeleteCount))\n\n\t\tconst changed = !!(\n\t\t\tObject.keys(add).length || Object.keys(remove).length\n\t\t)\n\n\t\tif (changed) {\n\t\t\tthis.#composite.change({\n\t\t\t\tadd,\n\t\t\t\tchange: {} as Record<string, T>,\n\t\t\t\tremove,\n\t\t\t\tchanged,\n\t\t\t})\n\t\t\tthis.#order = newOrder.filter(() => true) // Update order array\n\t\t\tnotifyWatchers(this.#watchers)\n\t\t}\n\n\t\treturn Object.values(remove)\n\t}\n\n\ton(type: Hook, callback: HookCallback): Cleanup {\n\t\tif (isHandledHook(type, [HOOK_SORT, HOOK_WATCH])) {\n\t\t\tthis.#hookCallbacks[type] ||= new Set<HookCallback>()\n\t\t\tthis.#hookCallbacks[type].add(callback)\n\t\t\treturn () => {\n\t\t\t\tthis.#hookCallbacks[type]?.delete(callback)\n\t\t\t}\n\t\t} else if (isHandledHook(type, [HOOK_ADD, HOOK_CHANGE, HOOK_REMOVE])) {\n\t\t\treturn this.#composite.on(type, callback)\n\t\t}\n\t\tthrow new InvalidHookError(TYPE_LIST, type)\n\t}\n\n\tderiveCollection<R extends {}>(\n\t\tcallback: (sourceValue: T) => R,\n\t): DerivedCollection<R, T>\n\tderiveCollection<R extends {}>(\n\t\tcallback: (sourceValue: T, abort: AbortSignal) => Promise<R>,\n\t): DerivedCollection<R, T>\n\tderiveCollection<R extends {}>(\n\t\tcallback: CollectionCallback<R, T>,\n\t): DerivedCollection<R, T> {\n\t\treturn new DerivedCollection(this, callback)\n\t}\n}\n\n/* === Functions === */\n\n/**\n * Check if the provided value is a List instance\n *\n * @since 0.15.0\n * @param {unknown} value - Value to check\n * @returns {boolean} - True if the value is a List instance, false otherwise\n */\nconst isList = <T extends {}>(value: unknown): value is List<T> =>\n\tisObjectOfType(value, TYPE_LIST)\n\n/* === Exports === */\n\nexport { isList, List, TYPE_LIST, type ArrayToRecord, type KeyConfig }\n",
    "import { diff, type UnknownRecord } from '../diff'\nimport {\n\tDuplicateKeyError,\n\tInvalidHookError,\n\tvalidateSignalValue,\n} from '../errors'\nimport { createMutableSignal, type MutableSignal, type Signal } from '../signal'\nimport {\n\ttype Cleanup,\n\tHOOK_ADD,\n\tHOOK_CHANGE,\n\tHOOK_REMOVE,\n\tHOOK_WATCH,\n\ttype Hook,\n\ttype HookCallback,\n\tisHandledHook,\n\tnotifyWatchers,\n\tsubscribeActiveWatcher,\n\tUNSET,\n\ttype Watcher,\n} from '../system'\nimport { isFunction, isObjectOfType, isRecord, isSymbol } from '../util'\nimport { Composite } from './composite'\nimport type { List } from './list'\nimport type { State } from './state'\n\n/* === Types === */\n\ntype Store<T extends UnknownRecord> = BaseStore<T> & {\n\t[K in keyof T]: T[K] extends readonly (infer U extends {})[]\n\t\t? List<U>\n\t\t: T[K] extends UnknownRecord\n\t\t\t? Store<T[K]>\n\t\t\t: State<T[K] & {}>\n}\n\n/* === Constants === */\n\nconst TYPE_STORE = 'Store' as const\n\n/* === Store Implementation === */\n\nclass BaseStore<T extends UnknownRecord> {\n\t#composite: Composite<T, Signal<T[keyof T] & {}>>\n\t#watchers = new Set<Watcher>()\n\t#watchHookCallbacks: Set<HookCallback> | undefined\n\n\t/**\n\t * Create a new store with the given initial value.\n\t *\n\t * @param {T} initialValue - The initial value of the store\n\t * @throws {NullishSignalValueError} - If the initial value is null or undefined\n\t * @throws {InvalidSignalValueError} - If the initial value is not an object\n\t */\n\tconstructor(initialValue: T) {\n\t\tvalidateSignalValue(TYPE_STORE, initialValue, isRecord)\n\n\t\tthis.#composite = new Composite<T, Signal<T[keyof T] & {}>>(\n\t\t\tinitialValue,\n\t\t\t<K extends keyof T & string>(\n\t\t\t\tkey: K,\n\t\t\t\tvalue: unknown,\n\t\t\t): value is T[K] & {} => {\n\t\t\t\tvalidateSignalValue(`${TYPE_STORE} for key \"${key}\"`, value)\n\t\t\t\treturn true\n\t\t\t},\n\t\t\tvalue => createMutableSignal(value),\n\t\t)\n\t}\n\n\tget #value(): T {\n\t\tconst record = {} as UnknownRecord\n\t\tfor (const [key, signal] of this.#composite.signals.entries())\n\t\t\trecord[key] = signal.get()\n\t\treturn record as T\n\t}\n\n\t// Public methods\n\tget [Symbol.toStringTag](): 'Store' {\n\t\treturn TYPE_STORE\n\t}\n\n\tget [Symbol.isConcatSpreadable](): boolean {\n\t\treturn false\n\t}\n\n\t*[Symbol.iterator](): IterableIterator<\n\t\t[string, MutableSignal<T[keyof T] & {}>]\n\t> {\n\t\tfor (const [key, signal] of this.#composite.signals.entries())\n\t\t\tyield [key, signal as MutableSignal<T[keyof T] & {}>]\n\t}\n\n\tkeys(): IterableIterator<string> {\n\t\treturn this.#composite.signals.keys()\n\t}\n\n\tbyKey<K extends keyof T & string>(\n\t\tkey: K,\n\t): T[K] extends readonly (infer U extends {})[]\n\t\t? List<U>\n\t\t: T[K] extends UnknownRecord\n\t\t\t? Store<T[K]>\n\t\t\t: T[K] extends unknown & {}\n\t\t\t\t? State<T[K] & {}>\n\t\t\t\t: State<T[K] & {}> | undefined {\n\t\treturn this.#composite.signals.get(\n\t\t\tkey,\n\t\t) as T[K] extends readonly (infer U extends {})[]\n\t\t\t? List<U>\n\t\t\t: T[K] extends UnknownRecord\n\t\t\t\t? Store<T[K]>\n\t\t\t\t: T[K] extends unknown & {}\n\t\t\t\t\t? State<T[K] & {}>\n\t\t\t\t\t: State<T[K] & {}> | undefined\n\t}\n\n\tget(): T {\n\t\tsubscribeActiveWatcher(this.#watchers, this.#watchHookCallbacks)\n\t\treturn this.#value\n\t}\n\n\tset(newValue: T): void {\n\t\tif (UNSET === newValue) {\n\t\t\tthis.#composite.clear()\n\t\t\tnotifyWatchers(this.#watchers)\n\t\t\tthis.#watchers.clear()\n\t\t\treturn\n\t\t}\n\n\t\tconst oldValue = this.#value\n\t\tconst changed = this.#composite.change(diff(oldValue, newValue))\n\t\tif (changed) notifyWatchers(this.#watchers)\n\t}\n\n\tupdate(fn: (oldValue: T) => T): void {\n\t\tthis.set(fn(this.get()))\n\t}\n\n\tadd<K extends keyof T & string>(key: K, value: T[K]): K {\n\t\tif (this.#composite.signals.has(key))\n\t\t\tthrow new DuplicateKeyError(TYPE_STORE, key, value)\n\n\t\tconst ok = this.#composite.add(key, value)\n\t\tif (ok) notifyWatchers(this.#watchers)\n\t\treturn key\n\t}\n\n\tremove(key: string): void {\n\t\tconst ok = this.#composite.remove(key)\n\t\tif (ok) notifyWatchers(this.#watchers)\n\t}\n\n\ton(type: Hook, callback: HookCallback): Cleanup {\n\t\tif (type === HOOK_WATCH) {\n\t\t\tthis.#watchHookCallbacks ||= new Set<HookCallback>()\n\t\t\tthis.#watchHookCallbacks.add(callback)\n\t\t\treturn () => {\n\t\t\t\tthis.#watchHookCallbacks?.delete(callback)\n\t\t\t}\n\t\t} else if (isHandledHook(type, [HOOK_ADD, HOOK_CHANGE, HOOK_REMOVE])) {\n\t\t\treturn this.#composite.on(type, callback)\n\t\t}\n\t\tthrow new InvalidHookError(TYPE_STORE, type)\n\t}\n}\n\n/* === Functions === */\n\n/**\n * Create a new store with deeply nested reactive properties\n *\n * @since 0.15.0\n * @param {T} initialValue - Initial object or array value of the store\n * @returns {Store<T>} - New store with reactive properties that preserves the original type T\n */\nconst createStore = <T extends UnknownRecord>(initialValue: T): Store<T> => {\n\tconst instance = new BaseStore(initialValue)\n\n\t// Return proxy for property access\n\treturn new Proxy(instance, {\n\t\tget(target, prop) {\n\t\t\tif (prop in target) {\n\t\t\t\tconst value = Reflect.get(target, prop)\n\t\t\t\treturn isFunction(value) ? value.bind(target) : value\n\t\t\t}\n\t\t\tif (!isSymbol(prop)) return target.byKey(prop)\n\t\t},\n\t\thas(target, prop) {\n\t\t\tif (prop in target) return true\n\t\t\treturn target.byKey(String(prop)) !== undefined\n\t\t},\n\t\townKeys(target) {\n\t\t\treturn Array.from(target.keys())\n\t\t},\n\t\tgetOwnPropertyDescriptor(target, prop) {\n\t\t\tif (prop in target)\n\t\t\t\treturn Reflect.getOwnPropertyDescriptor(target, prop)\n\t\t\tif (isSymbol(prop)) return undefined\n\n\t\t\tconst signal = target.byKey(String(prop))\n\t\t\treturn signal\n\t\t\t\t? {\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\twritable: true,\n\t\t\t\t\t\tvalue: signal,\n\t\t\t\t\t}\n\t\t\t\t: undefined\n\t\t},\n\t}) as Store<T>\n}\n\n/**\n * Check if the provided value is a Store instance\n *\n * @since 0.15.0\n * @param {unknown} value - Value to check\n * @returns {boolean} - True if the value is a Store instance, false otherwise\n */\nconst isStore = <T extends UnknownRecord>(\n\tvalue: unknown,\n): value is BaseStore<T> => isObjectOfType(value, TYPE_STORE)\n\n/* === Exports === */\n\nexport { createStore, isStore, BaseStore, TYPE_STORE, type Store }\n",
    "import {\n\ttype Computed,\n\tisComputed,\n\tisMemoCallback,\n\tisTaskCallback,\n\tMemo,\n\tTask,\n} from './classes/computed'\nimport { isList, List } from './classes/list'\nimport { isState, State } from './classes/state'\nimport { createStore, isStore, type Store } from './classes/store'\nimport type { UnknownRecord } from './diff'\nimport { isRecord, isUniformArray } from './util'\n\n/* === Types === */\n\ntype Signal<T extends {}> = {\n\tget(): T\n}\n\ntype MutableSignal<T extends {}> = T extends readonly (infer U extends {})[]\n\t? List<U>\n\t: T extends UnknownRecord\n\t\t? Store<T>\n\t\t: State<T>\ntype ReadonlySignal<T extends {}> = Computed<T> // | Collection<T>\n\ntype UnknownSignalRecord = Record<string, Signal<unknown & {}>>\n\ntype SignalValues<S extends UnknownSignalRecord> = {\n\t[K in keyof S]: S[K] extends Signal<infer T> ? T : never\n}\n\n/* === Functions === */\n\n/**\n * Check whether a value is a Signal\n *\n * @since 0.9.0\n * @param {unknown} value - value to check\n * @returns {boolean} - true if value is a Signal, false otherwise\n */\nconst isSignal = /*#__PURE__*/ <T extends {}>(\n\tvalue: unknown,\n): value is Signal<T> => isState(value) || isComputed(value) || isStore(value)\n\n/**\n * Check whether a value is a State, Store, or List\n *\n * @since 0.15.2\n * @param {unknown} value - Value to check\n * @returns {boolean} - True if value is a State, Store, or List, false otherwise\n */\nconst isMutableSignal = /*#__PURE__*/ (\n\tvalue: unknown,\n): value is MutableSignal<unknown & {}> =>\n\tisState(value) || isStore(value) || isList(value)\n\n/**\n * Convert a value to a Signal.\n *\n * @since 0.9.6\n */\nfunction createSignal<T extends {}>(value: readonly T[]): List<T>\nfunction createSignal<T extends {}>(value: T[]): List<T>\nfunction createSignal<T extends UnknownRecord>(value: T): Store<T>\nfunction createSignal<T extends {}>(value: () => T): Computed<T>\nfunction createSignal<T extends {}>(value: T): State<T>\nfunction createSignal(value: unknown): unknown {\n\tif (isMemoCallback(value)) return new Memo(value)\n\tif (isTaskCallback(value)) return new Task(value)\n\tif (isUniformArray<unknown & {}>(value)) return new List(value)\n\tif (isRecord(value)) return createStore(value as UnknownRecord)\n\treturn new State(value as unknown & {})\n}\n\n/**\n * Convert a value to a MutableSignal.\n *\n * @since 0.17.0\n */\nfunction createMutableSignal<T extends {}>(value: readonly T[]): List<T>\nfunction createMutableSignal<T extends {}>(value: T[]): List<T>\nfunction createMutableSignal<T extends UnknownRecord>(value: T): Store<T>\nfunction createMutableSignal<T extends {}>(value: T): State<T>\nfunction createMutableSignal(value: unknown): unknown {\n\tif (isUniformArray<unknown & {}>(value)) return new List(value)\n\tif (isRecord(value)) return createStore(value as UnknownRecord)\n\treturn new State(value as unknown & {})\n}\n\n/* === Exports === */\n\nexport {\n\tcreateMutableSignal,\n\tcreateSignal,\n\tisMutableSignal,\n\tisSignal,\n\ttype MutableSignal,\n\ttype ReadonlySignal,\n\ttype Signal,\n\ttype SignalValues,\n\ttype UnknownSignalRecord,\n}\n",
    "import { isMutableSignal, type MutableSignal } from './signal'\nimport { UNSET } from './system'\nimport { isFunction, isSymbol, valueString } from './util'\n\n/* === Types === */\n\ntype Guard<T> = (value: unknown) => value is T\n\n/* === Classes === */\n\nclass CircularDependencyError extends Error {\n\tconstructor(where: string) {\n\t\tsuper(`Circular dependency detected in ${where}`)\n\t\tthis.name = 'CircularDependencyError'\n\t}\n}\n\nclass DuplicateKeyError extends Error {\n\tconstructor(where: string, key: string, value?: unknown) {\n\t\tsuper(\n\t\t\t`Could not add ${where} key \"${key}\"${\n\t\t\t\tvalue ? ` with value ${valueString(value)}` : ''\n\t\t\t} because it already exists`,\n\t\t)\n\t\tthis.name = 'DuplicateKeyError'\n\t}\n}\n\nclass InvalidCallbackError extends TypeError {\n\tconstructor(where: string, value: unknown) {\n\t\tsuper(`Invalid ${where} callback ${valueString(value)}`)\n\t\tthis.name = 'InvalidCallbackError'\n\t}\n}\n\nclass InvalidCollectionSourceError extends TypeError {\n\tconstructor(where: string, value: unknown) {\n\t\tsuper(`Invalid ${where} source ${valueString(value)}`)\n\t\tthis.name = 'InvalidCollectionSourceError'\n\t}\n}\n\nclass InvalidHookError extends TypeError {\n\tconstructor(where: string, type: string) {\n\t\tsuper(`Invalid hook \"${type}\" in  ${where}`)\n\t\tthis.name = 'InvalidHookError'\n\t}\n}\n\nclass InvalidSignalValueError extends TypeError {\n\tconstructor(where: string, value: unknown) {\n\t\tsuper(`Invalid signal value ${valueString(value)} in ${where}`)\n\t\tthis.name = 'InvalidSignalValueError'\n\t}\n}\n\nclass NullishSignalValueError extends TypeError {\n\tconstructor(where: string) {\n\t\tsuper(`Nullish signal values are not allowed in ${where}`)\n\t\tthis.name = 'NullishSignalValueError'\n\t}\n}\n\nclass ReadonlySignalError extends Error {\n\tconstructor(what: string, value: unknown) {\n\t\tsuper(\n\t\t\t`Could not set ${what} to ${valueString(value)} because signal is read-only`,\n\t\t)\n\t\tthis.name = 'ReadonlySignalError'\n\t}\n}\n\n/* === Functions === */\n\nconst createError = /*#__PURE__*/ (reason: unknown): Error =>\n\treason instanceof Error ? reason : Error(String(reason))\n\nconst validateCallback = (\n\twhere: string,\n\tvalue: unknown,\n\tguard: (value: unknown) => boolean = isFunction,\n): void => {\n\tif (!guard(value)) throw new InvalidCallbackError(where, value)\n}\n\nconst validateSignalValue = (\n\twhere: string,\n\tvalue: unknown,\n\tguard: (value: unknown) => boolean = () =>\n\t\t!(isSymbol(value) && value !== UNSET) || isFunction(value),\n): void => {\n\tif (value == null) throw new NullishSignalValueError(where)\n\tif (!guard(value)) throw new InvalidSignalValueError(where, value)\n}\n\nconst guardMutableSignal = <T extends {}>(\n\twhat: string,\n\tvalue: unknown,\n\tsignal: unknown,\n): signal is MutableSignal<T> => {\n\tif (!isMutableSignal(signal)) throw new ReadonlySignalError(what, value)\n\treturn true\n}\n\nexport {\n\ttype Guard,\n\tCircularDependencyError,\n\tDuplicateKeyError,\n\tInvalidCallbackError,\n\tInvalidCollectionSourceError,\n\tInvalidHookError,\n\tInvalidSignalValueError,\n\tNullishSignalValueError,\n\tReadonlySignalError,\n\tcreateError,\n\tvalidateCallback,\n\tvalidateSignalValue,\n\tguardMutableSignal,\n}\n",
    "import {\n\tInvalidCollectionSourceError,\n\tInvalidHookError,\n\tvalidateCallback,\n} from '../errors'\nimport type { Signal } from '../signal'\nimport {\n\ttype Cleanup,\n\tcreateWatcher,\n\tHOOK_ADD,\n\tHOOK_CHANGE,\n\tHOOK_REMOVE,\n\tHOOK_SORT,\n\tHOOK_WATCH,\n\ttype Hook,\n\ttype HookCallback,\n\ttype HookCallbacks,\n\tisHandledHook,\n\tnotifyWatchers,\n\tsubscribeActiveWatcher,\n\ttrackSignalReads,\n\ttriggerHook,\n\tUNSET,\n\ttype Watcher,\n} from '../system'\nimport { isAsyncFunction, isFunction, isObjectOfType } from '../util'\nimport { type Computed, createComputed } from './computed'\nimport { isList, type List } from './list'\n\n/* === Types === */\n\ntype CollectionSource<T extends {}> = List<T> | Collection<T>\n\ntype CollectionCallback<T extends {}, U extends {}> =\n\t| ((sourceValue: U) => T)\n\t| ((sourceValue: U, abort: AbortSignal) => Promise<T>)\n\ntype Collection<T extends {}> = {\n\treadonly [Symbol.toStringTag]: 'Collection'\n\treadonly [Symbol.isConcatSpreadable]: true\n\t[Symbol.iterator](): IterableIterator<Signal<T>>\n\tkeys(): IterableIterator<string>\n\tget: () => T[]\n\tat: (index: number) => Signal<T> | undefined\n\tbyKey: (key: string) => Signal<T> | undefined\n\tkeyAt: (index: number) => string | undefined\n\tindexOfKey: (key: string) => number | undefined\n\ton: <K extends Hook>(type: K, callback: HookCallback) => Cleanup\n\tderiveCollection: <R extends {}>(\n\t\tcallback: CollectionCallback<R, T>,\n\t) => DerivedCollection<R, T>\n\treadonly length: number\n}\n\n/* === Constants === */\n\nconst TYPE_COLLECTION = 'Collection' as const\n\n/* === Class === */\n\nclass DerivedCollection<T extends {}, U extends {}> implements Collection<T> {\n\t#watchers = new Set<Watcher>()\n\t#source: CollectionSource<U>\n\t#callback: CollectionCallback<T, U>\n\t#signals = new Map<string, Computed<T>>()\n\t#ownWatchers = new Map<string, Watcher>()\n\t#hookCallbacks: HookCallbacks = {}\n\t#order: string[] = []\n\n\tconstructor(\n\t\tsource: CollectionSource<U> | (() => CollectionSource<U>),\n\t\tcallback: CollectionCallback<T, U>,\n\t) {\n\t\tvalidateCallback(TYPE_COLLECTION, callback)\n\n\t\tif (isFunction(source)) source = source()\n\t\tif (!isCollectionSource(source))\n\t\t\tthrow new InvalidCollectionSourceError(TYPE_COLLECTION, source)\n\t\tthis.#source = source\n\n\t\tthis.#callback = callback\n\n\t\tfor (let i = 0; i < this.#source.length; i++) {\n\t\t\tconst key = this.#source.keyAt(i)\n\t\t\tif (!key) continue\n\n\t\t\tthis.#add(key)\n\t\t}\n\n\t\tthis.#source.on(HOOK_ADD, additions => {\n\t\t\tif (!additions) return\n\t\t\tfor (const key of additions) {\n\t\t\t\tif (!this.#signals.has(key)) {\n\t\t\t\t\tthis.#add(key)\n\t\t\t\t\t// For async computations, trigger initial computation\n\t\t\t\t\tconst signal = this.#signals.get(key)\n\t\t\t\t\tif (signal && isAsyncCollectionCallback(this.#callback))\n\t\t\t\t\t\tsignal.get()\n\t\t\t\t}\n\t\t\t}\n\t\t\tnotifyWatchers(this.#watchers)\n\t\t\ttriggerHook(this.#hookCallbacks.add, additions)\n\t\t})\n\n\t\tthis.#source.on(HOOK_REMOVE, removals => {\n\t\t\tif (!removals) return\n\t\t\tfor (const key of removals) {\n\t\t\t\tif (!this.#signals.has(key)) continue\n\n\t\t\t\tthis.#signals.delete(key)\n\t\t\t\tconst index = this.#order.indexOf(key)\n\t\t\t\tif (index >= 0) this.#order.splice(index, 1)\n\n\t\t\t\tconst watcher = this.#ownWatchers.get(key)\n\t\t\t\tif (watcher) {\n\t\t\t\t\twatcher.stop()\n\t\t\t\t\tthis.#ownWatchers.delete(key)\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.#order = this.#order.filter(() => true) // Compact array\n\t\t\tnotifyWatchers(this.#watchers)\n\t\t\ttriggerHook(this.#hookCallbacks.remove, removals)\n\t\t})\n\n\t\tthis.#source.on(HOOK_SORT, newOrder => {\n\t\t\tif (newOrder) this.#order = [...newOrder]\n\t\t\tnotifyWatchers(this.#watchers)\n\t\t\ttriggerHook(this.#hookCallbacks.sort, newOrder)\n\t\t})\n\t}\n\n\t#add(key: string): boolean {\n\t\tconst computedCallback = isAsyncCollectionCallback<T>(this.#callback)\n\t\t\t? async (_: T, abort: AbortSignal) => {\n\t\t\t\t\tconst sourceValue = this.#source.byKey(key)?.get() as U\n\t\t\t\t\tif (sourceValue === UNSET) return UNSET\n\t\t\t\t\treturn this.#callback(sourceValue, abort)\n\t\t\t\t}\n\t\t\t: () => {\n\t\t\t\t\tconst sourceValue = this.#source.byKey(key)?.get() as U\n\t\t\t\t\tif (sourceValue === UNSET) return UNSET\n\t\t\t\t\treturn (this.#callback as (sourceValue: U) => T)(\n\t\t\t\t\t\tsourceValue,\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\tconst signal = createComputed(computedCallback)\n\n\t\tthis.#signals.set(key, signal)\n\t\tif (!this.#order.includes(key)) this.#order.push(key)\n\t\tif (this.#hookCallbacks.change?.size) this.#addWatcher(key)\n\t\treturn true\n\t}\n\n\t#addWatcher(key: string): void {\n\t\tconst watcher = createWatcher(() => {\n\t\t\ttrackSignalReads(watcher, () => {\n\t\t\t\tthis.#signals.get(key)?.get() // Subscribe to the signal\n\t\t\t})\n\t\t})\n\t\tthis.#ownWatchers.set(key, watcher)\n\t\twatcher()\n\t}\n\n\tget [Symbol.toStringTag](): 'Collection' {\n\t\treturn TYPE_COLLECTION\n\t}\n\n\tget [Symbol.isConcatSpreadable](): true {\n\t\treturn true\n\t}\n\n\t*[Symbol.iterator](): IterableIterator<Computed<T>> {\n\t\tfor (const key of this.#order) {\n\t\t\tconst signal = this.#signals.get(key)\n\t\t\tif (signal) yield signal as Computed<T>\n\t\t}\n\t}\n\n\tkeys(): IterableIterator<string> {\n\t\treturn this.#order.values()\n\t}\n\n\tget(): T[] {\n\t\tsubscribeActiveWatcher(this.#watchers, this.#hookCallbacks[HOOK_WATCH])\n\t\treturn this.#order\n\t\t\t.map(key => this.#signals.get(key)?.get())\n\t\t\t.filter(v => v != null && v !== UNSET) as T[]\n\t}\n\n\tat(index: number): Computed<T> | undefined {\n\t\treturn this.#signals.get(this.#order[index])\n\t}\n\n\tbyKey(key: string): Computed<T> | undefined {\n\t\treturn this.#signals.get(key)\n\t}\n\n\tkeyAt(index: number): string | undefined {\n\t\treturn this.#order[index]\n\t}\n\n\tindexOfKey(key: string): number {\n\t\treturn this.#order.indexOf(key)\n\t}\n\n\ton(type: Hook, callback: HookCallback): Cleanup {\n\t\tif (\n\t\t\tisHandledHook(type, [\n\t\t\t\tHOOK_ADD,\n\t\t\t\tHOOK_CHANGE,\n\t\t\t\tHOOK_REMOVE,\n\t\t\t\tHOOK_SORT,\n\t\t\t\tHOOK_WATCH,\n\t\t\t])\n\t\t) {\n\t\t\tthis.#hookCallbacks[type] ||= new Set()\n\t\t\tthis.#hookCallbacks[type].add(callback)\n\t\t\tif (type === HOOK_CHANGE && !this.#ownWatchers.size) {\n\t\t\t\tfor (const key of this.#signals.keys()) this.#addWatcher(key)\n\t\t\t}\n\n\t\t\treturn () => {\n\t\t\t\tthis.#hookCallbacks[type]?.delete(callback)\n\t\t\t\tif (type === HOOK_CHANGE && !this.#hookCallbacks.change?.size) {\n\t\t\t\t\tif (this.#ownWatchers.size) {\n\t\t\t\t\t\tfor (const watcher of this.#ownWatchers.values())\n\t\t\t\t\t\t\twatcher.stop()\n\t\t\t\t\t\tthis.#ownWatchers.clear()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthrow new InvalidHookError(TYPE_COLLECTION, type)\n\t}\n\n\tderiveCollection<R extends {}>(\n\t\tcallback: (sourceValue: T) => R,\n\t): DerivedCollection<R, T>\n\tderiveCollection<R extends {}>(\n\t\tcallback: (sourceValue: T, abort: AbortSignal) => Promise<R>,\n\t): DerivedCollection<R, T>\n\tderiveCollection<R extends {}>(\n\t\tcallback: CollectionCallback<R, T>,\n\t): DerivedCollection<R, T> {\n\t\treturn new DerivedCollection(this, callback)\n\t}\n\n\tget length(): number {\n\t\tsubscribeActiveWatcher(this.#watchers, this.#hookCallbacks[HOOK_WATCH])\n\t\treturn this.#order.length\n\t}\n}\n\n/* === Functions === */\n\n/**\n * Check if a value is a collection signal\n *\n * @since 0.17.2\n * @param {unknown} value - Value to check\n * @returns {boolean} - True if value is a collection signal, false otherwise\n */\nconst isCollection = /*#__PURE__*/ <T extends {}>(\n\tvalue: unknown,\n): value is Collection<T> => isObjectOfType(value, TYPE_COLLECTION)\n\n/**\n * Check if a value is a collection source\n *\n * @since 0.17.0\n * @param {unknown} value - Value to check\n * @returns {boolean} - True if value is a collection source, false otherwise\n */\nconst isCollectionSource = /*#__PURE__*/ <T extends {}>(\n\tvalue: unknown,\n): value is CollectionSource<T> => isList(value) || isCollection(value)\n\n/**\n * Check if the provided callback is an async function\n *\n * @since 0.17.0\n * @param {unknown} callback - Value to check\n * @returns {boolean} - True if value is an async collection callback, false otherwise\n */\nconst isAsyncCollectionCallback = <T extends {}>(\n\tcallback: unknown,\n): callback is (sourceValue: unknown, abort: AbortSignal) => Promise<T> =>\n\tisAsyncFunction(callback)\n\nexport {\n\ttype Collection,\n\ttype CollectionSource,\n\ttype CollectionCallback,\n\tDerivedCollection,\n\tisCollection,\n\tTYPE_COLLECTION,\n}\n",
    "import { type Guard, InvalidHookError, validateSignalValue } from '../errors'\nimport {\n\ttype Cleanup,\n\tHOOK_WATCH,\n\ttype HookCallback,\n\tnotifyWatchers,\n\tsubscribeActiveWatcher,\n\ttype Watcher,\n\ttype WatchHook,\n} from '../system'\nimport { isObjectOfType } from '../util'\n\n/* === Constants === */\n\nconst TYPE_REF = 'Ref'\n\n/* === Class === */\n\n/**\n * Create a new ref signal.\n *\n * @since 0.17.1\n */\nclass Ref<T extends {}> {\n\t#watchers = new Set<Watcher>()\n\t#value: T\n\t#watchHookCallbacks: Set<HookCallback> | undefined\n\n\t/**\n\t * Create a new ref signal.\n\t *\n\t * @param {T} value - Reference to external object\n\t * @param {Guard<T>} guard - Optional guard function to validate the value\n\t * @throws {NullishSignalValueError} - If the value is null or undefined\n\t * @throws {InvalidSignalValueError} - If the value is invalid\n\t */\n\tconstructor(value: T, guard?: Guard<T>) {\n\t\tvalidateSignalValue(TYPE_REF, value, guard)\n\n\t\tthis.#value = value\n\t}\n\n\tget [Symbol.toStringTag](): string {\n\t\treturn TYPE_REF\n\t}\n\n\t/**\n\t * Get the value of the ref signal.\n\t *\n\t * @returns {T} - Object reference\n\t */\n\tget(): T {\n\t\tsubscribeActiveWatcher(this.#watchers, this.#watchHookCallbacks)\n\n\t\treturn this.#value\n\t}\n\n\t/**\n\t * Notify watchers of relevant changes in the external reference.\n\t */\n\tnotify(): void {\n\t\tnotifyWatchers(this.#watchers)\n\t}\n\n\t/**\n\t * Register a callback to be called when HOOK_WATCH is triggered.\n\t *\n\t * @param {WatchHook} type - The type of hook to register the callback for; only HOOK_WATCH is supported\n\t * @param {HookCallback} callback - The callback to register\n\t * @returns {Cleanup} - A function to unregister the callback\n\t */\n\ton(type: WatchHook, callback: HookCallback): Cleanup {\n\t\tif (type === HOOK_WATCH) {\n\t\t\tthis.#watchHookCallbacks ||= new Set()\n\t\t\tthis.#watchHookCallbacks.add(callback)\n\t\t\treturn () => {\n\t\t\t\tthis.#watchHookCallbacks?.delete(callback)\n\t\t\t}\n\t\t}\n\t\tthrow new InvalidHookError(TYPE_REF, type)\n\t}\n}\n\n/* === Functions === */\n\n/**\n * Check if the provided value is a Ref instance\n *\n * @since 0.17.1\n * @param {unknown} value - Value to check\n * @returns {boolean} - True if the value is a Ref instance, false otherwise\n */\nconst isRef = /*#__PURE__*/ <T extends {}>(value: unknown): value is Ref<T> =>\n\tisObjectOfType(value, TYPE_REF)\n\nexport { TYPE_REF, Ref, isRef }\n",
    "import { CircularDependencyError, InvalidCallbackError } from './errors'\nimport {\n\ttype Cleanup,\n\tcreateWatcher,\n\tHOOK_CLEANUP,\n\ttype MaybeCleanup,\n\ttrackSignalReads,\n} from './system'\nimport { isAbortError, isAsyncFunction, isFunction } from './util'\n\n/* === Types === */\n\ntype EffectCallback =\n\t| (() => MaybeCleanup)\n\t| ((abort: AbortSignal) => Promise<MaybeCleanup>)\n\n/* === Functions === */\n\n/**\n * Define what happens when a reactive state changes\n *\n * The callback can be synchronous or asynchronous. Async callbacks receive\n * an AbortSignal parameter, which is automatically aborted when the effect\n * re-runs or is cleaned up, preventing stale async operations.\n *\n * @since 0.1.0\n * @param {EffectCallback} callback - Synchronous or asynchronous effect callback\n * @returns {Cleanup} - Cleanup function for the effect\n */\nconst createEffect = (callback: EffectCallback): Cleanup => {\n\tif (!isFunction(callback) || callback.length > 1)\n\t\tthrow new InvalidCallbackError('effect', callback)\n\n\tconst isAsync = isAsyncFunction(callback)\n\tlet running = false\n\tlet controller: AbortController | undefined\n\n\tconst watcher = createWatcher(() =>\n\t\ttrackSignalReads(watcher, () => {\n\t\t\tif (running) throw new CircularDependencyError('effect')\n\t\t\trunning = true\n\n\t\t\t// Abort any previous async operations\n\t\t\tcontroller?.abort()\n\t\t\tcontroller = undefined\n\n\t\t\tlet cleanup: MaybeCleanup | Promise<MaybeCleanup>\n\n\t\t\ttry {\n\t\t\t\tif (isAsync) {\n\t\t\t\t\t// Create AbortController for async callback\n\t\t\t\t\tcontroller = new AbortController()\n\t\t\t\t\tconst currentController = controller\n\t\t\t\t\tcallback(controller.signal)\n\t\t\t\t\t\t.then(cleanup => {\n\t\t\t\t\t\t\t// Only register cleanup if this is still the current controller\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tisFunction(cleanup) &&\n\t\t\t\t\t\t\t\tcontroller === currentController\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\twatcher.on(HOOK_CLEANUP, cleanup)\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.catch(error => {\n\t\t\t\t\t\t\tif (!isAbortError(error))\n\t\t\t\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t\t\t\t'Error in async effect callback:',\n\t\t\t\t\t\t\t\t\terror,\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\tcleanup = callback()\n\t\t\t\t\tif (isFunction(cleanup)) watcher.on(HOOK_CLEANUP, cleanup)\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tif (!isAbortError(error))\n\t\t\t\t\tconsole.error('Error in effect callback:', error)\n\t\t\t}\n\n\t\t\trunning = false\n\t\t}),\n\t)\n\n\twatcher()\n\treturn () => {\n\t\tcontroller?.abort()\n\t\ttry {\n\t\t\twatcher.stop()\n\t\t} catch (error) {\n\t\t\tconsole.error('Error in effect cleanup:', error)\n\t\t}\n\t}\n}\n\n/* === Exports === */\n\nexport { type MaybeCleanup, type EffectCallback, createEffect }\n",
    "import { createError } from './errors'\nimport type { ResolveResult } from './resolve'\nimport type { SignalValues, UnknownSignalRecord } from './signal'\n\n/* === Types === */\n\ntype MatchHandlers<S extends UnknownSignalRecord> = {\n\tok: (values: SignalValues<S>) => void\n\terr?: (errors: readonly Error[]) => void\n\tnil?: () => void\n}\n\n/* === Functions === */\n\n/**\n * Match on resolve result and call appropriate handler for side effects\n *\n * This is a utility function for those who prefer the handler pattern.\n * All handlers are for side effects only and return void. If you need\n * cleanup logic, use a hoisted let variable in your effect.\n *\n * @since 0.15.0\n * @param {ResolveResult<S>} result - Result from resolve()\n * @param {MatchHandlers<S>} handlers - Handlers for different states (side effects only)\n * @returns {void} - Always returns void\n */\nfunction match<S extends UnknownSignalRecord>(\n\tresult: ResolveResult<S>,\n\thandlers: MatchHandlers<S>,\n): void {\n\ttry {\n\t\tif (result.pending) handlers.nil?.()\n\t\telse if (result.errors) handlers.err?.(result.errors)\n\t\telse if (result.ok) handlers.ok(result.values)\n\t} catch (e) {\n\t\tconst error = createError(e)\n\t\tif (handlers.err && (!result.errors || !result.errors.includes(error)))\n\t\t\thandlers.err(result.errors ? [...result.errors, error] : [error])\n\t\telse throw error\n\t}\n}\n\n/* === Exports === */\n\nexport { match, type MatchHandlers }\n",
    "import type { UnknownRecord } from './diff'\nimport { createError } from './errors'\nimport type { SignalValues, UnknownSignalRecord } from './signal'\nimport { UNSET } from './system'\n\n/* === Types === */\n\ntype ResolveResult<S extends UnknownSignalRecord> =\n\t| { ok: true; values: SignalValues<S>; errors?: never; pending?: never }\n\t| { ok: false; errors: readonly Error[]; values?: never; pending?: never }\n\t| { ok: false; pending: true; values?: never; errors?: never }\n\n/* === Functions === */\n\n/**\n * Resolve signal values with perfect type inference\n *\n * Always returns a discriminated union result, regardless of whether\n * handlers are provided or not. This ensures a predictable API.\n *\n * @since 0.15.0\n * @param {S} signals - Signals to resolve\n * @returns {ResolveResult<S>} - Discriminated union result\n */\nfunction resolve<S extends UnknownSignalRecord>(signals: S): ResolveResult<S> {\n\tconst errors: Error[] = []\n\tlet pending = false\n\tconst values: UnknownRecord = {}\n\n\t// Collect values and errors\n\tfor (const [key, signal] of Object.entries(signals)) {\n\t\ttry {\n\t\t\tconst value = signal.get()\n\t\t\tif (value === UNSET) pending = true\n\t\t\telse values[key] = value\n\t\t} catch (e) {\n\t\t\terrors.push(createError(e))\n\t\t}\n\t}\n\n\t// Return discriminated union\n\tif (pending) return { ok: false, pending: true }\n\tif (errors.length > 0) return { ok: false, errors }\n\treturn { ok: true, values: values as SignalValues<S> }\n}\n\n/* === Exports === */\n\nexport { resolve, type ResolveResult }\n",
    "import { isFunction, isString } from '@zeix/cause-effect'\n\n/* === Types === */\n\ntype LogLevel = 'debug' | 'info' | 'warn' | 'error'\n\n/* === Constants === */\n\nconst DEV_MODE = process.env.DEV_MODE\n\nconst LOG_DEBUG: LogLevel = 'debug'\nconst LOG_INFO: LogLevel = 'info'\nconst LOG_WARN: LogLevel = 'warn'\nconst LOG_ERROR: LogLevel = 'error'\n\n// Reserved words that should never be used as property names\n// These are fundamental JavaScript/Object properties that cause serious issues\nconst RESERVED_WORDS = new Set([\n\t'constructor',\n\t'prototype',\n\t// Expand this list based on user feedback for other reserved words like:\n\t// '__proto__', 'toString', 'valueOf', 'hasOwnProperty', etc.\n])\n\n// HTMLElement properties that commonly cause conflicts\n// These are properties that exist on HTMLElement and cause confusion when overridden\n// in our reactive components because we use the same name for both attributes and properties\nconst HTML_ELEMENT_PROPS = new Set([\n\t'id', // DOM selector conflicts\n\t'class', // CSS class management conflicts (note: property is 'className')\n\t'className', // CSS class management conflicts (note: HTML attribute is 'class')\n\t'title', // Conflicts with tooltip behavior\n\t'role', // ARIA/accessibility conflicts\n\t'style', // Conflicts with style object\n\t'dataset', // Conflicts with data-* attribute access\n\t'lang', // Language/i18n conflicts\n\t'dir', // Text direction conflicts\n\t'hidden', // Visibility control conflicts\n\t'children', // DOM manipulation conflicts\n\t'innerHTML', // DOM manipulation conflicts\n\t'outerHTML', // Full element HTML conflicts\n\t'textContent', // Text manipulation conflicts\n\t'innerText', // Text manipulation conflicts\n\t// TO EXPAND: Add properties based on user feedback and common mistakes\n\t// 'tabindex', 'tabIndex', 'slot', 'part', etc.\n])\n\n/* === Internal Functions === */\n\n/**\n * Return selector string for the id of the element\n *\n * @since 0.7.0\n * @param {string | undefined | null} id\n * @returns {string} - id string for the element with '#' prefix\n */\nconst idString = (id: string | undefined | null): string => (id ? `#${id}` : '')\n\n/**\n * Return a selector string for classes of the element\n *\n * @since 0.7.0\n * @param {DOMTokenList | undefined | null} classList - DOMTokenList to convert to a string\n * @returns {string} - class string for the DOMTokenList with '.' prefix if any\n */\nconst classString = (classList: DOMTokenList | undefined | null): string =>\n\tclassList?.length ? `.${Array.from(classList).join('.')}` : ''\n\n/* === Exported Functions === */\n\nconst hasMethod = /*#__PURE__*/ <T extends object, K extends PropertyKey, R>(\n\tobj: T,\n\tmethodName: K,\n): obj is T & Record<K, (...args: any[]) => R> =>\n\tisString(methodName) &&\n\tmethodName in obj &&\n\tisFunction<R>((obj as any)[methodName])\n\n/**\n * Check if a node is an Element\n *\n * @param {Node} node - node to check\n * @returns {boolean} - `true` if node is an element node, otherwise `false`\n */\nconst isElement = /*#__PURE__*/ (node: Node): node is Element =>\n\tnode.nodeType === Node.ELEMENT_NODE\n\n/**\n * Check whether an element is a custom element\n *\n * @param {E} element - Element to check\n * @returns {boolean} - True if the element is a custom element\n */\nconst isCustomElement = /*#__PURE__*/ <E extends Element>(\n\telement: E,\n): boolean => element.localName.includes('-')\n\n/**\n * Check whether a custom element is not yet defined\n *\n * @param {Element} element - Element to check\n * @returns {boolean} - True if the element is a custom element and not yet defined\n */\nconst isNotYetDefinedComponent = /*#__PURE__*/ (element: Element): boolean =>\n\tisCustomElement(element) && element.matches(':not(:defined)')\n\n/**\n * Return a string representation of the Element instance\n *\n * @since 0.7.0\n * @param {Element | undefined | null} el\n * @returns {string}\n */\nconst elementName = /*#__PURE__*/ (el: Element | undefined | null): string =>\n\tel\n\t\t? `<${el.localName}${idString(el.id)}${classString(el.classList)}>`\n\t\t: '<unknown>'\n\n/**\n * Return a detailed type of a JavaScript variable\n *\n * @since 0.11.0\n * @param {unknown} value\n * @returns {string}\n */\nconst typeString = /*#__PURE__*/ (value: unknown): string => {\n\tif (value === null) return 'null'\n\tif (typeof value !== 'object') return typeof value\n\tif (Array.isArray(value)) return 'Array'\n\n\t// Check for Symbol.toStringTag\n\tif (Symbol.toStringTag in Object(value)) {\n\t\treturn (value as any)[Symbol.toStringTag]\n\t}\n\n\t// For other objects, return the constructor name if available\n\treturn value.constructor?.name || 'Object'\n}\n\n/**\n * Log a message to the console with the specified level\n *\n * @since 0.7.0\n * @param {T} value - value to inspect\n * @param {string} msg - message to log\n * @param {LogLevel} level - log level\n * @returns {T} - value passed through\n */\nconst log = <T>(value: T, msg: string, level: LogLevel = LOG_DEBUG): T => {\n\tif (DEV_MODE || ([LOG_ERROR, LOG_WARN] as LogLevel[]).includes(level))\n\t\tconsole[level](msg, value)\n\treturn value\n}\n\n/**\n * Simple fail-fast validation that checks for specific problematic cases\n *\n * This validation prevents common mistakes where developers accidentally\n * use property names that conflict with native HTMLElement functionality.\n *\n * @param {string} prop - Property name to validate\n * @returns {string | null} - Error message or null if valid\n */\nconst validatePropertyName = (prop: string): string | null => {\n\tif (RESERVED_WORDS.has(prop))\n\t\treturn `Property name \"${prop}\" is a reserved word`\n\tif (HTML_ELEMENT_PROPS.has(prop))\n\t\treturn `Property name \"${prop}\" conflicts with inherited HTMLElement property`\n\treturn null\n}\n\nexport {\n\ttype LogLevel,\n\thasMethod,\n\tisElement,\n\tisCustomElement,\n\tisNotYetDefinedComponent,\n\tlog,\n\telementName,\n\ttypeString,\n\tvalidatePropertyName,\n\tDEV_MODE,\n\tLOG_DEBUG,\n\tLOG_INFO,\n\tLOG_WARN,\n\tLOG_ERROR,\n}\n",
    "import { valueString } from '@zeix/cause-effect'\nimport { elementName } from './util'\n\n/* === Error Classes === */\n\n/**\n * Error thrown when a circular dependency is detected in a selection signal\n *\n * @since 0.14.0\n */\nclass CircularMutationError extends Error {\n\t/**\n\t * @param {HTMLElement} host - Host component\n\t * @param {string} selector - Selector used to find the elements\n\t */\n\tconstructor(host: HTMLElement, selector: string) {\n\t\tsuper(\n\t\t\t`Circular dependency detected in selection signal for component ${elementName(host)} with selector \"${selector}\"`,\n\t\t)\n\t\tthis.name = 'CircularMutationError'\n\t}\n}\n\n/**\n * Error thrown when component name violates rules for custom element names\n *\n * @since 0.14.0\n */\nclass InvalidComponentNameError extends TypeError {\n\t/**\n\t * @param {string} component - Component name\n\t */\n\tconstructor(component: string) {\n\t\tsuper(\n\t\t\t`Invalid component name \"${component}\". Custom element names must contain a hyphen, start with a lowercase letter, and contain only lowercase letters, numbers, and hyphens.`,\n\t\t)\n\t\tthis.name = 'InvalidComponentNameError'\n\t}\n}\n\n/**\n * Error thrown when trying to assign a property name that conflicts with reserved words or inherited HTMLElement properties\n *\n * @since 0.14.0\n */\nclass InvalidPropertyNameError extends TypeError {\n\t/**\n\t * @param {string} component - Component name\n\t * @param {string} prop - Property name\n\t * @param {string} reason - Explanation why the property is invalid\n\t */\n\tconstructor(component: string, prop: string, reason: string) {\n\t\tsuper(\n\t\t\t`Invalid property name \"${prop}\" for component <${component}>. ${reason}`,\n\t\t)\n\t\tthis.name = 'InvalidPropertyNameError'\n\t}\n}\n\n/**\n * Error thrown when setup function does not return effects\n *\n * @since 0.14.0\n */\nclass InvalidEffectsError extends TypeError {\n\t/**\n\t * @param {HTMLElement} host - Host component\n\t * @param {Error} cause - Error that caused the invalid effects\n\t */\n\tconstructor(host: HTMLElement, cause?: Error) {\n\t\tsuper(\n\t\t\t`Invalid effects in component ${elementName(host)}. Effects must be a record of effects for UI elements or the component, or a Promise that resolves to effects.`,\n\t\t)\n\t\tthis.name = 'InvalidEffectsError'\n\t\tif (cause) this.cause = cause\n\t}\n}\n\n/**\n * Error thrown if UI key is invalid\n *\n * @since 0.15.1\n * @param {HTMLElement} host - Host component\n * @param {string} key - Invalid key\n * @param {string} where - Where the key is used\n */\nclass InvalidUIKeyError extends TypeError {\n\tconstructor(host: HTMLElement, key: string, where: string) {\n\t\tsuper(\n\t\t\t`Invalid UI key \"${key}\" in ${where} of component ${elementName(host)}`,\n\t\t)\n\t\tthis.name = 'InvalidUIKeyError'\n\t}\n}\n\n/**\n * Error thrown when a required descendant element does not exist in a component's DOM subtree\n *\n * @since 0.14.0\n */\nclass MissingElementError extends Error {\n\t/**\n\t * @param {HTMLElement} host - Host component\n\t * @param {string} selector - Selector used to find the elements\n\t * @param {string} required - Explanation why the element is required\n\t */\n\tconstructor(host: HTMLElement, selector: string, required: string) {\n\t\tsuper(\n\t\t\t`Missing required element <${selector}> in component ${elementName(host)}. ${required}`,\n\t\t)\n\t\tthis.name = 'MissingElementError'\n\t}\n}\n\n/**\n * Error when a component's dependencies are not met within a specified timeout\n *\n * @since 0.14.0\n */\nclass DependencyTimeoutError extends Error {\n\t/**\n\t * @param {HTMLElement} host - Host component\n\t * @param {string[]} missing - List of missing dependencies\n\t */\n\tconstructor(host: HTMLElement, missing: string[]) {\n\t\tsuper(\n\t\t\t`Timeout waiting for: [${missing.join(', ')}] in component ${elementName(host)}.`,\n\t\t)\n\t\tthis.name = 'DependencyTimeoutError'\n\t}\n}\n\n/**\n * Error thrown when reactives passed to a component are invalid\n *\n * @since 0.15.0\n */\nclass InvalidReactivesError extends TypeError {\n\t/**\n\t * @param {HTMLElement} host - Host component\n\t * @param {HTMLElement} target - Target component\n\t * @param {unknown} reactives - Reactives passed to the component\n\t */\n\tconstructor(host: HTMLElement, target: HTMLElement, reactives: unknown) {\n\t\tsuper(\n\t\t\t`Expected reactives passed from ${elementName(host)} to ${elementName(target)} to be a record of signals, reactive property names or functions. Got ${valueString(reactives)}.`,\n\t\t)\n\t\tthis.name = 'InvalidReactivesError'\n\t}\n}\n\n/**\n * Error thrown when target element is not a custom element as expected\n *\n * @since 0.15.0\n */\nclass InvalidCustomElementError extends TypeError {\n\t/**\n\t * @param {HTMLElement} target - Target component\n\t * @param {string} where - Location where the error occurred\n\t */\n\tconstructor(target: HTMLElement, where: string) {\n\t\tsuper(`Target ${elementName(target)} is not a custom element in ${where}.`)\n\t\tthis.name = 'InvalidCustomElementError'\n\t}\n}\n\nexport {\n\tCircularMutationError,\n\tDependencyTimeoutError,\n\tInvalidComponentNameError,\n\tInvalidCustomElementError,\n\tInvalidPropertyNameError,\n\tInvalidEffectsError,\n\tInvalidReactivesError,\n\tInvalidUIKeyError,\n\tMissingElementError,\n}\n",
    "import {\n\ttype Cleanup,\n\ttype Collection,\n\tcreateEffect,\n\tHOOK_ADD,\n\tHOOK_REMOVE,\n\tisCollection,\n\tisFunction,\n\tisRecord,\n\tisSignal,\n\tisString,\n\ttype MaybeCleanup,\n\ttype Signal,\n\tUNSET,\n\tvalueString,\n} from '@zeix/cause-effect'\nimport type { Component, ComponentProps } from './component'\nimport { InvalidEffectsError } from './errors'\nimport type { ElementFromKey, UI } from './ui'\nimport { DEV_MODE, elementName, LOG_ERROR, log } from './util'\n\n/* === Types === */\n\ntype Effect<P extends ComponentProps, E extends Element> = (\n\thost: Component<P>,\n\ttarget: E,\n) => MaybeCleanup\n\ntype ElementEffects<P extends ComponentProps, E extends Element> =\n\t| Effect<P, E>\n\t| Effect<P, E>[]\n\ntype Effects<\n\tP extends ComponentProps,\n\tU extends UI & { host: Component<P> },\n> = {\n\t[K in keyof U & string]?: ElementEffects<P, ElementFromKey<U, K>>\n}\n\ntype Reactive<T, P extends ComponentProps, E extends Element> =\n\t| keyof P\n\t| Signal<T & {}>\n\t| ((target: E) => T | null | undefined)\n\ntype UpdateOperation = 'a' | 'c' | 'd' | 'h' | 'm' | 'p' | 's' | 't'\n\ntype ElementUpdater<E extends Element, T> = {\n\top: UpdateOperation\n\tname?: string\n\tread: (element: E) => T | null\n\tupdate: (element: E, value: T) => void\n\tdelete?: (element: E) => void\n\tresolve?: (element: E) => void\n\treject?: (error: unknown) => void\n}\n\n/* type ElementInserter<E extends Element> = {\n\tposition?: InsertPosition\n\tcreate: (parent: E) => Element | null\n\tresolve?: (parent: E) => void\n\treject?: (error: unknown) => void\n} */\n\n/* === Constants === */\n\n// Special value explicitly marked as any so it can be used as signal value of any type\nconst RESET: any = Symbol('RESET')\n\n/* === Internal Functions === */\n\nconst getUpdateDescription = (\n\top: UpdateOperation,\n\tname: string = '',\n): string => {\n\tconst ops: Record<UpdateOperation, string> = {\n\t\ta: 'attribute ',\n\t\tc: 'class ',\n\t\td: 'dataset ',\n\t\th: 'inner HTML',\n\t\tm: 'method call ',\n\t\tp: 'property ',\n\t\ts: 'style property ',\n\t\tt: 'text content',\n\t}\n\treturn ops[op] + name\n}\n\n/* === Exported Functions === */\n\n/**\n * Run element effects\n *\n * @since 0.15.0\n * @param {U} host - Host component\n * @param {E} target - Target element\n * @param {ElementEffects<P, E>} effects - Effect functions to run\n * @returns {MaybeCleanup} - Cleanup function that runs collected cleanup functions\n * @throws {InvalidEffectsError} - If the effects are invalid\n */\nconst runElementEffects = <P extends ComponentProps, E extends Element>(\n\thost: Component<P>,\n\ttarget: E,\n\teffects: ElementEffects<P, E>,\n): MaybeCleanup => {\n\tconst cleanups: Cleanup[] = []\n\n\tconst run = (fn: Effect<P, E>) => {\n\t\tconst cleanup = fn(host, target)\n\t\tif (cleanup) cleanups.push(cleanup)\n\t}\n\n\tif (Array.isArray(effects)) for (const fn of effects) run(fn)\n\telse run(effects)\n\n\treturn () => {\n\t\tcleanups.forEach(cleanup => cleanup())\n\t\tcleanups.length = 0\n\t}\n}\n\n/**\n * Run collection effects\n *\n * @since 0.15.0\n * @param {Component<P>} host - Host component\n * @param {Collection<E>} collection - Collection of elements\n * @param {ElementEffects<P, E>} effects - Element effects\n * @returns {Cleanup} - Cleanup function that runs collected cleanup functions\n * @throws {InvalidEffectsError} - If the effects are invalid\n */\nconst runCollectionEffects = <P extends ComponentProps, E extends Element>(\n\thost: Component<P>,\n\tcollection: Collection<E>,\n\teffects: ElementEffects<P, E>,\n): Cleanup => {\n\tconst cleanups: Map<E, Cleanup> = new Map()\n\n\tconst attach = (keys?: readonly string[]) => {\n\t\tif (!keys) return\n\t\tfor (const key of keys) {\n\t\t\tconst target = collection.byKey(key)?.get()\n\t\t\tif (!target) continue\n\t\t\tconst cleanup = runElementEffects(host, target, effects)\n\t\t\tif (cleanup) cleanups.set(target, cleanup)\n\t\t}\n\t}\n\tconst detach = (keys?: readonly string[]) => {\n\t\tif (!keys) return\n\t\tfor (const key of keys) {\n\t\t\tconst target = collection.byKey(key)?.get()\n\t\t\tif (!target) continue\n\t\t\tcleanups.get(target)?.()\n\t\t\tcleanups.delete(target)\n\t\t}\n\t}\n\n\tcollection.on(HOOK_ADD, attach)\n\tcollection.on(HOOK_REMOVE, detach)\n\tattach(Array.from(collection.keys()))\n\treturn () => {\n\t\tfor (const cleanup of cleanups.values()) cleanup()\n\t\tcleanups.clear()\n\t}\n}\n\n/**\n * Run component effects\n *\n * @since 0.15.0\n * @param {ComponentUI<P, U>} ui - Component UI\n * @param {Effects<P, U>} effects - Effect functions to run\n * @returns {Cleanup} - Cleanup function that runs collected cleanup functions\n * @throws {InvalidEffectsError} - If the effects are invalid\n */\nconst runEffects = <\n\tP extends ComponentProps,\n\tU extends UI & { host: Component<P> },\n>(\n\tui: U,\n\teffects: Effects<P, U>,\n): Cleanup => {\n\tif (!isRecord(effects)) throw new InvalidEffectsError(ui.host)\n\n\tconst cleanups: Cleanup[] = []\n\tconst keys = Object.keys(effects)\n\tfor (const key of keys) {\n\t\tif (!effects[key]) continue\n\n\t\tconst elementEffects = Array.isArray(effects[key])\n\t\t\t? effects[key]\n\t\t\t: [effects[key]]\n\t\tconst targets = ui[key]\n\t\tif (isCollection<ElementFromKey<U, typeof key>>(targets)) {\n\t\t\tcleanups.push(runCollectionEffects(ui.host, targets, elementEffects))\n\t\t} else if (targets) {\n\t\t\tconst cleanup = runElementEffects(\n\t\t\t\tui.host,\n\t\t\t\ttargets as ElementFromKey<U, typeof key>,\n\t\t\t\telementEffects,\n\t\t\t)\n\t\t\tif (cleanup) cleanups.push(cleanup)\n\t\t}\n\t}\n\treturn () => {\n\t\tfor (const cleanup of cleanups) cleanup()\n\t\tcleanups.length = 0\n\t}\n}\n\n/**\n * Resolve reactive property name, reader function or signal\n *\n * @param {Reactive<T, P, E>} reactive - Reactive property name, reader function or signal\n * @param {Component<P, U>} host - Component host element\n * @param {E} target - Element to resolve reactive value for\n * @param {string} [context] - Context for error logging\n * @returns {T} - Resolved reactive value\n */\nconst resolveReactive = <\n\tT extends {},\n\tP extends ComponentProps,\n\tE extends Element,\n>(\n\treactive: Reactive<T, P, E>,\n\thost: Component<P>,\n\ttarget: E,\n\tcontext?: string,\n): T => {\n\ttry {\n\t\treturn isString(reactive)\n\t\t\t? (host[reactive] as unknown as T)\n\t\t\t: isSignal(reactive)\n\t\t\t\t? reactive.get()\n\t\t\t\t: isFunction(reactive)\n\t\t\t\t\t? (reactive(target) as unknown as T)\n\t\t\t\t\t: RESET\n\t} catch (error) {\n\t\tif (context) {\n\t\t\tlog(\n\t\t\t\terror,\n\t\t\t\t`Failed to resolve value of ${valueString(reactive)}${\n\t\t\t\t\tcontext ? ` for ${context}` : ''\n\t\t\t\t} in ${elementName(target)}${\n\t\t\t\t\t(host as unknown as E) !== target ? ` in ${elementName(host)}` : ''\n\t\t\t\t}`,\n\t\t\t\tLOG_ERROR,\n\t\t\t)\n\t\t}\n\t\treturn RESET\n\t}\n}\n\n/**\n * Core effect function for updating element properties based on reactive values.\n * This function handles the lifecycle of reading, updating, and deleting element properties\n * while providing proper error handling and debugging support.\n *\n * @since 0.9.0\n * @param {Reactive<T, P, E>} reactive - The reactive value that drives the element updates\n * @param {ElementUpdater<E, T>} updater - Configuration object defining how to read, update, and delete the element property\n * @returns {Effect<P, E>} Effect function that manages the element property updates\n */\nconst updateElement =\n\t<T extends {}, P extends ComponentProps, E extends Element>(\n\t\treactive: Reactive<T, P, E>,\n\t\tupdater: ElementUpdater<E, T>,\n\t): Effect<P, E> =>\n\t(host, target): Cleanup => {\n\t\tconst { op, name = '', read, update } = updater\n\t\tconst operationDesc = getUpdateDescription(op, name)\n\n\t\tconst ok = (verb: string) => () => {\n\t\t\tif (DEV_MODE && host.debug) {\n\t\t\t\tlog(\n\t\t\t\t\ttarget,\n\t\t\t\t\t`${verb} ${operationDesc} of ${elementName(target)} in ${elementName(host)}`,\n\t\t\t\t)\n\t\t\t}\n\t\t\tupdater.resolve?.(target)\n\t\t}\n\n\t\tconst err = (verb: string) => (error: unknown) => {\n\t\t\tlog(\n\t\t\t\terror,\n\t\t\t\t`Failed to ${verb} ${operationDesc} of ${elementName(target)} in ${elementName(host)}`,\n\t\t\t\tLOG_ERROR,\n\t\t\t)\n\t\t\tupdater.reject?.(error)\n\t\t}\n\n\t\tconst fallback = read(target)\n\n\t\treturn createEffect(() => {\n\t\t\tconst value = resolveReactive(reactive, host, target, operationDesc)\n\t\t\tconst resolvedValue =\n\t\t\t\tvalue === RESET\n\t\t\t\t\t? fallback\n\t\t\t\t\t: value === UNSET\n\t\t\t\t\t\t? updater.delete\n\t\t\t\t\t\t\t? null\n\t\t\t\t\t\t\t: fallback\n\t\t\t\t\t\t: value\n\n\t\t\tif (updater.delete && resolvedValue === null) {\n\t\t\t\ttry {\n\t\t\t\t\tupdater.delete!(target)\n\t\t\t\t\tok('delete')()\n\t\t\t\t} catch (error) {\n\t\t\t\t\terr('delete')(error)\n\t\t\t\t}\n\t\t\t} else if (resolvedValue != null) {\n\t\t\t\tconst current = read(target)\n\t\t\t\tif (Object.is(resolvedValue, current)) return\n\t\t\t\ttry {\n\t\t\t\t\tupdate(target, resolvedValue)\n\t\t\t\t\tok('update')()\n\t\t\t\t} catch (error) {\n\t\t\t\t\terr('update')(error)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n/**\n * Effect for dynamically inserting or removing elements based on a reactive numeric value.\n * Positive values insert elements, negative values remove them.\n *\n * @since 0.12.1\n * @param {Reactive<number, P, E>} reactive - Reactive value determining number of elements to insert (positive) or remove (negative)\n * @param {ElementInserter<E>} inserter - Configuration object defining how to create and position elements\n * @returns {Effect<P, E>} Effect function that manages element insertion and removal\n * /\nconst insertOrRemoveElement =\n\t<P extends ComponentProps, E extends Element = HTMLElement>(\n\t\treactive: Reactive<number, P, E>,\n\t\tinserter?: ElementInserter<E>,\n\t): Effect<P, E> =>\n\t(host, target) => {\n\t\tconst ok = (verb: string) => () => {\n\t\t\tif (DEV_MODE && host.debug) {\n\t\t\t\tlog(\n\t\t\t\t\ttarget,\n\t\t\t\t\t`${verb} element in ${elementName(target)} in ${elementName(host)}`,\n\t\t\t\t)\n\t\t\t}\n\t\t\tif (isFunction(inserter?.resolve)) {\n\t\t\t\tinserter.resolve(target)\n\t\t\t} else {\n\t\t\t\tconst signal = isSignal<number>(reactive) ? reactive : undefined\n\t\t\t\tif (isState(signal)) signal.set(0)\n\t\t\t}\n\t\t}\n\n\t\tconst err = (verb: string) => (error: unknown) => {\n\t\t\tlog(\n\t\t\t\terror,\n\t\t\t\t`Failed to ${verb} element in ${elementName(target)} in ${elementName(host)}`,\n\t\t\t\tLOG_ERROR,\n\t\t\t)\n\t\t\tinserter?.reject?.(error)\n\t\t}\n\n\t\treturn createEffect(() => {\n\t\t\tconst diff = resolveReactive(\n\t\t\t\treactive,\n\t\t\t\thost,\n\t\t\t\ttarget,\n\t\t\t\t'insertion or deletion',\n\t\t\t)\n\t\t\tconst resolvedDiff = diff === RESET ? 0 : diff\n\n\t\t\tif (resolvedDiff > 0) {\n\t\t\t\t// Positive diff => insert element\n\t\t\t\tif (!inserter) throw new TypeError(`No inserter provided`)\n\t\t\t\ttry {\n\t\t\t\t\tfor (let i = 0; i < resolvedDiff; i++) {\n\t\t\t\t\t\tconst element = inserter.create(target)\n\t\t\t\t\t\tif (!element) continue\n\t\t\t\t\t\ttarget.insertAdjacentElement(\n\t\t\t\t\t\t\tinserter.position ?? 'beforeend',\n\t\t\t\t\t\t\telement,\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\tok('insert')()\n\t\t\t\t} catch (error) {\n\t\t\t\t\terr('insert')(error)\n\t\t\t\t}\n\t\t\t} else if (resolvedDiff < 0) {\n\t\t\t\ttry {\n\t\t\t\t\tif (\n\t\t\t\t\t\tinserter &&\n\t\t\t\t\t\t(inserter.position === 'afterbegin' ||\n\t\t\t\t\t\t\tinserter.position === 'beforeend')\n\t\t\t\t\t) {\n\t\t\t\t\t\tfor (let i = 0; i > resolvedDiff; i--) {\n\t\t\t\t\t\t\tif (inserter.position === 'afterbegin')\n\t\t\t\t\t\t\t\ttarget.firstElementChild?.remove()\n\t\t\t\t\t\t\telse target.lastElementChild?.remove()\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget.remove()\n\t\t\t\t\t}\n\t\t\t\t\tok('remove')()\n\t\t\t\t} catch (error) {\n\t\t\t\t\terr('remove')(error)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\t} */\n\nexport {\n\ttype Effect,\n\ttype Effects,\n\ttype ElementEffects,\n\ttype ElementUpdater,\n\ttype Reactive,\n\trunEffects,\n\trunElementEffects,\n\tresolveReactive,\n\tupdateElement,\n\tRESET,\n}\n",
    "import { isFunction, isString } from '@zeix/cause-effect'\nimport type { UI } from './ui'\n\n/* === Types === */\n\ntype Parser<T extends {}, U extends UI> = (\n\tui: U,\n\tvalue: string | null | undefined,\n\told?: string | null,\n) => T\n\ntype LooseReader<T extends {}, U extends UI> = (\n\tui: U,\n) => T | string | null | undefined\ntype Reader<T extends {}, U extends UI> = (ui: U) => T\n\ntype Fallback<T extends {}, U extends UI> = T | Reader<T, U>\n\ntype ParserOrFallback<T extends {}, U extends UI> =\n\t| Parser<T, U>\n\t| Fallback<T, U>\n\n/* === Exported Functions === */\n\n/**\n * Check if a value is a parser\n *\n * @since 0.14.0\n * @param {unknown} value - Value to check if it is a parser\n * @returns {boolean} True if the value is a parser, false otherwise\n */\nconst isParser = <T extends {}, U extends UI>(\n\tvalue: unknown,\n): value is Parser<T, U> => isFunction<T>(value) && value.length >= 2\n\n/**\n * Check if a value is a reader\n *\n * @since 0.15.0\n * @param {unknown} value - Value to check if it is a reader\n * @returns {boolean} True if the value is a reader, false otherwise\n */\nconst isReader = <T extends {}, U extends UI>(\n\tvalue: unknown,\n): value is Reader<T, U> => isFunction<T>(value)\n\n/**\n * Get a fallback value for an element\n *\n * @since 0.14.0\n * @param {U} ui - Component UI\n * @param {ParserOrFallback<T, U>} fallback - Fallback value or parser function\n * @returns {T} Fallback value or parsed value\n */\nconst getFallback = <T extends {}, U extends UI>(\n\tui: U,\n\tfallback: ParserOrFallback<T, U>,\n): T => (isReader<T, U>(fallback) ? fallback(ui) : (fallback as T))\n\n/**\n * Read a value from a UI element\n *\n * @since 0.15.0\n * @param {LooseReader<T, U>} reader - Reader function returning T | string | null | undefined\n * @param {ParserOrFallback<T, U>} fallback - Fallback value or parser function\n * @returns {Reader<T, U>} Parsed value or fallback value\n */\nconst read =\n\t<T extends {}, U extends UI>(\n\t\treader: LooseReader<T, U>,\n\t\tfallback: ParserOrFallback<T, U>,\n\t): Reader<T, U> =>\n\t(ui: U): T => {\n\t\tconst value = reader(ui)\n\t\treturn isString(value) && isParser<T, U>(fallback)\n\t\t\t? fallback(ui, value)\n\t\t\t: ((value as T) ?? getFallback(ui, fallback))\n\t}\n\nexport {\n\ttype Parser,\n\ttype LooseReader,\n\ttype Reader,\n\ttype Fallback,\n\ttype ParserOrFallback,\n\tisParser,\n\tisReader,\n\tgetFallback,\n\tread,\n}\n",
    "import {\n\tbatchSignalWrites,\n\ttype Cleanup,\n\ttype Collection,\n\ttype CollectionCallback,\n\tDerivedCollection,\n\tHOOK_ADD,\n\tHOOK_CHANGE,\n\tHOOK_REMOVE,\n\tHOOK_SORT,\n\tHOOK_WATCH,\n\ttype Hook,\n\ttype HookCallback,\n\ttype HookCallbacks,\n\tInvalidHookError,\n\tisEqual,\n\tisFunction,\n\tisHandledHook,\n\tisString,\n\ttype KeyConfig,\n\tnotifyWatchers,\n\tRef,\n\tsubscribeActiveWatcher,\n\tTYPE_COLLECTION,\n\ttriggerHook,\n\ttype Watcher,\n} from '@zeix/cause-effect'\nimport type { ElementFromSelector } from '../ui'\nimport { isElement } from '../util'\n\n/* === Internal Functions === */\n\n/**\n * Extract attribute names from a CSS selector\n * Handles various attribute selector formats: .class, #id, [attr], [attr=value], [attr^=value], etc.\n *\n * @param {string} selector - CSS selector to parse\n * @returns {string[]} - Array of attribute names found in the selector\n */\nconst extractAttributes = (selector: string): string[] => {\n\tconst attributes = new Set<string>()\n\tif (selector.includes('.')) attributes.add('class')\n\tif (selector.includes('#')) attributes.add('id')\n\tif (selector.includes('[')) {\n\t\tconst parts = selector.split('[')\n\t\tfor (let i = 1; i < parts.length; i++) {\n\t\t\tconst part = parts[i]\n\t\t\tif (!part.includes(']')) continue\n\t\t\tconst attrName = part\n\t\t\t\t.split('=')[0]\n\t\t\t\t.trim()\n\t\t\t\t.replace(/[^a-zA-Z0-9_-]/g, '')\n\t\t\tif (attrName) attributes.add(attrName)\n\t\t}\n\t}\n\treturn [...attributes]\n}\n\n/* === Class === */\n\nclass ElementCollection<T extends Element> implements Collection<T> {\n\t#watchers = new Set<Watcher>()\n\t#signals = new Map<string, Ref<T>>()\n\t#hookCallbacks: HookCallbacks = {}\n\t#parent: ParentNode\n\t#selector: string\n\t#observer: MutationObserver | undefined\n\t#order: string[] = []\n\t#generateKey: (item: T) => string\n\n\tconstructor(parent: ParentNode, selector: string, keyConfig?: KeyConfig<T>) {\n\t\tthis.#parent = parent\n\t\tthis.#selector = selector\n\n\t\tlet keyCounter = 0\n\t\tthis.#generateKey = isString(keyConfig)\n\t\t\t? () => `${keyConfig}${keyCounter++}`\n\t\t\t: isFunction<string>(keyConfig)\n\t\t\t\t? (element: T) => keyConfig(element)\n\t\t\t\t: () => String(keyCounter++)\n\t}\n\n\t#keyFor(element: T): string | undefined {\n\t\tfor (const [key, signal] of this.#signals) {\n\t\t\tif (signal.get() === element) return key\n\t\t}\n\t\treturn undefined\n\t}\n\n\t#observe() {\n\t\tArray.from(this.#parent.querySelectorAll<T>(this.#selector)).forEach(\n\t\t\telement => {\n\t\t\t\tconst key = this.#generateKey(element)\n\t\t\t\tthis.#signals.set(key, new Ref(element))\n\t\t\t},\n\t\t)\n\n\t\tconst findMatches = (nodes: NodeList) => {\n\t\t\tconst elements = Array.from(nodes).filter(isElement)\n\t\t\tconst found: T[] = []\n\t\t\tfor (const element of elements) {\n\t\t\t\tif (element.matches(this.#selector)) found.push(element as T)\n\t\t\t\tfound.push(...Array.from(element.querySelectorAll<T>(this.#selector)))\n\t\t\t}\n\t\t\treturn found\n\t\t}\n\n\t\tthis.#observer = new MutationObserver(mutations => {\n\t\t\tconst addedElements: T[] = []\n\t\t\tconst removedElements: T[] = []\n\t\t\tconst addedKeys: string[] = []\n\t\t\tconst changedKeys = new Set<string>()\n\t\t\tconst removedKeys: string[] = []\n\t\t\tlet changed = false\n\n\t\t\tfor (const mutation of mutations) {\n\t\t\t\tif (mutation.type === 'childList') {\n\t\t\t\t\tconst target = mutation.target as T\n\t\t\t\t\tif (isElement(target)) {\n\t\t\t\t\t\t// maybe observed match -> change\n\t\t\t\t\t\tconst key = this.#keyFor(target)\n\t\t\t\t\t\tif (key) changedKeys.add(key)\n\t\t\t\t\t}\n\t\t\t\t\tif (mutation.addedNodes.length)\n\t\t\t\t\t\t// Maybe new matches in childList -> add\n\t\t\t\t\t\taddedElements.push(...findMatches(mutation.addedNodes))\n\t\t\t\t\tif (mutation.removedNodes.length)\n\t\t\t\t\t\t// Maybe removed matches in childList -> remove\n\t\t\t\t\t\tremovedElements.push(...findMatches(mutation.removedNodes))\n\t\t\t\t} else if (mutation.type === 'attributes') {\n\t\t\t\t\tconst target = mutation.target as T\n\t\t\t\t\tif (isElement(target)) {\n\t\t\t\t\t\tconst key = this.#keyFor(target)\n\t\t\t\t\t\tconst isMatching = target.matches(this.#selector)\n\t\t\t\t\t\tif (key && !isMatching) {\n\t\t\t\t\t\t\t// No longer matching -> remove\n\t\t\t\t\t\t\tthis.#signals.delete(key)\n\t\t\t\t\t\t\tremovedElements.push(target)\n\t\t\t\t\t\t\tremovedKeys.push(key)\n\t\t\t\t\t\t} else if (key && isMatching) {\n\t\t\t\t\t\t\t// Still matching -> change\n\t\t\t\t\t\t\tchangedKeys.add(key)\n\t\t\t\t\t\t} else if (!key && isMatching) {\n\t\t\t\t\t\t\t// Matching for the first time -> add\n\t\t\t\t\t\t\tconst newKey = this.#generateKey(target)\n\t\t\t\t\t\t\tthis.#signals.set(newKey, new Ref(target))\n\t\t\t\t\t\t\taddedElements.push(target)\n\t\t\t\t\t\t\taddedKeys.push(newKey)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbatchSignalWrites(() => {\n\t\t\t\tif (addedKeys.length || removedKeys.length) {\n\t\t\t\t\tchanged = true\n\t\t\t\t\tif (addedKeys.length)\n\t\t\t\t\t\ttriggerHook(this.#hookCallbacks[HOOK_ADD], addedKeys)\n\t\t\t\t\tif (removedKeys.length)\n\t\t\t\t\t\ttriggerHook(this.#hookCallbacks[HOOK_REMOVE], removedKeys)\n\t\t\t\t}\n\n\t\t\t\tif (this.#hookCallbacks[HOOK_CHANGE]?.size) {\n\t\t\t\t\ttriggerHook(this.#hookCallbacks[HOOK_CHANGE], Array.from(changedKeys))\n\t\t\t\t\tfor (const key of changedKeys) {\n\t\t\t\t\t\tif (key) this.#signals.get(key)?.notify()\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst newOrder = Array.from(\n\t\t\t\t\tthis.#parent.querySelectorAll<T>(this.#selector),\n\t\t\t\t)\n\t\t\t\t\t.map(element => this.#keyFor(element))\n\t\t\t\t\t.filter(key => key !== undefined)\n\n\t\t\t\tif (!isEqual(this.#order, newOrder)) {\n\t\t\t\t\tthis.#order = newOrder\n\t\t\t\t\tchanged = true\n\t\t\t\t\ttriggerHook(this.#hookCallbacks[HOOK_SORT], newOrder)\n\t\t\t\t}\n\n\t\t\t\tif (changed) notifyWatchers(this.#watchers)\n\t\t\t})\n\t\t})\n\n\t\tconst observerConfig: MutationObserverInit = this.#hookCallbacks[\n\t\t\tHOOK_CHANGE\n\t\t]?.size\n\t\t\t? {\n\t\t\t\t\tattributes: true,\n\t\t\t\t\tchildList: true,\n\t\t\t\t\tsubtree: true,\n\t\t\t\t}\n\t\t\t: {\n\t\t\t\t\tchildList: true,\n\t\t\t\t\tsubtree: true,\n\t\t\t\t}\n\t\tif (!this.#hookCallbacks[HOOK_CHANGE]?.size) {\n\t\t\tconst observedAttributes = extractAttributes(this.#selector)\n\t\t\tif (observedAttributes.length) {\n\t\t\t\tobserverConfig.attributes = true\n\t\t\t\tobserverConfig.attributeFilter = observedAttributes\n\t\t\t}\n\t\t}\n\t\tthis.#observer.observe(this.#parent, observerConfig)\n\t}\n\n\tget [Symbol.toStringTag](): 'Collection' {\n\t\treturn TYPE_COLLECTION\n\t}\n\n\tget [Symbol.isConcatSpreadable](): true {\n\t\treturn true\n\t}\n\n\t*[Symbol.iterator](): IterableIterator<Ref<T>> {\n\t\tfor (const key of this.#order) {\n\t\t\tconst element = this.#signals.get(key)\n\t\t\tif (element) yield element\n\t\t}\n\t}\n\n\tkeys(): IterableIterator<string> {\n\t\treturn this.#order.values()\n\t}\n\n\tget(): T[] {\n\t\tsubscribeActiveWatcher(this.#watchers, this.#hookCallbacks[HOOK_WATCH])\n\t\tif (!this.#observer) this.#observe()\n\t\treturn this.#order\n\t\t\t.map(key => this.#signals.get(key)?.get())\n\t\t\t.filter(element => element !== undefined)\n\t}\n\n\tat(index: number): Ref<T> | undefined {\n\t\treturn this.#signals.get(this.#order[index])\n\t}\n\n\tbyKey(key: string): Ref<T> | undefined {\n\t\treturn this.#signals.get(key)\n\t}\n\n\tkeyAt(index: number): string | undefined {\n\t\treturn this.#order[index]\n\t}\n\n\tindexOfKey(key: string): number {\n\t\treturn this.#order.indexOf(key)\n\t}\n\n\ton(type: Hook, callback: HookCallback): Cleanup {\n\t\tif (\n\t\t\tisHandledHook(type, [\n\t\t\t\tHOOK_ADD,\n\t\t\t\tHOOK_CHANGE,\n\t\t\t\tHOOK_REMOVE,\n\t\t\t\tHOOK_SORT,\n\t\t\t\tHOOK_WATCH,\n\t\t\t])\n\t\t) {\n\t\t\tthis.#hookCallbacks[type] ||= new Set()\n\t\t\tthis.#hookCallbacks[type].add(callback)\n\t\t\tif (!this.#observer) this.#observe()\n\t\t\treturn () => {\n\t\t\t\tthis.#hookCallbacks[type]?.delete(callback)\n\t\t\t}\n\t\t}\n\t\tthrow new InvalidHookError(TYPE_COLLECTION, type)\n\t}\n\n\tderiveCollection<R extends {}>(\n\t\tcallback: (sourceValue: T) => R,\n\t): DerivedCollection<R, T>\n\tderiveCollection<R extends {}>(\n\t\tcallback: (sourceValue: T, abort: AbortSignal) => Promise<R>,\n\t): DerivedCollection<R, T>\n\tderiveCollection<R extends {}>(\n\t\tcallback: CollectionCallback<R, T>,\n\t): DerivedCollection<R, T> {\n\t\treturn new DerivedCollection(this, callback)\n\t}\n\n\tget length(): number {\n\t\tsubscribeActiveWatcher(this.#watchers, this.#hookCallbacks[HOOK_WATCH])\n\t\tif (!this.#observer) this.#observe()\n\t\treturn this.#signals.size\n\t}\n}\n\n/* === Exported Functions === */\n\n/**\n * Create a collection of elements from a parent node and a CSS selector.\n *\n * @since 0.15.0\n * @param parent - The parent node to search within\n * @param selector - The CSS selector to match elements\n * @returns A collection signal of elements\n */\nfunction createElementCollection<S extends string>(\n\tparent: ParentNode,\n\tselector: S,\n\tkeyConfig?: KeyConfig<ElementFromSelector<S>>,\n): ElementCollection<ElementFromSelector<S>>\nfunction createElementCollection<E extends Element>(\n\tparent: ParentNode,\n\tselector: string,\n\tkeyConfig?: KeyConfig<E>,\n): ElementCollection<E>\nfunction createElementCollection<S extends string>(\n\tparent: ParentNode,\n\tselector: S,\n\tkeyConfig?: KeyConfig<ElementFromSelector<S>>,\n): ElementCollection<ElementFromSelector<S>> {\n\treturn new ElementCollection(parent, selector, keyConfig)\n}\n\nexport { createElementCollection, ElementCollection }\n",
    "import type { Collection } from '@zeix/cause-effect'\nimport { DependencyTimeoutError, MissingElementError } from './errors'\nimport { createElementCollection } from './signals/collection'\nimport { isNotYetDefinedComponent } from './util'\n\n/* === Types === */\n\n// Split a comma-separated selector into individual selectors\ntype SplitByComma<S extends string> = S extends `${infer First},${infer Rest}`\n\t? [TrimWhitespace<First>, ...SplitByComma<Rest>]\n\t: [TrimWhitespace<S>]\n\n// Trim leading/trailing whitespace from a string\ntype TrimWhitespace<S extends string> = S extends ` ${infer Rest}`\n\t? TrimWhitespace<Rest>\n\t: S extends `${infer Rest} `\n\t\t? TrimWhitespace<Rest>\n\t\t: S\n\n// Extract the rightmost selector part from combinator selectors (space, >, +, ~)\ntype ExtractRightmostSelector<S extends string> =\n\tS extends `${string} ${infer Rest}`\n\t\t? ExtractRightmostSelector<Rest>\n\t\t: S extends `${string}>${infer Rest}`\n\t\t\t? ExtractRightmostSelector<Rest>\n\t\t\t: S extends `${string}+${infer Rest}`\n\t\t\t\t? ExtractRightmostSelector<Rest>\n\t\t\t\t: S extends `${string}~${infer Rest}`\n\t\t\t\t\t? ExtractRightmostSelector<Rest>\n\t\t\t\t\t: S\n\n// Extract tag name from a simple selector (without combinators)\ntype ExtractTagFromSimpleSelector<S extends string> =\n\tS extends `${infer T}.${string}`\n\t\t? T\n\t\t: S extends `${infer T}#${string}`\n\t\t\t? T\n\t\t\t: S extends `${infer T}:${string}`\n\t\t\t\t? T\n\t\t\t\t: S extends `${infer T}[${string}`\n\t\t\t\t\t? T\n\t\t\t\t\t: S\n\n// Main extraction logic for a single selector\ntype ExtractTag<S extends string> = ExtractTagFromSimpleSelector<\n\tExtractRightmostSelector<S>\n>\n\n// Normalize to lowercase and ensure it's a known HTML tag\ntype KnownTag<S extends string> =\n\tLowercase<ExtractTag<S>> extends\n\t\t| keyof HTMLElementTagNameMap\n\t\t| keyof SVGElementTagNameMap\n\t\t| keyof MathMLElementTagNameMap\n\t\t? Lowercase<ExtractTag<S>>\n\t\t: never\n\n// Get element type from a single selector\ntype ElementFromSingleSelector<S extends string> =\n\tKnownTag<S> extends never\n\t\t? HTMLElement\n\t\t: KnownTag<S> extends keyof HTMLElementTagNameMap\n\t\t\t? HTMLElementTagNameMap[KnownTag<S>]\n\t\t\t: KnownTag<S> extends keyof SVGElementTagNameMap\n\t\t\t\t? SVGElementTagNameMap[KnownTag<S>]\n\t\t\t\t: KnownTag<S> extends keyof MathMLElementTagNameMap\n\t\t\t\t\t? MathMLElementTagNameMap[KnownTag<S>]\n\t\t\t\t\t: HTMLElement\n\n// Map a tuple of selectors to a union of their element types\ntype ElementsFromSelectorArray<Selectors extends readonly string[]> = {\n\t[K in keyof Selectors]: Selectors[K] extends string\n\t\t? ElementFromSingleSelector<Selectors[K]>\n\t\t: never\n}[number]\n\n// Main type: handle both single selectors and comma-separated selectors\ntype ElementFromSelector<S extends string> = S extends `${string},${string}`\n\t? ElementsFromSelectorArray<SplitByComma<S>>\n\t: ElementFromSingleSelector<S>\n\ntype FirstElement = {\n\t<S extends string>(selector: S, required: string): ElementFromSelector<S>\n\t<S extends string>(selector: S): ElementFromSelector<S> | undefined\n\t<E extends Element>(selector: string, required: string): E\n\t<E extends Element>(selector: string): E | undefined\n}\n\ntype AllElements = {\n\t<S extends string>(\n\t\tselector: S,\n\t\trequired?: string,\n\t): Collection<ElementFromSelector<S>>\n\t<E extends Element>(selector: string, required?: string): Collection<E>\n}\ntype UI = Record<string, Element | Collection<Element>>\n\ntype ElementFromKey<U extends UI, K extends keyof U & string> = NonNullable<\n\tU[K] extends Collection<infer E extends Element>\n\t\t? E\n\t\t: U[K] extends Element\n\t\t\t? U[K]\n\t\t\t: never\n>\n\ntype ElementQueries = {\n\tfirst: FirstElement\n\tall: AllElements\n}\n\n/* === Constants === */\n\nconst DEPENDENCY_TIMEOUT = 50\n\n/* === Exported Functions === */\n\n/**\n * Create partially applied helper functions to get descendants and run effects on them\n *\n * @since 0.14.0\n * @param {HTMLElement} host - Host component\n * @returns {ElementSelectors<P>} - Helper functions for selecting descendants\n */\nconst getHelpers = (\n\thost: HTMLElement,\n): [ElementQueries, (run: () => void) => void] => {\n\tconst root = host.shadowRoot ?? host\n\tconst dependencies: Set<string> = new Set()\n\n\t/**\n\t * Get the first descendant element matching a selector\n\t * If the element is a custom elements it will be added to dependencies\n\t *\n\t * @since 0.15.0\n\t * @param {S} selector - Selector for element to check for\n\t * @param {string} [required] - Optional reason for the assertion; if provided, throws on missing element\n\t * @returns {ElementFromSelector<S> | undefined} First matching descendant element, or void if not found and not required\n\t * @throws {MissingElementError} - Thrown when the element is required but not found\n\t */\n\tfunction first<S extends string>(\n\t\tselector: S,\n\t\trequired: string,\n\t): ElementFromSelector<S>\n\tfunction first<S extends string>(\n\t\tselector: S,\n\t): ElementFromSelector<S> | undefined\n\tfunction first<E extends Element>(selector: string, required: string): E\n\tfunction first<E extends Element>(selector: string): E | undefined\n\tfunction first<S extends string>(\n\t\tselector: S,\n\t\trequired?: string,\n\t): ElementFromSelector<S> | undefined {\n\t\tconst target = root.querySelector<ElementFromSelector<S>>(selector)\n\t\tif (required != null && !target)\n\t\t\tthrow new MissingElementError(host, selector, required)\n\n\t\t// Only add to dependencies if element is a custom element that's not yet defined\n\t\tif (target && isNotYetDefinedComponent(target))\n\t\t\tdependencies.add(target.localName)\n\t\treturn target ?? undefined\n\t}\n\n\t/**\n\t * Get all descendant elements matching a selector\n\t * If any element is a custom element it will be added to dependencies\n\t *\n\t * @since 0.15.0\n\t * @param {S} selector - Selector for elements to check for\n\t * @param {string} [required] - Optional reason for the assertion; if provided, throws on missing elements\n\t * @returns {ElementFromSelector<S>[]} All matching descendant elements\n\t * @throws {MissingElementError} - Thrown when elements are required but not found\n\t */\n\tfunction all<S extends string>(\n\t\tselector: S,\n\t\trequired?: string,\n\t): Collection<ElementFromSelector<S>>\n\tfunction all<E extends Element>(\n\t\tselector: string,\n\t\trequired?: string,\n\t): Collection<E>\n\tfunction all<S extends string>(\n\t\tselector: S,\n\t\trequired?: string,\n\t): Collection<ElementFromSelector<S>> {\n\t\tconst collection = createElementCollection(root, selector)\n\t\tconst targets = collection.get()\n\t\tif (required != null && !targets.length)\n\t\t\tthrow new MissingElementError(host, selector, required)\n\t\tif (targets.length)\n\t\t\ttargets.forEach(target => {\n\t\t\t\t// Only add to dependencies if element is a custom element that's not yet defined\n\t\t\t\tif (isNotYetDefinedComponent(target)) dependencies.add(target.localName)\n\t\t\t})\n\t\treturn collection\n\t}\n\n\t/**\n\t * Resolve dependencies and thereafter run the provided function\n\t *\n\t * @param {() => void} callback - Function to run after resolving dependencies\n\t */\n\tconst resolveDependencies = (callback: () => void) => {\n\t\tif (dependencies.size) {\n\t\t\tconst deps = Array.from(dependencies)\n\t\t\tPromise.race([\n\t\t\t\tPromise.all(deps.map(dep => customElements.whenDefined(dep))),\n\t\t\t\tnew Promise((_, reject) => {\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\treject(\n\t\t\t\t\t\t\tnew DependencyTimeoutError(\n\t\t\t\t\t\t\t\thost,\n\t\t\t\t\t\t\t\tdeps.filter(dep => !customElements.get(dep)),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t)\n\t\t\t\t\t}, DEPENDENCY_TIMEOUT)\n\t\t\t\t}),\n\t\t\t])\n\t\t\t\t.then(callback)\n\t\t\t\t.catch(() => {\n\t\t\t\t\t// Error during setup of <${name}>. Trying to run effects anyway.\n\t\t\t\t\tcallback()\n\t\t\t\t})\n\t\t} else {\n\t\t\tcallback()\n\t\t}\n\t}\n\n\treturn [{ first, all }, resolveDependencies]\n}\n\nexport {\n\ttype ElementFromKey,\n\ttype ElementFromSelector,\n\ttype ElementQueries,\n\tgetHelpers,\n\ttype UI,\n}\n",
    "import {\n\tisComputed,\n\tisFunction,\n\tisMemoCallback,\n\tisMutableSignal,\n\tisSignal,\n\tisState,\n\tisStore,\n\tisTaskCallback,\n\ttype MaybeCleanup,\n\tMemo,\n\ttype MemoCallback,\n\ttype Signal,\n\tState,\n\tTask,\n\ttype TaskCallback,\n\tUNSET,\n} from '@zeix/cause-effect'\n\nimport { type Effects, runEffects } from './effects'\nimport { InvalidComponentNameError, InvalidPropertyNameError } from './errors'\nimport { isParser, type Parser, type Reader } from './parsers'\nimport { type ElementQueries, getHelpers, type UI } from './ui'\nimport { validatePropertyName } from './util'\n\n/* === Types === */\n\ntype ReservedWords =\n\t| 'constructor'\n\t| 'prototype'\n\t| '__proto__'\n\t| 'toString'\n\t| 'valueOf'\n\t| 'hasOwnProperty'\n\t| 'isPrototypeOf'\n\t| 'propertyIsEnumerable'\n\t| 'toLocaleString'\n\ntype ComponentProp = Exclude<string, keyof HTMLElement | ReservedWords>\ntype ComponentProps = Record<ComponentProp, NonNullable<unknown>>\n\ntype Component<P extends ComponentProps> = HTMLElement & P\ntype ComponentUI<P extends ComponentProps, U extends UI> = U & {\n\thost: Component<P>\n}\n\ntype ComponentSetup<P extends ComponentProps, U extends UI> = (\n\tui: ComponentUI<P, U>,\n) => Effects<P, ComponentUI<P, U>>\n\ntype MethodProducer<P extends ComponentProps, U extends UI> = (\n\tui: U & { host: Component<P> },\n) => void\n\ntype Initializers<P extends ComponentProps, U extends UI> = {\n\t[K in keyof P]?:\n\t\t| P[K]\n\t\t| Signal<P[K]>\n\t\t| Parser<P[K], ComponentUI<P, U>>\n\t\t| Reader<MaybeSignal<P[K]>, ComponentUI<P, U>>\n\t\t| MethodProducer<P, ComponentUI<P, U>>\n}\n\ntype MaybeSignal<T extends {}> =\n\t| T\n\t| Signal<T>\n\t| MemoCallback<T>\n\t| TaskCallback<T>\n\n/* === Exported Functions === */\n\n/**\n * Define a component with dependency resolution and setup function (connectedCallback)\n *\n * @since 0.15.0\n * @param {string} name - Custom element name\n * @param {object} props - Component properties\n * @param {function} select - Function to select UI elements\n * @param {function} setup - Setup function\n * @throws {InvalidComponentNameError} If component name is invalid\n * @throws {InvalidPropertyNameError} If property name is invalid\n */\nfunction defineComponent<P extends ComponentProps, U extends UI = {}>(\n\tname: string,\n\tprops: Initializers<P, U> = {} as Initializers<P, U>,\n\tselect: (elementQueries: ElementQueries) => U = () => ({}) as U,\n\tsetup: (ui: ComponentUI<P, U>) => Effects<P, ComponentUI<P, U>> = () => ({}),\n): Component<P> {\n\tif (!name.includes('-') || !name.match(/^[a-z][a-z0-9-]*$/))\n\t\tthrow new InvalidComponentNameError(name)\n\tfor (const prop of Object.keys(props)) {\n\t\tconst error = validatePropertyName(prop)\n\t\tif (error) throw new InvalidPropertyNameError(name, prop, error)\n\t}\n\n\tclass Truc extends HTMLElement {\n\t\tdebug?: boolean\n\t\t#ui: ComponentUI<P, U> | undefined\n\t\t#signals = {} as { [K in keyof P]: Signal<P[K]> }\n\t\t#cleanup: MaybeCleanup\n\n\t\tstatic observedAttributes =\n\t\t\tObject.entries(props)\n\t\t\t\t?.filter(([, initializer]) => isParser(initializer))\n\t\t\t\t.map(([prop]) => prop) ?? []\n\n\t\t/**\n\t\t * Native callback when the custom element is first connected to the document\n\t\t */\n\t\tconnectedCallback() {\n\t\t\t// Initialize UI\n\t\t\tconst [elementQueries, resolveDependencies] = getHelpers(this)\n\t\t\tconst ui = {\n\t\t\t\t...select(elementQueries),\n\t\t\t\thost: this as unknown as Component<P>,\n\t\t\t}\n\t\t\tthis.#ui = ui\n\t\t\tObject.freeze(this.#ui)\n\n\t\t\t// Initialize signals\n\t\t\tconst isReaderOrMethodProducer = <K extends keyof P & string>(\n\t\t\t\tvalue: unknown,\n\t\t\t): value is\n\t\t\t\t| Reader<P[K], ComponentUI<P, U>>\n\t\t\t\t| MethodProducer<P, ComponentUI<P, U>> => {\n\t\t\t\treturn isFunction(value)\n\t\t\t}\n\t\t\tconst createSignal = <K extends keyof P & string>(\n\t\t\t\tkey: K,\n\t\t\t\tinitializer: Initializers<P, U>[K],\n\t\t\t) => {\n\t\t\t\tconst result = isParser<P[K], ComponentUI<P, U>>(initializer)\n\t\t\t\t\t? initializer(ui, this.getAttribute(key))\n\t\t\t\t\t: isReaderOrMethodProducer<K>(initializer)\n\t\t\t\t\t\t? initializer(ui)\n\t\t\t\t\t\t: (initializer as MaybeSignal<P[K]>)\n\t\t\t\tif (result != null) this.#setAccessor(key, result)\n\t\t\t}\n\t\t\tfor (const [prop, initializer] of Object.entries(props)) {\n\t\t\t\tif (initializer == null || prop in this) continue\n\t\t\t\tcreateSignal(prop, initializer)\n\t\t\t}\n\n\t\t\t// Resolve dependencies and run setup function\n\t\t\tresolveDependencies(() => {\n\t\t\t\tthis.#cleanup = runEffects(ui, setup(ui))\n\t\t\t})\n\t\t}\n\n\t\t/**\n\t\t * Native callback when the custom element is disconnected from the document\n\t\t */\n\t\tdisconnectedCallback() {\n\t\t\tif (isFunction(this.#cleanup)) this.#cleanup()\n\t\t}\n\n\t\t/**\n\t\t * Native callback when an observed attribute of the custom element changes\n\t\t *\n\t\t * @param {K} name - Name of the modified attribute\n\t\t * @param {string | null} oldValue - Old value of the modified attribute\n\t\t * @param {string | null} newValue - New value of the modified attribute\n\t\t */\n\t\tattributeChangedCallback<K extends keyof P>(\n\t\t\tname: K,\n\t\t\toldValue: string | null,\n\t\t\tnewValue: string | null,\n\t\t) {\n\t\t\t// Not connected yet, unchanged value or controlled by computed\n\t\t\tif (!this.#ui || newValue === oldValue || isComputed(this.#signals[name]))\n\t\t\t\treturn\n\n\t\t\t// Check whether we have a parser for the attribute\n\t\t\tconst parser = props[name]\n\t\t\tif (!isParser<P[K], ComponentUI<P, U>>(parser)) return\n\n\t\t\tconst parsed = parser(this.#ui, newValue, oldValue)\n\t\t\tif (name in this) (this as unknown as P)[name] = parsed\n\t\t\telse this.#setAccessor(name, parsed)\n\t\t}\n\n\t\t/**\n\t\t * Set the signal for a given key\n\t\t *\n\t\t * @since 0.15.0\n\t\t * @param {K} key - Key to set accessor for\n\t\t * @param {MaybeSignal<P[K]>} value - Initial value, signal or computed callback to create signal\n\t\t */\n\t\t#setAccessor<K extends keyof P>(key: K, value: MaybeSignal<P[K]>): void {\n\t\t\tconst signal = isSignal(value)\n\t\t\t\t? value\n\t\t\t\t: isMemoCallback(value)\n\t\t\t\t\t? new Memo(value)\n\t\t\t\t\t: isTaskCallback(value)\n\t\t\t\t\t\t? new Task(value)\n\t\t\t\t\t\t: new State(value)\n\t\t\tconst prev = this.#signals[key]\n\t\t\tconst mutable = isMutableSignal(signal)\n\t\t\tthis.#signals[key] = signal as Signal<P[K]>\n\t\t\tObject.defineProperty(this, key, {\n\t\t\t\tget: signal.get,\n\t\t\t\tset: mutable ? signal.set : undefined,\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: mutable,\n\t\t\t})\n\t\t\tif ((prev && isState(prev)) || isStore(prev)) prev.set(UNSET)\n\t\t}\n\t}\n\n\tcustomElements.define(name, Truc)\n\treturn customElements.get(name) as unknown as Component<P>\n}\n\nexport {\n\ttype Component,\n\ttype ComponentProp,\n\ttype ComponentProps,\n\ttype ComponentUI,\n\ttype ComponentSetup,\n\ttype MaybeSignal,\n\ttype ReservedWords,\n\ttype Initializers,\n\tdefineComponent,\n}\n",
    "import {\n\ttype Cleanup,\n\ttype Computed,\n\tisFunction,\n\tisString,\n\tMemo,\n} from '@zeix/cause-effect'\n\nimport type { Component, ComponentProps } from './component'\nimport { type Fallback, getFallback, type Reader } from './parsers'\nimport type { UI } from './ui'\n\n/** @see https://github.com/webcomponents-cg/community-protocols/blob/main/proposals/context.md */\n\n/* === Types === */\n\n/**\n * A context key.\n *\n * A context key can be any type of object, including strings and symbols. The\n *  Context type brands the key type with the `__context__` property that\n * carries the type of the value the context references.\n */\ntype Context<K, V> = K & { __context__: V }\n\n/**\n * An unknown context type\n */\ntype UnknownContext = Context<unknown, unknown>\n\n/**\n * A helper type which can extract a Context value type from a Context type\n */\ntype ContextType<T extends UnknownContext> =\n\tT extends Context<infer _, infer V> ? V : never\n\n/**\n * A callback which is provided by a context requester and is called with the value satisfying the request.\n * This callback can be called multiple times by context providers as the requested value is changed.\n */\ntype ContextCallback<V> = (value: V, unsubscribe?: () => void) => void\n\ndeclare global {\n\tinterface HTMLElementEventMap {\n\t\t/**\n\t\t * A 'context-request' event can be emitted by any element which desires\n\t\t * a context value to be injected by an external provider.\n\t\t */\n\t\t'context-request': ContextRequestEvent<UnknownContext>\n\t}\n}\n\n/* === Constants === */\n\nconst CONTEXT_REQUEST = 'context-request'\n\n/* === Exported class === */\n\n/**\n * Class for context-request events\n *\n * An event fired by a context requester to signal it desires a named context.\n *\n * A provider should inspect the `context` property of the event to determine if it has a value that can\n * satisfy the request, calling the `callback` with the requested value if so.\n *\n * If the requested context event contains a truthy `subscribe` value, then a provider can call the callback\n * multiple times if the value is changed, if this is the case the provider should pass an `unsubscribe`\n * function to the callback which requesters can invoke to indicate they no longer wish to receive these updates.\n *\n * @class ContextRequestEvent\n * @extends {Event}\n *\n * @property {T} context - context key\n * @property {ContextCallback<ContextType<T>>} callback - callback function for value getter and unsubscribe function\n * @property {boolean} [subscribe=false] - whether to subscribe to context changes\n */\nclass ContextRequestEvent<T extends UnknownContext> extends Event {\n\treadonly context: T\n\treadonly callback: ContextCallback<ContextType<T>>\n\treadonly subscribe: boolean\n\n\tconstructor(\n\t\tcontext: T,\n\t\tcallback: ContextCallback<ContextType<T>>,\n\t\tsubscribe: boolean = false,\n\t) {\n\t\tsuper(CONTEXT_REQUEST, {\n\t\t\tbubbles: true,\n\t\t\tcomposed: true,\n\t\t})\n\t\tthis.context = context\n\t\tthis.callback = callback\n\t\tthis.subscribe = subscribe\n\t}\n}\n\n/**\n * Provide a context for descendant component consumers\n *\n * @since 0.13.3\n * @param {Context<string, P[K]>[]} contexts - Array of contexts to provide\n * @returns {(host: Component<P>) => Cleanup} Function to add an event listener for ContextRequestEvent returning a cleanup function to remove the event listener\n */\nconst provideContexts =\n\t<P extends ComponentProps>(\n\t\tcontexts: Array<keyof P>,\n\t): ((host: Component<P>) => Cleanup) =>\n\t(host: Component<P>) => {\n\t\tconst listener = (e: ContextRequestEvent<UnknownContext>) => {\n\t\t\tconst { context, callback } = e\n\t\t\tif (\n\t\t\t\tisString(context) &&\n\t\t\t\tcontexts.includes(context as unknown as Extract<keyof P, string>) &&\n\t\t\t\tisFunction(callback)\n\t\t\t) {\n\t\t\t\te.stopImmediatePropagation()\n\t\t\t\tcallback(() => host[context])\n\t\t\t}\n\t\t}\n\t\thost.addEventListener(CONTEXT_REQUEST, listener)\n\t\treturn () => host.removeEventListener(CONTEXT_REQUEST, listener)\n\t}\n\n/**\n * Consume a context value for a component\n *\n * @since 0.15.0\n * @param {Context<string, () => T>} context - Context key to consume\n * @param {Fallback<T, U>} fallback - Fallback value or reader function for fallback\n * @returns {Reader<Computed<T>, U>} Computed signal that returns the consumed context the fallback value\n */\nconst requestContext =\n\t<T extends {}, P extends ComponentProps, U extends UI>(\n\t\tcontext: Context<string, () => T>,\n\t\tfallback: Fallback<T, U & { host: Component<P> }>,\n\t): Reader<Computed<T>, U & { host: Component<P> }> =>\n\t(ui: U & { host: Component<P> }) => {\n\t\tlet consumed = () => getFallback(ui, fallback)\n\t\tui.host.dispatchEvent(\n\t\t\tnew ContextRequestEvent(context, (getter: () => T) => {\n\t\t\t\tconsumed = getter\n\t\t\t}),\n\t\t)\n\t\treturn new Memo(consumed)\n\t}\n\nexport {\n\ttype Context,\n\ttype UnknownContext,\n\ttype ContextType,\n\tCONTEXT_REQUEST,\n\tContextRequestEvent,\n\tprovideContexts,\n\trequestContext,\n}\n",
    "import type { ComponentProps } from '../component'\nimport { type Effect, type Reactive, updateElement } from '../effects'\n\n/* === Internal Functions === */\n\nconst isSafeURL = (value: string): boolean => {\n\tif (/^(mailto|tel):/i.test(value)) return true\n\tif (value.includes('://')) {\n\t\ttry {\n\t\t\tconst url = new URL(value, window.location.origin)\n\t\t\treturn ['http:', 'https:', 'ftp:'].includes(url.protocol)\n\t\t} catch {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nconst safeSetAttribute = (\n\telement: Element,\n\tattr: string,\n\tvalue: string,\n): void => {\n\tif (/^on/i.test(attr)) throw new Error(`Unsafe attribute: ${attr}`)\n\tvalue = String(value).trim()\n\tif (!isSafeURL(value)) throw new Error(`Unsafe URL for ${attr}: ${value}`)\n\telement.setAttribute(attr, value)\n}\n\n/* === Exported Functions === */\n\n/**\n * Effect for setting an attribute on an element.\n * Sets the specified attribute with security validation for unsafe values.\n *\n * @since 0.8.0\n * @param {string} name - Name of the attribute to set\n * @param {Reactive<string, P, E>} reactive - Reactive value bound to the attribute value (defaults to attribute name)\n * @returns {Effect<P, E>} Effect function that sets the attribute on the element\n */\nconst setAttribute = <P extends ComponentProps, E extends Element>(\n\tname: string,\n\treactive: Reactive<string, P, E> = name as Reactive<string, P, E>,\n): Effect<P, E> =>\n\tupdateElement(reactive, {\n\t\top: 'a',\n\t\tname,\n\t\tread: el => el.getAttribute(name),\n\t\tupdate: (el, value) => {\n\t\t\tsafeSetAttribute(el, name, value)\n\t\t},\n\t\tdelete: el => {\n\t\t\tel.removeAttribute(name)\n\t\t},\n\t})\n\n/**\n * Effect for toggling a boolean attribute on an element.\n * When the reactive value is true, the attribute is present; when false, it's absent.\n *\n * @since 0.8.0\n * @param {string} name - Name of the attribute to toggle\n * @param {Reactive<boolean, P, E>} reactive - Reactive value bound to the attribute presence (defaults to attribute name)\n * @returns {Effect<P, E>} Effect function that toggles the attribute on the element\n */\nconst toggleAttribute = <\n\tP extends ComponentProps,\n\tE extends Element = HTMLElement,\n>(\n\tname: string,\n\treactive: Reactive<boolean, P, E> = name as Reactive<boolean, P, E>,\n): Effect<P, E> =>\n\tupdateElement(reactive, {\n\t\top: 'a',\n\t\tname,\n\t\tread: el => el.hasAttribute(name),\n\t\tupdate: (el, value) => {\n\t\t\tel.toggleAttribute(name, value)\n\t\t},\n\t})\n\nexport { setAttribute, toggleAttribute }\n",
    "import type { ComponentProps } from '../component'\nimport { type Effect, type Reactive, updateElement } from '../effects'\n\n/* === Exported Function === */\n\n/**\n * Effect for toggling a CSS class token on an element.\n * When the reactive value is true, the class is added; when false, it's removed.\n *\n * @since 0.8.0\n * @param {string} token - CSS class token to toggle\n * @param {Reactive<boolean, P, E>} reactive - Reactive value bound to the class presence (defaults to class name)\n * @returns {Effect<P, U, E>} Effect function that toggles the class on the element\n */\nconst toggleClass = <P extends ComponentProps, E extends Element>(\n\ttoken: string,\n\treactive: Reactive<boolean, P, E> = token as Reactive<boolean, P, E>,\n): Effect<P, E> =>\n\tupdateElement(reactive, {\n\t\top: 'c',\n\t\tname: token,\n\t\tread: el => el.classList.contains(token),\n\t\tupdate: (el, value) => {\n\t\t\tel.classList.toggle(token, value)\n\t\t},\n\t})\n\nexport { toggleClass }\n",
    "/* === Constants === */\n\n// High-frequency events that are passive by default and should be scheduled\nconst PASSIVE_EVENTS = new Set([\n\t'scroll',\n\t'resize',\n\t'mousewheel',\n\t'touchstart',\n\t'touchmove',\n\t'wheel',\n])\n\n/* === Internal === */\n\nconst pendingElements = new Set<Element>()\nconst tasks = new WeakMap<Element, () => void>()\nlet requestId: number | undefined\n\nconst runTasks = () => {\n\trequestId = undefined\n\tconst elements = Array.from(pendingElements)\n\tpendingElements.clear()\n\tfor (const element of elements) tasks.get(element)?.()\n}\n\nconst requestTick = () => {\n\tif (requestId) cancelAnimationFrame(requestId)\n\trequestId = requestAnimationFrame(runTasks)\n}\n\n/* === Exported Function === */\n\n/**\n * Schedule a task to be executed on the next animation frame, with automatic\n * deduplication per component. If the same component schedules multiple tasks\n * before the next frame, only the latest task will be executed.\n *\n * @param element - Element for deduplication\n * @param task - Function to execute (typically calls batch() or sets a signal)\n */\nconst schedule = (element: Element, task: () => void) => {\n\ttasks.set(element, task)\n\tpendingElements.add(element)\n\trequestTick()\n}\n\nexport { PASSIVE_EVENTS, schedule }\n",
    "import { batchSignalWrites, type Cleanup, isRecord } from '@zeix/cause-effect'\nimport type { ComponentProps } from '../component'\nimport { type Effect } from '../effects'\nimport { PASSIVE_EVENTS, schedule } from '../scheduler'\nimport { elementName, LOG_ERROR, log } from '../util'\n\n/* === Types === */\n\ntype EventType<K extends string> = K extends keyof HTMLElementEventMap\n\t? HTMLElementEventMap[K]\n\t: Event\n\ntype EventHandler<P extends ComponentProps, Evt extends Event> = (\n\tevent: Evt,\n) => { [K in keyof P]?: P[K] } | void | Promise<void>\n\n/* === Exported Function === */\n\n/**\n * Effect for attaching an event listener to an element.\n * Provides proper cleanup when the effect is disposed.\n *\n * @since 0.14.0\n * @param {K} type - Event type\n * @param {EventHandler<P, E, EventType<K>>} handler - Event handler function\n * @param {AddEventListenerOptions | boolean} options - Event listener options\n * @returns {Effect<ComponentProps, E>} Effect function that manages the event listener\n */\nconst on =\n\t<\n\t\tK extends keyof HTMLElementEventMap | string,\n\t\tP extends ComponentProps,\n\t\tE extends Element = HTMLElement,\n\t>(\n\t\ttype: K,\n\t\thandler: EventHandler<P, EventType<K>>,\n\t\toptions: AddEventListenerOptions = {},\n\t): Effect<P, E> =>\n\t(host, target): Cleanup => {\n\t\tif (!('passive' in options))\n\t\t\toptions = { ...options, passive: PASSIVE_EVENTS.has(type) }\n\t\tconst listener = (e: Event) => {\n\t\t\tconst task = () => {\n\t\t\t\tconst result = handler(e as EventType<K>)\n\t\t\t\tif (!isRecord(result)) return\n\t\t\t\tbatchSignalWrites(() => {\n\t\t\t\t\tfor (const [key, value] of Object.entries(result)) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\thost[key as keyof P] = value\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\tlog(\n\t\t\t\t\t\t\t\terror,\n\t\t\t\t\t\t\t\t`Reactive property \"${key}\" on ${elementName(host)} from event ${type} on ${elementName(target)} could not be set, because it is read-only.`,\n\t\t\t\t\t\t\t\tLOG_ERROR,\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t\tif (options.passive) schedule(target, task)\n\t\t\telse task()\n\t\t}\n\t\ttarget.addEventListener(type, listener, options)\n\t\treturn () => target.removeEventListener(type, listener)\n\t}\n\nexport { type EventHandler, type EventType, on }\n",
    "import type { ComponentProps } from '../component'\nimport { type Effect, type Reactive, updateElement } from '../effects'\nimport { schedule } from '../scheduler'\n\n/* === Types === */\n\ntype DangerouslySetInnerHTMLOptions = {\n\tshadowRootMode?: ShadowRootMode\n\tallowScripts?: boolean\n}\n\n/* === Exported Function === */\n\n/**\n * Effect for setting the inner HTML of an element with optional Shadow DOM support.\n * Provides security options for script execution and shadow root creation.\n *\n * @since 0.11.0\n * @param {Reactive<string, P, E>} reactive - Reactive value bound to the inner HTML content\n * @param {DangerouslySetInnerHTMLOptions} options - Configuration options: shadowRootMode, allowScripts\n * @returns {Effect<P, E>} Effect function that sets the inner HTML of the element\n */\nconst dangerouslySetInnerHTML = <P extends ComponentProps, E extends Element>(\n\treactive: Reactive<string, P, E>,\n\toptions: DangerouslySetInnerHTMLOptions = {},\n): Effect<P, E> =>\n\tupdateElement(reactive, {\n\t\top: 'h',\n\t\tread: el =>\n\t\t\t(el.shadowRoot || !options.shadowRootMode ? el : null)?.innerHTML ?? '',\n\t\tupdate: (el, html) => {\n\t\t\tconst { shadowRootMode, allowScripts } = options\n\t\t\tif (!html) {\n\t\t\t\tif (el.shadowRoot) el.shadowRoot.innerHTML = '<slot></slot>'\n\t\t\t\treturn ''\n\t\t\t}\n\t\t\tif (shadowRootMode && !el.shadowRoot)\n\t\t\t\tel.attachShadow({ mode: shadowRootMode })\n\t\t\tconst target = el.shadowRoot || el\n\t\t\tschedule(el, () => {\n\t\t\t\ttarget.innerHTML = html\n\t\t\t\tif (allowScripts) {\n\t\t\t\t\ttarget.querySelectorAll('script').forEach(script => {\n\t\t\t\t\t\tconst newScript = document.createElement('script')\n\t\t\t\t\t\tnewScript.appendChild(\n\t\t\t\t\t\t\tdocument.createTextNode(script.textContent ?? ''),\n\t\t\t\t\t\t)\n\t\t\t\t\t\t// Safely copy only the type attribute to preserve module/MIME type info\n\t\t\t\t\t\tconst typeAttr = script.getAttribute('type')\n\t\t\t\t\t\tif (typeAttr) newScript.setAttribute('type', typeAttr)\n\t\t\t\t\t\ttarget.appendChild(newScript)\n\t\t\t\t\t\tscript.remove()\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t})\n\t\t\treturn allowScripts ? ' with scripts' : ''\n\t\t},\n\t})\n\nexport { type DangerouslySetInnerHTMLOptions, dangerouslySetInnerHTML }\n",
    "import {\n\tisFunction,\n\tisMemoCallback,\n\tisRecord,\n\tisSignal,\n\tisString,\n\ttype MaybeCleanup,\n\tMemo,\n\ttype MemoCallback,\n\tUNSET,\n} from '@zeix/cause-effect'\nimport type { Component, ComponentProps } from '../component'\nimport type { Effect, Reactive } from '../effects'\nimport { InvalidCustomElementError, InvalidReactivesError } from '../errors'\nimport { elementName, isCustomElement } from '../util'\n\n/* === Types === */\n\ntype PassedProp<T, P extends ComponentProps, E extends HTMLElement> =\n\t| Reactive<T, P, E>\n\t| [Reactive<T, P, E>, (value: T) => void]\n\ntype PassedProps<P extends ComponentProps, Q extends ComponentProps> = {\n\t[K in keyof Q & string]?: PassedProp<Q[K], P, Component<Q>>\n}\n\n/* === Exported Function === */\n\n/**\n * Effect for passing reactive values to a descendant Le Truc component.\n *\n * @since 0.15.0\n * @param {MutableReactives<Component<Q>, P>} props - Reactive values to pass\n * @returns {Effect<P, Component<Q>>} Effect function that passes reactive values to the descendant component\n * @throws {InvalidCustomElementError} When the target element is not a valid custom element\n * @throws {InvalidReactivesError} When the provided reactives is not a record of signals, reactive property names or functions\n * @throws {Error} When passing signals failed for some other reason\n */\nconst pass =\n\t<P extends ComponentProps, Q extends ComponentProps>(\n\t\tprops: PassedProps<P, Q> | ((target: Component<Q>) => PassedProps<P, Q>),\n\t): Effect<P, Component<Q>> =>\n\t(host, target): MaybeCleanup => {\n\t\tif (!isCustomElement(target))\n\t\t\tthrow new InvalidCustomElementError(\n\t\t\t\ttarget,\n\t\t\t\t`pass from ${elementName(host)}`,\n\t\t\t)\n\t\tconst reactives = isFunction(props) ? props(target) : props\n\t\tif (!isRecord(reactives))\n\t\t\tthrow new InvalidReactivesError(host, target, reactives)\n\n\t\tconst resetProperties: PropertyDescriptorMap = {}\n\n\t\t// Return getter from signal, reactive property name or function\n\t\tconst getGetter = (value: unknown) => {\n\t\t\tif (isSignal(value)) return value.get\n\t\t\tconst fn =\n\t\t\t\tisString(value) && value in host\n\t\t\t\t\t? ((() => host[value as keyof typeof host]) as MemoCallback<\n\t\t\t\t\t\t\tunknown & {}\n\t\t\t\t\t\t>)\n\t\t\t\t\t: isMemoCallback(value)\n\t\t\t\t\t\t? value\n\t\t\t\t\t\t: undefined\n\t\t\treturn fn ? new Memo(fn).get : undefined\n\t\t}\n\n\t\t// Iterate through reactives\n\t\tfor (const [prop, reactive] of Object.entries(reactives)) {\n\t\t\tif (reactive == null) continue\n\n\t\t\t// Ensure target has configurable property\n\t\t\tconst descriptor = Object.getOwnPropertyDescriptor(target, prop)\n\t\t\tif (!(prop in target) || !descriptor?.configurable) continue\n\n\t\t\t// Determine getter\tand setter\n\t\t\tconst applied =\n\t\t\t\tisFunction(reactive) && reactive.length === 1\n\t\t\t\t\t? reactive(target)\n\t\t\t\t\t: reactive\n\t\t\tconst isArray = Array.isArray(applied) && applied.length === 2\n\t\t\tconst getter = getGetter(isArray ? applied[0] : applied)\n\t\t\tconst setter = isArray && isFunction(applied[1]) ? applied[1] : undefined\n\t\t\tif (!getter) continue\n\n\t\t\t// Store original descriptor for reset and assign new descriptor\n\t\t\tresetProperties[prop] = descriptor\n\t\t\tObject.defineProperty(target, prop, {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tget: getter,\n\t\t\t\tset: setter,\n\t\t\t})\n\n\t\t\t// Unset previous value so subscribers are notified\n\t\t\tdescriptor.set?.call(target, UNSET)\n\t\t}\n\n\t\t// Reset to original descriptors on cleanup\n\t\treturn () => {\n\t\t\tObject.defineProperties(target, resetProperties)\n\t\t}\n\t}\n\nexport { type PassedProp, type PassedProps, pass }\n",
    "import { UNSET } from '@zeix/cause-effect'\nimport type { ComponentProps } from '../component'\nimport { type Effect, type Reactive, updateElement } from '../effects'\n\n/* === Exported Functions === */\n\n/**\n * Effect for setting a property on an element.\n * Sets the specified property directly on the element object.\n *\n * @since 0.8.0\n * @param {K} key - Name of the property to set\n * @param {Reactive<E[K], P, E>} reactive - Reactive value bound to the property value (defaults to property name)\n * @returns {Effect<P, E>} Effect function that sets the property on the element\n */\nconst setProperty = <\n\tP extends ComponentProps,\n\tE extends Element,\n\tK extends keyof E & string,\n>(\n\tkey: K,\n\treactive: Reactive<E[K] & {}, P, E> = key as unknown as Reactive<\n\t\tE[K] & {},\n\t\tP,\n\t\tE\n\t>,\n): Effect<P, E> =>\n\tupdateElement(reactive, {\n\t\top: 'p',\n\t\tname: key,\n\t\tread: el => (key in el ? el[key] : UNSET),\n\t\tupdate: (el, value) => {\n\t\t\tel[key] = value\n\t\t},\n\t})\n\n/**\n * Effect for controlling element visibility by setting the 'hidden' property.\n * When the reactive value is true, the element is shown; when false, it's hidden.\n *\n * @since 0.13.1\n * @param {Reactive<boolean, P, E>} reactive - Reactive value bound to the visibility state\n * @returns {Effect<P, E>} Effect function that controls element visibility\n */\nconst show = <P extends ComponentProps, E extends HTMLElement = HTMLElement>(\n\treactive: Reactive<boolean, P, E>,\n): Effect<P, E> =>\n\tupdateElement(reactive, {\n\t\top: 'p',\n\t\tname: 'hidden',\n\t\tread: el => !el.hidden,\n\t\tupdate: (el, value) => {\n\t\t\tel.hidden = !value\n\t\t},\n\t})\n\nexport { setProperty, show }\n",
    "import type { ComponentProps } from '../component'\nimport { type Effect, type Reactive, updateElement } from '../effects'\n\n/* === Exported Function === */\n\n/**\n * Effect for setting a CSS style property on an element.\n * Sets the specified style property with support for deletion via UNSET.\n *\n * @since 0.8.0\n * @param {string} prop - Name of the CSS style property to set\n * @param {Reactive<string, P, E>} reactive - Reactive value bound to the style property value (defaults to property name)\n * @returns {Effect<P, E>} Effect function that sets the style property on the element\n */\nconst setStyle = <\n\tP extends ComponentProps,\n\tE extends HTMLElement | SVGElement | MathMLElement,\n>(\n\tprop: string,\n\treactive: Reactive<string, P, E> = prop as Reactive<string, P, E>,\n): Effect<P, E> =>\n\tupdateElement(reactive, {\n\t\top: 's',\n\t\tname: prop,\n\t\tread: el => el.style.getPropertyValue(prop),\n\t\tupdate: (el, value) => {\n\t\t\tel.style.setProperty(prop, value)\n\t\t},\n\t\tdelete: el => {\n\t\t\tel.style.removeProperty(prop)\n\t\t},\n\t})\n\nexport { setStyle }\n",
    "import type { ComponentProps } from '../component'\nimport { type Effect, type Reactive, updateElement } from '../effects'\n\n/* === Exported Function === */\n\n/**\n * Effect for setting the text content of an element.\n * Replaces all child nodes (except comments) with a single text node.\n *\n * @since 0.8.0\n * @param {Reactive<string, P, E>} reactive - Reactive value bound to the text content\n * @returns {Effect<P, E>} Effect function that sets the text content of the element\n */\nconst setText = <P extends ComponentProps, E extends Element>(\n\treactive: Reactive<string, P, E>,\n): Effect<P, E> =>\n\tupdateElement(reactive, {\n\t\top: 't',\n\t\tread: el => el.textContent,\n\t\tupdate: (el, value) => {\n\t\t\tArray.from(el.childNodes)\n\t\t\t\t.filter(node => node.nodeType !== Node.COMMENT_NODE)\n\t\t\t\t.forEach(node => node.remove())\n\t\t\tel.append(document.createTextNode(value))\n\t\t},\n\t})\n\nexport { setText }\n",
    "import type { Parser } from '../parsers'\nimport type { UI } from '../ui'\n\n/**\n * Parse a boolean attribute as an actual boolean value\n *\n * @since 0.13.1\n * @returns {Parser<boolean, UI>}\n */\nconst asBoolean =\n\t(): Parser<boolean, UI> => (_: UI, value: string | null | undefined) =>\n\t\tvalue != null && value !== 'false'\n\nexport { asBoolean }\n",
    "import { type Fallback, getFallback, type Parser } from '../parsers'\nimport type { UI } from '../ui'\n\n/**\n * Parse a string as a JSON serialized object with a fallback\n *\n * @since 0.11.0\n * @param {Fallback<T, U>} fallback - Fallback value or reader function\n * @returns {Parser<T, U>} Parser function\n * @throws {TypeError} If the value and fallback are both null or undefined\n * @throws {SyntaxError} If value is not a valid JSON string\n */\nconst asJSON =\n\t<T extends {}, U extends UI>(fallback: Fallback<T, U>): Parser<T, U> =>\n\t(ui: U, value: string | null | undefined) => {\n\t\tif ((value ?? fallback) == null)\n\t\t\tthrow new TypeError(\n\t\t\t\t'asJSON: Value and fallback are both null or undefined',\n\t\t\t)\n\t\tif (value == null) return getFallback(ui, fallback)\n\t\tif (value === '') throw new TypeError('Empty string is not valid JSON')\n\t\tlet result: T | undefined\n\t\ttry {\n\t\t\tresult = JSON.parse(value)\n\t\t} catch (error) {\n\t\t\tthrow new SyntaxError(`Failed to parse JSON: ${String(error)}`, {\n\t\t\t\tcause: error,\n\t\t\t})\n\t\t}\n\t\treturn result ?? getFallback(ui, fallback)\n\t}\n\nexport { asJSON }\n",
    "import { type Fallback, getFallback, type Parser } from '../parsers'\nimport type { UI } from '../ui'\n\n/* === Internal Functions === */\n\nconst parseNumber = (\n\tparseFn: (v: string) => number,\n\tvalue: string | null | undefined,\n) => {\n\tif (value == null) return\n\tconst parsed = parseFn(value)\n\treturn Number.isFinite(parsed) ? parsed : undefined\n}\n\n/* === Exported Functions === */\n\n/**\n * Parse a string as a number forced to integer with a fallback\n *\n * Supports hexadecimal and scientific notation\n *\n * @since 0.11.0\n * @param {Fallback<number, U>} [fallback=0] - Fallback value or reader function\n * @returns {Parser<number, U>} Parser function\n */\nconst asInteger =\n\t<U extends UI>(fallback: Fallback<number, U> = 0): Parser<number, U> =>\n\t(ui: U, value: string | null | undefined) => {\n\t\tif (value == null) return getFallback(ui, fallback)\n\n\t\t// Handle hexadecimal notation\n\t\tconst trimmed = value.trim()\n\t\tif (trimmed.toLowerCase().startsWith('0x'))\n\t\t\treturn (\n\t\t\t\tparseNumber(v => parseInt(v, 16), trimmed) ?? getFallback(ui, fallback)\n\t\t\t)\n\n\t\t// Handle other formats (including scientific notation)\n\t\tconst parsed = parseNumber(parseFloat, value)\n\t\treturn parsed != null ? Math.trunc(parsed) : getFallback(ui, fallback)\n\t}\n\n/**\n * Parse a string as a number with a fallback\n *\n * @since 0.11.0\n * @param {Fallback<number, U>} [fallback=0] - Fallback value or reader function\n * @returns {Parser<number, U>} Parser function\n */\nconst asNumber =\n\t<U extends UI>(fallback: Fallback<number, U> = 0): Parser<number, U> =>\n\t(ui: U, value: string | null | undefined) =>\n\t\tparseNumber(parseFloat, value) ?? getFallback(ui, fallback)\n\nexport { asInteger, asNumber }\n",
    "import { type Fallback, getFallback, type Parser } from '../parsers'\nimport type { UI } from '../ui'\n\n/**\n * Pass through string with a fallback\n *\n * @since 0.11.0\n * @param {Fallback<string, U>} [fallback=''] - Fallback value or reader function\n * @returns {Parser<string, U>} Parser function\n */\nconst asString =\n\t<U extends UI>(fallback: Fallback<string, U> = ''): Parser<string, U> =>\n\t(ui: U, value: string | null | undefined) =>\n\t\tvalue ?? getFallback(ui, fallback)\n\n/**\n * Parse a string as a multi-state value (for example: ['true', 'false', 'mixed'], defaulting to the first valid option\n *\n * @since 0.9.0\n * @param {[string, ...string[]]} valid - Array of valid values\n * @returns {Parser<string, UI>} Parser function\n */\nconst asEnum =\n\t(valid: [string, ...string[]]): Parser<string, UI> =>\n\t(_: UI, value: string | null | undefined) => {\n\t\tif (value == null) return valid[0]\n\t\tconst lowerValue = value.toLowerCase()\n\t\tconst matchingValid = valid.find(v => v.toLowerCase() === lowerValue)\n\t\treturn matchingValid ? value : valid[0]\n\t}\n\nexport { asString, asEnum }\n",
    "import {\n\ttype Cleanup,\n\ttype Collection,\n\ttype Computed,\n\tisCollection,\n\tnotifyWatchers,\n\tsubscribeActiveWatcher,\n\tTYPE_COMPUTED,\n\ttype Watcher,\n} from '@zeix/cause-effect'\nimport type { Component, ComponentProps } from '../component'\nimport { InvalidUIKeyError } from '../errors'\nimport { getFallback, type ParserOrFallback } from '../parsers'\nimport { PASSIVE_EVENTS, schedule } from '../scheduler'\nimport type { ElementFromKey, UI } from '../ui'\n\n/* === Types === */\n\ntype EventType<K extends string> = K extends keyof HTMLElementEventMap\n\t? HTMLElementEventMap[K]\n\t: Event\n\ntype SensorHandler<\n\tT extends {},\n\tEvt extends Event,\n\tU extends UI,\n\tE extends Element,\n> = (context: {\n\tevent: Evt\n\tui: U\n\ttarget: E\n\tprev: T\n}) => T | void | Promise<void>\n\ntype SensorEvents<T extends {}, U extends UI, E extends Element> = {\n\t[K in keyof HTMLElementEventMap]?: SensorHandler<T, EventType<K>, U, E>\n}\n\n/* === Internal Function === */\n\nfunction getTarget<E extends Element>(\n\ttargets: E | Collection<E>,\n\teventTarget: Node,\n): E | undefined {\n\tconst elements = isCollection(targets) ? targets.get() : [targets]\n\tfor (const t of elements) if (t.contains(eventTarget)) return t\n}\n\n/* === Class === */\n\nclass Sensor<\n\tT extends {},\n\tU extends UI & { host: HTMLElement },\n\tE extends Element,\n> {\n\t#watchers = new Set<Watcher>()\n\t#value: T\n\t#host: HTMLElement\n\t#events = new Map<string, EventListener>()\n\t#cleanup: Cleanup | undefined\n\n\tconstructor(\n\t\tui: U,\n\t\tkey: string,\n\t\tevents: SensorEvents<T, U, E>,\n\t\tinitialValue: T,\n\t) {\n\t\tif (!ui[key]) throw new InvalidUIKeyError(ui.host, key, 'sensor')\n\n\t\tthis.#host = ui.host\n\t\tthis.#value = initialValue\n\t\tconst targets = ui[key] as E | Collection<E>\n\n\t\tfor (const [type, handler] of Object.entries(events)) {\n\t\t\tthis.#events.set(\n\t\t\t\ttype,\n\t\t\t\tthis.#getEventListener(\n\t\t\t\t\ttype,\n\t\t\t\t\thandler as SensorHandler<T, EventType<typeof type>, U, E>,\n\t\t\t\t\tui,\n\t\t\t\t\ttargets,\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\t}\n\n\t#getEventListener<K extends string>(\n\t\ttype: K,\n\t\thandler: SensorHandler<T, EventType<K>, U, E>,\n\t\tui: U,\n\t\ttargets: E | Collection<E>,\n\t) {\n\t\tconst isPassive = PASSIVE_EVENTS.has(type)\n\n\t\treturn (e: Event) => {\n\t\t\tconst eventTarget = e.target as Node\n\t\t\tif (!eventTarget) return\n\t\t\tconst target = getTarget(targets, eventTarget)\n\t\t\tif (!target) return\n\t\t\te.stopPropagation()\n\n\t\t\tconst task = () => {\n\t\t\t\ttry {\n\t\t\t\t\tconst next = handler({\n\t\t\t\t\t\tevent: e as EventType<K>,\n\t\t\t\t\t\tui,\n\t\t\t\t\t\ttarget,\n\t\t\t\t\t\tprev: this.#value,\n\t\t\t\t\t})\n\t\t\t\t\tif (next == null || next instanceof Promise) return\n\t\t\t\t\tif (!Object.is(next, this.#value)) {\n\t\t\t\t\t\tthis.#value = next\n\t\t\t\t\t\tif (this.#watchers.size) notifyWatchers(this.#watchers)\n\t\t\t\t\t\telse if (this.#cleanup) this.#cleanup()\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\te.stopImmediatePropagation()\n\t\t\t\t\tthrow error\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isPassive) schedule(this.#host, task)\n\t\t\telse task()\n\t\t}\n\t}\n\n\tget [Symbol.toStringTag](): 'Computed' {\n\t\treturn TYPE_COMPUTED\n\t}\n\n\t/**\n\t * Return the memoized value after computing it if necessary.\n\t *\n\t * @returns {T}\n\t */\n\tget(): T {\n\t\tsubscribeActiveWatcher(this.#watchers)\n\t\tif (this.#watchers.size && !this.#cleanup) {\n\t\t\tfor (const [type, listener] of this.#events) {\n\t\t\t\tconst options = { passive: PASSIVE_EVENTS.has(type) }\n\t\t\t\tthis.#host.addEventListener(type, listener, options)\n\t\t\t}\n\t\t\tthis.#cleanup = () => {\n\t\t\t\tfor (const [type, listener] of this.#events)\n\t\t\t\t\tthis.#host.removeEventListener(type, listener)\n\t\t\t\tthis.#cleanup = undefined\n\t\t\t}\n\t\t}\n\t\treturn this.#value\n\t}\n}\n\n/* === Exported Functions === */\n\n/**\n * Create a computed signal from transformed event data\n *\n * @since 0.14.0\n * @param {ParserOrFallback<T, U>} init - Initial value, reader or parser\n * @param {K} key - Name of UI key\n * @param {SensorEvents<T, U, ElementFromKey<U, K>>} events - Transformation functions for events\n * @returns {Extractor<Computed<T>, C>} Extractor function for value from event\n */\nconst createSensor =\n\t<\n\t\tT extends {},\n\t\tP extends ComponentProps,\n\t\tU extends UI,\n\t\tK extends keyof U & string,\n\t>(\n\t\tinit: ParserOrFallback<T, U>,\n\t\tkey: K,\n\t\tevents: SensorEvents<T, U, ElementFromKey<U, K>>,\n\t): ((ui: U & { host: Component<P> }) => Computed<T>) =>\n\t(ui: U & { host: Component<P> }) => {\n\t\tconst value: T = getFallback(ui, init)\n\n\t\treturn new Sensor(ui, key, events, value)\n\t}\n\nexport { createSensor, type SensorEvents }\n"
  ],
  "mappings": "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",
  "debugId": "3749C45885FA1B6964756E2164756E21",
  "names": []
}